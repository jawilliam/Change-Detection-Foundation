
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Jawilliam.CDF.CSharp.Diagnostic
{
    public partial class IrrationalityBasedDiagnostic
    {
    	#region Inserted(XElement, int, XElement)'s Visit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Inserted(XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Inserted(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCore(XElement, XElement)"/> is not executed and <see cref="Inserted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCore(XElement, XElement)"/>.</param>
        partial void InsertedAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Analyzes a insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="Inserted(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCore(XElement property, int position, XElement parent)
    	{
    		if(parent == null)
    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
    		switch(parent.Name.LocalName)
    		{
    			case "AttributeArgument": return this.InsertedAttributeArgument(property, position, parent);
    			case "NameEquals": return this.InsertedNameEquals(property, position, parent);
    			case "TypeParameterList": return this.InsertedTypeParameterList(property, position, parent);
    			case "TypeParameter": return this.InsertedTypeParameter(property, position, parent);
    			case "BaseList": return this.InsertedBaseList(property, position, parent);
    			case "TypeParameterConstraintClause": return this.InsertedTypeParameterConstraintClause(property, position, parent);
    			case "ExplicitInterfaceSpecifier": return this.InsertedExplicitInterfaceSpecifier(property, position, parent);
    			case "ConstructorInitializer": return this.InsertedConstructorInitializer(property, position, parent);
    			case "ArrowExpressionClause": return this.InsertedArrowExpressionClause(property, position, parent);
    			case "AccessorList": return this.InsertedAccessorList(property, position, parent);
    			case "AccessorDeclaration": return this.InsertedAccessorDeclaration(property, position, parent);
    			case "Parameter": return this.InsertedParameter(property, position, parent);
    			case "CrefParameter": return this.InsertedCrefParameter(property, position, parent);
    			case "XmlElementStartTag": return this.InsertedXmlElementStartTag(property, position, parent);
    			case "XmlElementEndTag": return this.InsertedXmlElementEndTag(property, position, parent);
    			case "XmlName": return this.InsertedXmlName(property, position, parent);
    			case "XmlPrefix": return this.InsertedXmlPrefix(property, position, parent);
    			case "TypeArgumentList": return this.InsertedTypeArgumentList(property, position, parent);
    			case "ArrayRankSpecifier": return this.InsertedArrayRankSpecifier(property, position, parent);
    			case "TupleElement": return this.InsertedTupleElement(property, position, parent);
    			case "Argument": return this.InsertedArgument(property, position, parent);
    			case "NameColon": return this.InsertedNameColon(property, position, parent);
    			case "AnonymousObjectMemberDeclarator": return this.InsertedAnonymousObjectMemberDeclarator(property, position, parent);
    			case "QueryBody": return this.InsertedQueryBody(property, position, parent);
    			case "JoinIntoClause": return this.InsertedJoinIntoClause(property, position, parent);
    			case "Ordering": return this.InsertedOrdering(property, position, parent);
    			case "QueryContinuation": return this.InsertedQueryContinuation(property, position, parent);
    			case "WhenClause": return this.InsertedWhenClause(property, position, parent);
    			case "InterpolationAlignmentClause": return this.InsertedInterpolationAlignmentClause(property, position, parent);
    			case "InterpolationFormatClause": return this.InsertedInterpolationFormatClause(property, position, parent);
    			case "VariableDeclaration": return this.InsertedVariableDeclaration(property, position, parent);
    			case "VariableDeclarator": return this.InsertedVariableDeclarator(property, position, parent);
    			case "EqualsValueClause": return this.InsertedEqualsValueClause(property, position, parent);
    			case "ElseClause": return this.InsertedElseClause(property, position, parent);
    			case "SwitchSection": return this.InsertedSwitchSection(property, position, parent);
    			case "CatchClause": return this.InsertedCatchClause(property, position, parent);
    			case "CatchDeclaration": return this.InsertedCatchDeclaration(property, position, parent);
    			case "CatchFilterClause": return this.InsertedCatchFilterClause(property, position, parent);
    			case "FinallyClause": return this.InsertedFinallyClause(property, position, parent);
    			case "CompilationUnit": return this.InsertedCompilationUnit(property, position, parent);
    			case "ExternAliasDirective": return this.InsertedExternAliasDirective(property, position, parent);
    			case "UsingDirective": return this.InsertedUsingDirective(property, position, parent);
    			case "AttributeList": return this.InsertedAttributeList(property, position, parent);
    			case "AttributeTargetSpecifier": return this.InsertedAttributeTargetSpecifier(property, position, parent);
    			case "Attribute": return this.InsertedAttribute(property, position, parent);
    			case "AttributeArgumentList": return this.InsertedAttributeArgumentList(property, position, parent);
    			case "DelegateDeclaration": return this.InsertedDelegateDeclaration(property, position, parent);
    			case "EnumMemberDeclaration": return this.InsertedEnumMemberDeclaration(property, position, parent);
    			case "IncompleteMember": return this.InsertedIncompleteMember(property, position, parent);
    			case "GlobalStatement": return this.InsertedGlobalStatement(property, position, parent);
    			case "NamespaceDeclaration": return this.InsertedNamespaceDeclaration(property, position, parent);
    			case "EnumDeclaration": return this.InsertedEnumDeclaration(property, position, parent);
    			case "ClassDeclaration": return this.InsertedClassDeclaration(property, position, parent);
    			case "StructDeclaration": return this.InsertedStructDeclaration(property, position, parent);
    			case "InterfaceDeclaration": return this.InsertedInterfaceDeclaration(property, position, parent);
    			case "FieldDeclaration": return this.InsertedFieldDeclaration(property, position, parent);
    			case "EventFieldDeclaration": return this.InsertedEventFieldDeclaration(property, position, parent);
    			case "MethodDeclaration": return this.InsertedMethodDeclaration(property, position, parent);
    			case "OperatorDeclaration": return this.InsertedOperatorDeclaration(property, position, parent);
    			case "ConversionOperatorDeclaration": return this.InsertedConversionOperatorDeclaration(property, position, parent);
    			case "ConstructorDeclaration": return this.InsertedConstructorDeclaration(property, position, parent);
    			case "DestructorDeclaration": return this.InsertedDestructorDeclaration(property, position, parent);
    			case "PropertyDeclaration": return this.InsertedPropertyDeclaration(property, position, parent);
    			case "EventDeclaration": return this.InsertedEventDeclaration(property, position, parent);
    			case "IndexerDeclaration": return this.InsertedIndexerDeclaration(property, position, parent);
    			case "SimpleBaseType": return this.InsertedSimpleBaseType(property, position, parent);
    			case "ConstructorConstraint": return this.InsertedConstructorConstraint(property, position, parent);
    			case "ClassOrStructConstraint": return this.InsertedClassOrStructConstraint(property, position, parent);
    			case "TypeConstraint": return this.InsertedTypeConstraint(property, position, parent);
    			case "ParameterList": return this.InsertedParameterList(property, position, parent);
    			case "BracketedParameterList": return this.InsertedBracketedParameterList(property, position, parent);
    			case "SkippedTokensTrivia": return this.InsertedSkippedTokensTrivia(property, position, parent);
    			case "DocumentationCommentTrivia": return this.InsertedDocumentationCommentTrivia(property, position, parent);
    			case "EndIfDirectiveTrivia": return this.InsertedEndIfDirectiveTrivia(property, position, parent);
    			case "RegionDirectiveTrivia": return this.InsertedRegionDirectiveTrivia(property, position, parent);
    			case "EndRegionDirectiveTrivia": return this.InsertedEndRegionDirectiveTrivia(property, position, parent);
    			case "ErrorDirectiveTrivia": return this.InsertedErrorDirectiveTrivia(property, position, parent);
    			case "WarningDirectiveTrivia": return this.InsertedWarningDirectiveTrivia(property, position, parent);
    			case "BadDirectiveTrivia": return this.InsertedBadDirectiveTrivia(property, position, parent);
    			case "DefineDirectiveTrivia": return this.InsertedDefineDirectiveTrivia(property, position, parent);
    			case "UndefDirectiveTrivia": return this.InsertedUndefDirectiveTrivia(property, position, parent);
    			case "LineDirectiveTrivia": return this.InsertedLineDirectiveTrivia(property, position, parent);
    			case "PragmaWarningDirectiveTrivia": return this.InsertedPragmaWarningDirectiveTrivia(property, position, parent);
    			case "PragmaChecksumDirectiveTrivia": return this.InsertedPragmaChecksumDirectiveTrivia(property, position, parent);
    			case "ReferenceDirectiveTrivia": return this.InsertedReferenceDirectiveTrivia(property, position, parent);
    			case "LoadDirectiveTrivia": return this.InsertedLoadDirectiveTrivia(property, position, parent);
    			case "ShebangDirectiveTrivia": return this.InsertedShebangDirectiveTrivia(property, position, parent);
    			case "ElseDirectiveTrivia": return this.InsertedElseDirectiveTrivia(property, position, parent);
    			case "IfDirectiveTrivia": return this.InsertedIfDirectiveTrivia(property, position, parent);
    			case "ElifDirectiveTrivia": return this.InsertedElifDirectiveTrivia(property, position, parent);
    			case "TypeCref": return this.InsertedTypeCref(property, position, parent);
    			case "QualifiedCref": return this.InsertedQualifiedCref(property, position, parent);
    			case "NameMemberCref": return this.InsertedNameMemberCref(property, position, parent);
    			case "IndexerMemberCref": return this.InsertedIndexerMemberCref(property, position, parent);
    			case "OperatorMemberCref": return this.InsertedOperatorMemberCref(property, position, parent);
    			case "ConversionOperatorMemberCref": return this.InsertedConversionOperatorMemberCref(property, position, parent);
    			case "CrefParameterList": return this.InsertedCrefParameterList(property, position, parent);
    			case "CrefBracketedParameterList": return this.InsertedCrefBracketedParameterList(property, position, parent);
    			case "XmlElement": return this.InsertedXmlElement(property, position, parent);
    			case "XmlEmptyElement": return this.InsertedXmlEmptyElement(property, position, parent);
    			case "XmlText": return this.InsertedXmlText(property, position, parent);
    			case "XmlCDataSection": return this.InsertedXmlCDataSection(property, position, parent);
    			case "XmlProcessingInstruction": return this.InsertedXmlProcessingInstruction(property, position, parent);
    			case "XmlComment": return this.InsertedXmlComment(property, position, parent);
    			case "XmlTextAttribute": return this.InsertedXmlTextAttribute(property, position, parent);
    			case "XmlCrefAttribute": return this.InsertedXmlCrefAttribute(property, position, parent);
    			case "XmlNameAttribute": return this.InsertedXmlNameAttribute(property, position, parent);
    			case "ParenthesizedExpression": return this.InsertedParenthesizedExpression(property, position, parent);
    			case "TupleExpression": return this.InsertedTupleExpression(property, position, parent);
    			case "PrefixUnaryExpression": return this.InsertedPrefixUnaryExpression(property, position, parent);
    			case "AwaitExpression": return this.InsertedAwaitExpression(property, position, parent);
    			case "PostfixUnaryExpression": return this.InsertedPostfixUnaryExpression(property, position, parent);
    			case "MemberAccessExpression": return this.InsertedMemberAccessExpression(property, position, parent);
    			case "ConditionalAccessExpression": return this.InsertedConditionalAccessExpression(property, position, parent);
    			case "MemberBindingExpression": return this.InsertedMemberBindingExpression(property, position, parent);
    			case "ElementBindingExpression": return this.InsertedElementBindingExpression(property, position, parent);
    			case "ImplicitElementAccess": return this.InsertedImplicitElementAccess(property, position, parent);
    			case "BinaryExpression": return this.InsertedBinaryExpression(property, position, parent);
    			case "AssignmentExpression": return this.InsertedAssignmentExpression(property, position, parent);
    			case "ConditionalExpression": return this.InsertedConditionalExpression(property, position, parent);
    			case "LiteralExpression": return this.InsertedLiteralExpression(property, position, parent);
    			case "MakeRefExpression": return this.InsertedMakeRefExpression(property, position, parent);
    			case "RefTypeExpression": return this.InsertedRefTypeExpression(property, position, parent);
    			case "RefValueExpression": return this.InsertedRefValueExpression(property, position, parent);
    			case "CheckedExpression": return this.InsertedCheckedExpression(property, position, parent);
    			case "DefaultExpression": return this.InsertedDefaultExpression(property, position, parent);
    			case "TypeOfExpression": return this.InsertedTypeOfExpression(property, position, parent);
    			case "SizeOfExpression": return this.InsertedSizeOfExpression(property, position, parent);
    			case "InvocationExpression": return this.InsertedInvocationExpression(property, position, parent);
    			case "ElementAccessExpression": return this.InsertedElementAccessExpression(property, position, parent);
    			case "DeclarationExpression": return this.InsertedDeclarationExpression(property, position, parent);
    			case "CastExpression": return this.InsertedCastExpression(property, position, parent);
    			case "RefExpression": return this.InsertedRefExpression(property, position, parent);
    			case "InitializerExpression": return this.InsertedInitializerExpression(property, position, parent);
    			case "ObjectCreationExpression": return this.InsertedObjectCreationExpression(property, position, parent);
    			case "AnonymousObjectCreationExpression": return this.InsertedAnonymousObjectCreationExpression(property, position, parent);
    			case "ArrayCreationExpression": return this.InsertedArrayCreationExpression(property, position, parent);
    			case "ImplicitArrayCreationExpression": return this.InsertedImplicitArrayCreationExpression(property, position, parent);
    			case "StackAllocArrayCreationExpression": return this.InsertedStackAllocArrayCreationExpression(property, position, parent);
    			case "QueryExpression": return this.InsertedQueryExpression(property, position, parent);
    			case "OmittedArraySizeExpression": return this.InsertedOmittedArraySizeExpression(property, position, parent);
    			case "InterpolatedStringExpression": return this.InsertedInterpolatedStringExpression(property, position, parent);
    			case "IsPatternExpression": return this.InsertedIsPatternExpression(property, position, parent);
    			case "ThrowExpression": return this.InsertedThrowExpression(property, position, parent);
    			case "PredefinedType": return this.InsertedPredefinedType(property, position, parent);
    			case "ArrayType": return this.InsertedArrayType(property, position, parent);
    			case "PointerType": return this.InsertedPointerType(property, position, parent);
    			case "NullableType": return this.InsertedNullableType(property, position, parent);
    			case "TupleType": return this.InsertedTupleType(property, position, parent);
    			case "OmittedTypeArgument": return this.InsertedOmittedTypeArgument(property, position, parent);
    			case "RefType": return this.InsertedRefType(property, position, parent);
    			case "QualifiedName": return this.InsertedQualifiedName(property, position, parent);
    			case "AliasQualifiedName": return this.InsertedAliasQualifiedName(property, position, parent);
    			case "IdentifierName": return this.InsertedIdentifierName(property, position, parent);
    			case "GenericName": return this.InsertedGenericName(property, position, parent);
    			case "ThisExpression": return this.InsertedThisExpression(property, position, parent);
    			case "BaseExpression": return this.InsertedBaseExpression(property, position, parent);
    			case "AnonymousMethodExpression": return this.InsertedAnonymousMethodExpression(property, position, parent);
    			case "SimpleLambdaExpression": return this.InsertedSimpleLambdaExpression(property, position, parent);
    			case "ParenthesizedLambdaExpression": return this.InsertedParenthesizedLambdaExpression(property, position, parent);
    			case "ArgumentList": return this.InsertedArgumentList(property, position, parent);
    			case "BracketedArgumentList": return this.InsertedBracketedArgumentList(property, position, parent);
    			case "FromClause": return this.InsertedFromClause(property, position, parent);
    			case "LetClause": return this.InsertedLetClause(property, position, parent);
    			case "JoinClause": return this.InsertedJoinClause(property, position, parent);
    			case "WhereClause": return this.InsertedWhereClause(property, position, parent);
    			case "OrderByClause": return this.InsertedOrderByClause(property, position, parent);
    			case "SelectClause": return this.InsertedSelectClause(property, position, parent);
    			case "GroupClause": return this.InsertedGroupClause(property, position, parent);
    			case "DeclarationPattern": return this.InsertedDeclarationPattern(property, position, parent);
    			case "ConstantPattern": return this.InsertedConstantPattern(property, position, parent);
    			case "InterpolatedStringText": return this.InsertedInterpolatedStringText(property, position, parent);
    			case "Interpolation": return this.InsertedInterpolation(property, position, parent);
    			case "Block": return this.InsertedBlock(property, position, parent);
    			case "LocalFunctionStatement": return this.InsertedLocalFunctionStatement(property, position, parent);
    			case "LocalDeclarationStatement": return this.InsertedLocalDeclarationStatement(property, position, parent);
    			case "ExpressionStatement": return this.InsertedExpressionStatement(property, position, parent);
    			case "EmptyStatement": return this.InsertedEmptyStatement(property, position, parent);
    			case "LabeledStatement": return this.InsertedLabeledStatement(property, position, parent);
    			case "GotoStatement": return this.InsertedGotoStatement(property, position, parent);
    			case "BreakStatement": return this.InsertedBreakStatement(property, position, parent);
    			case "ContinueStatement": return this.InsertedContinueStatement(property, position, parent);
    			case "ReturnStatement": return this.InsertedReturnStatement(property, position, parent);
    			case "ThrowStatement": return this.InsertedThrowStatement(property, position, parent);
    			case "YieldStatement": return this.InsertedYieldStatement(property, position, parent);
    			case "WhileStatement": return this.InsertedWhileStatement(property, position, parent);
    			case "DoStatement": return this.InsertedDoStatement(property, position, parent);
    			case "ForStatement": return this.InsertedForStatement(property, position, parent);
    			case "UsingStatement": return this.InsertedUsingStatement(property, position, parent);
    			case "FixedStatement": return this.InsertedFixedStatement(property, position, parent);
    			case "CheckedStatement": return this.InsertedCheckedStatement(property, position, parent);
    			case "UnsafeStatement": return this.InsertedUnsafeStatement(property, position, parent);
    			case "LockStatement": return this.InsertedLockStatement(property, position, parent);
    			case "IfStatement": return this.InsertedIfStatement(property, position, parent);
    			case "SwitchStatement": return this.InsertedSwitchStatement(property, position, parent);
    			case "TryStatement": return this.InsertedTryStatement(property, position, parent);
    			case "ForEachStatement": return this.InsertedForEachStatement(property, position, parent);
    			case "ForEachVariableStatement": return this.InsertedForEachVariableStatement(property, position, parent);
    			case "SingleVariableDesignation": return this.InsertedSingleVariableDesignation(property, position, parent);
    			case "DiscardDesignation": return this.InsertedDiscardDesignation(property, position, parent);
    			case "ParenthesizedVariableDesignation": return this.InsertedParenthesizedVariableDesignation(property, position, parent);
    			case "CasePatternSwitchLabel": return this.InsertedCasePatternSwitchLabel(property, position, parent);
    			case "CaseSwitchLabel": return this.InsertedCaseSwitchLabel(property, position, parent);
    			case "DefaultSwitchLabel": return this.InsertedDefaultSwitchLabel(property, position, parent);
                case "SingleLineCommentTrivia": return this.InsertedFromSingleLineCommentTrivia(property, position, parent);
                case "MultiLineCommentTrivia": return this.InsertedFromMultiLineCommentTrivia(property, position, parent);
    			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
    		}
    	}		
    	
        /// <summary>
        /// Analyzes a insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> Inserted(XElement property, int position, XElement parent)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	InsertedBefore(property, position, parent, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.InsertedCore(property, position, parent);
        	InsertedAfter(property, position, parent, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Deleted(ElementTree, XElement)'s Visit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Deleted(XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Deleted(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCore(XElement, XElement)"/> is not executed and <see cref="Deleted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCore(XElement, XElement)"/>.</param>
        partial void DeletedAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="Deleted(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCore(XElement property, XElement parent)
    	{
    		if(parent == null)
    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
    		switch(parent.Name.LocalName)
    		{
    			case "AttributeArgument": return this.DeletedAttributeArgument(property, parent);
    			case "NameEquals": return this.DeletedNameEquals(property, parent);
    			case "TypeParameterList": return this.DeletedTypeParameterList(property, parent);
    			case "TypeParameter": return this.DeletedTypeParameter(property, parent);
    			case "BaseList": return this.DeletedBaseList(property, parent);
    			case "TypeParameterConstraintClause": return this.DeletedTypeParameterConstraintClause(property, parent);
    			case "ExplicitInterfaceSpecifier": return this.DeletedExplicitInterfaceSpecifier(property, parent);
    			case "ConstructorInitializer": return this.DeletedConstructorInitializer(property, parent);
    			case "ArrowExpressionClause": return this.DeletedArrowExpressionClause(property, parent);
    			case "AccessorList": return this.DeletedAccessorList(property, parent);
    			case "AccessorDeclaration": return this.DeletedAccessorDeclaration(property, parent);
    			case "Parameter": return this.DeletedParameter(property, parent);
    			case "CrefParameter": return this.DeletedCrefParameter(property, parent);
    			case "XmlElementStartTag": return this.DeletedXmlElementStartTag(property, parent);
    			case "XmlElementEndTag": return this.DeletedXmlElementEndTag(property, parent);
    			case "XmlName": return this.DeletedXmlName(property, parent);
    			case "XmlPrefix": return this.DeletedXmlPrefix(property, parent);
    			case "TypeArgumentList": return this.DeletedTypeArgumentList(property, parent);
    			case "ArrayRankSpecifier": return this.DeletedArrayRankSpecifier(property, parent);
    			case "TupleElement": return this.DeletedTupleElement(property, parent);
    			case "Argument": return this.DeletedArgument(property, parent);
    			case "NameColon": return this.DeletedNameColon(property, parent);
    			case "AnonymousObjectMemberDeclarator": return this.DeletedAnonymousObjectMemberDeclarator(property, parent);
    			case "QueryBody": return this.DeletedQueryBody(property, parent);
    			case "JoinIntoClause": return this.DeletedJoinIntoClause(property, parent);
    			case "Ordering": return this.DeletedOrdering(property, parent);
    			case "QueryContinuation": return this.DeletedQueryContinuation(property, parent);
    			case "WhenClause": return this.DeletedWhenClause(property, parent);
    			case "InterpolationAlignmentClause": return this.DeletedInterpolationAlignmentClause(property, parent);
    			case "InterpolationFormatClause": return this.DeletedInterpolationFormatClause(property, parent);
    			case "VariableDeclaration": return this.DeletedVariableDeclaration(property, parent);
    			case "VariableDeclarator": return this.DeletedVariableDeclarator(property, parent);
    			case "EqualsValueClause": return this.DeletedEqualsValueClause(property, parent);
    			case "ElseClause": return this.DeletedElseClause(property, parent);
    			case "SwitchSection": return this.DeletedSwitchSection(property, parent);
    			case "CatchClause": return this.DeletedCatchClause(property, parent);
    			case "CatchDeclaration": return this.DeletedCatchDeclaration(property, parent);
    			case "CatchFilterClause": return this.DeletedCatchFilterClause(property, parent);
    			case "FinallyClause": return this.DeletedFinallyClause(property, parent);
    			case "CompilationUnit": return this.DeletedCompilationUnit(property, parent);
    			case "ExternAliasDirective": return this.DeletedExternAliasDirective(property, parent);
    			case "UsingDirective": return this.DeletedUsingDirective(property, parent);
    			case "AttributeList": return this.DeletedAttributeList(property, parent);
    			case "AttributeTargetSpecifier": return this.DeletedAttributeTargetSpecifier(property, parent);
    			case "Attribute": return this.DeletedAttribute(property, parent);
    			case "AttributeArgumentList": return this.DeletedAttributeArgumentList(property, parent);
    			case "DelegateDeclaration": return this.DeletedDelegateDeclaration(property, parent);
    			case "EnumMemberDeclaration": return this.DeletedEnumMemberDeclaration(property, parent);
    			case "IncompleteMember": return this.DeletedIncompleteMember(property, parent);
    			case "GlobalStatement": return this.DeletedGlobalStatement(property, parent);
    			case "NamespaceDeclaration": return this.DeletedNamespaceDeclaration(property, parent);
    			case "EnumDeclaration": return this.DeletedEnumDeclaration(property, parent);
    			case "ClassDeclaration": return this.DeletedClassDeclaration(property, parent);
    			case "StructDeclaration": return this.DeletedStructDeclaration(property, parent);
    			case "InterfaceDeclaration": return this.DeletedInterfaceDeclaration(property, parent);
    			case "FieldDeclaration": return this.DeletedFieldDeclaration(property, parent);
    			case "EventFieldDeclaration": return this.DeletedEventFieldDeclaration(property, parent);
    			case "MethodDeclaration": return this.DeletedMethodDeclaration(property, parent);
    			case "OperatorDeclaration": return this.DeletedOperatorDeclaration(property, parent);
    			case "ConversionOperatorDeclaration": return this.DeletedConversionOperatorDeclaration(property, parent);
    			case "ConstructorDeclaration": return this.DeletedConstructorDeclaration(property, parent);
    			case "DestructorDeclaration": return this.DeletedDestructorDeclaration(property, parent);
    			case "PropertyDeclaration": return this.DeletedPropertyDeclaration(property, parent);
    			case "EventDeclaration": return this.DeletedEventDeclaration(property, parent);
    			case "IndexerDeclaration": return this.DeletedIndexerDeclaration(property, parent);
    			case "SimpleBaseType": return this.DeletedSimpleBaseType(property, parent);
    			case "ConstructorConstraint": return this.DeletedConstructorConstraint(property, parent);
    			case "ClassOrStructConstraint": return this.DeletedClassOrStructConstraint(property, parent);
    			case "TypeConstraint": return this.DeletedTypeConstraint(property, parent);
    			case "ParameterList": return this.DeletedParameterList(property, parent);
    			case "BracketedParameterList": return this.DeletedBracketedParameterList(property, parent);
    			case "SkippedTokensTrivia": return this.DeletedSkippedTokensTrivia(property, parent);
    			case "DocumentationCommentTrivia": return this.DeletedDocumentationCommentTrivia(property, parent);
    			case "EndIfDirectiveTrivia": return this.DeletedEndIfDirectiveTrivia(property, parent);
    			case "RegionDirectiveTrivia": return this.DeletedRegionDirectiveTrivia(property, parent);
    			case "EndRegionDirectiveTrivia": return this.DeletedEndRegionDirectiveTrivia(property, parent);
    			case "ErrorDirectiveTrivia": return this.DeletedErrorDirectiveTrivia(property, parent);
    			case "WarningDirectiveTrivia": return this.DeletedWarningDirectiveTrivia(property, parent);
    			case "BadDirectiveTrivia": return this.DeletedBadDirectiveTrivia(property, parent);
    			case "DefineDirectiveTrivia": return this.DeletedDefineDirectiveTrivia(property, parent);
    			case "UndefDirectiveTrivia": return this.DeletedUndefDirectiveTrivia(property, parent);
    			case "LineDirectiveTrivia": return this.DeletedLineDirectiveTrivia(property, parent);
    			case "PragmaWarningDirectiveTrivia": return this.DeletedPragmaWarningDirectiveTrivia(property, parent);
    			case "PragmaChecksumDirectiveTrivia": return this.DeletedPragmaChecksumDirectiveTrivia(property, parent);
    			case "ReferenceDirectiveTrivia": return this.DeletedReferenceDirectiveTrivia(property, parent);
    			case "LoadDirectiveTrivia": return this.DeletedLoadDirectiveTrivia(property, parent);
    			case "ShebangDirectiveTrivia": return this.DeletedShebangDirectiveTrivia(property, parent);
    			case "ElseDirectiveTrivia": return this.DeletedElseDirectiveTrivia(property, parent);
    			case "IfDirectiveTrivia": return this.DeletedIfDirectiveTrivia(property, parent);
    			case "ElifDirectiveTrivia": return this.DeletedElifDirectiveTrivia(property, parent);
    			case "TypeCref": return this.DeletedTypeCref(property, parent);
    			case "QualifiedCref": return this.DeletedQualifiedCref(property, parent);
    			case "NameMemberCref": return this.DeletedNameMemberCref(property, parent);
    			case "IndexerMemberCref": return this.DeletedIndexerMemberCref(property, parent);
    			case "OperatorMemberCref": return this.DeletedOperatorMemberCref(property, parent);
    			case "ConversionOperatorMemberCref": return this.DeletedConversionOperatorMemberCref(property, parent);
    			case "CrefParameterList": return this.DeletedCrefParameterList(property, parent);
    			case "CrefBracketedParameterList": return this.DeletedCrefBracketedParameterList(property, parent);
    			case "XmlElement": return this.DeletedXmlElement(property, parent);
    			case "XmlEmptyElement": return this.DeletedXmlEmptyElement(property, parent);
    			case "XmlText": return this.DeletedXmlText(property, parent);
    			case "XmlCDataSection": return this.DeletedXmlCDataSection(property, parent);
    			case "XmlProcessingInstruction": return this.DeletedXmlProcessingInstruction(property, parent);
    			case "XmlComment": return this.DeletedXmlComment(property, parent);
    			case "XmlTextAttribute": return this.DeletedXmlTextAttribute(property, parent);
    			case "XmlCrefAttribute": return this.DeletedXmlCrefAttribute(property, parent);
    			case "XmlNameAttribute": return this.DeletedXmlNameAttribute(property, parent);
    			case "ParenthesizedExpression": return this.DeletedParenthesizedExpression(property, parent);
    			case "TupleExpression": return this.DeletedTupleExpression(property, parent);
    			case "PrefixUnaryExpression": return this.DeletedPrefixUnaryExpression(property, parent);
    			case "AwaitExpression": return this.DeletedAwaitExpression(property, parent);
    			case "PostfixUnaryExpression": return this.DeletedPostfixUnaryExpression(property, parent);
    			case "MemberAccessExpression": return this.DeletedMemberAccessExpression(property, parent);
    			case "ConditionalAccessExpression": return this.DeletedConditionalAccessExpression(property, parent);
    			case "MemberBindingExpression": return this.DeletedMemberBindingExpression(property, parent);
    			case "ElementBindingExpression": return this.DeletedElementBindingExpression(property, parent);
    			case "ImplicitElementAccess": return this.DeletedImplicitElementAccess(property, parent);
    			case "BinaryExpression": return this.DeletedBinaryExpression(property, parent);
    			case "AssignmentExpression": return this.DeletedAssignmentExpression(property, parent);
    			case "ConditionalExpression": return this.DeletedConditionalExpression(property, parent);
    			case "LiteralExpression": return this.DeletedLiteralExpression(property, parent);
    			case "MakeRefExpression": return this.DeletedMakeRefExpression(property, parent);
    			case "RefTypeExpression": return this.DeletedRefTypeExpression(property, parent);
    			case "RefValueExpression": return this.DeletedRefValueExpression(property, parent);
    			case "CheckedExpression": return this.DeletedCheckedExpression(property, parent);
    			case "DefaultExpression": return this.DeletedDefaultExpression(property, parent);
    			case "TypeOfExpression": return this.DeletedTypeOfExpression(property, parent);
    			case "SizeOfExpression": return this.DeletedSizeOfExpression(property, parent);
    			case "InvocationExpression": return this.DeletedInvocationExpression(property, parent);
    			case "ElementAccessExpression": return this.DeletedElementAccessExpression(property, parent);
    			case "DeclarationExpression": return this.DeletedDeclarationExpression(property, parent);
    			case "CastExpression": return this.DeletedCastExpression(property, parent);
    			case "RefExpression": return this.DeletedRefExpression(property, parent);
    			case "InitializerExpression": return this.DeletedInitializerExpression(property, parent);
    			case "ObjectCreationExpression": return this.DeletedObjectCreationExpression(property, parent);
    			case "AnonymousObjectCreationExpression": return this.DeletedAnonymousObjectCreationExpression(property, parent);
    			case "ArrayCreationExpression": return this.DeletedArrayCreationExpression(property, parent);
    			case "ImplicitArrayCreationExpression": return this.DeletedImplicitArrayCreationExpression(property, parent);
    			case "StackAllocArrayCreationExpression": return this.DeletedStackAllocArrayCreationExpression(property, parent);
    			case "QueryExpression": return this.DeletedQueryExpression(property, parent);
    			case "OmittedArraySizeExpression": return this.DeletedOmittedArraySizeExpression(property, parent);
    			case "InterpolatedStringExpression": return this.DeletedInterpolatedStringExpression(property, parent);
    			case "IsPatternExpression": return this.DeletedIsPatternExpression(property, parent);
    			case "ThrowExpression": return this.DeletedThrowExpression(property, parent);
    			case "PredefinedType": return this.DeletedPredefinedType(property, parent);
    			case "ArrayType": return this.DeletedArrayType(property, parent);
    			case "PointerType": return this.DeletedPointerType(property, parent);
    			case "NullableType": return this.DeletedNullableType(property, parent);
    			case "TupleType": return this.DeletedTupleType(property, parent);
    			case "OmittedTypeArgument": return this.DeletedOmittedTypeArgument(property, parent);
    			case "RefType": return this.DeletedRefType(property, parent);
    			case "QualifiedName": return this.DeletedQualifiedName(property, parent);
    			case "AliasQualifiedName": return this.DeletedAliasQualifiedName(property, parent);
    			case "IdentifierName": return this.DeletedIdentifierName(property, parent);
    			case "GenericName": return this.DeletedGenericName(property, parent);
    			case "ThisExpression": return this.DeletedThisExpression(property, parent);
    			case "BaseExpression": return this.DeletedBaseExpression(property, parent);
    			case "AnonymousMethodExpression": return this.DeletedAnonymousMethodExpression(property, parent);
    			case "SimpleLambdaExpression": return this.DeletedSimpleLambdaExpression(property, parent);
    			case "ParenthesizedLambdaExpression": return this.DeletedParenthesizedLambdaExpression(property, parent);
    			case "ArgumentList": return this.DeletedArgumentList(property, parent);
    			case "BracketedArgumentList": return this.DeletedBracketedArgumentList(property, parent);
    			case "FromClause": return this.DeletedFromClause(property, parent);
    			case "LetClause": return this.DeletedLetClause(property, parent);
    			case "JoinClause": return this.DeletedJoinClause(property, parent);
    			case "WhereClause": return this.DeletedWhereClause(property, parent);
    			case "OrderByClause": return this.DeletedOrderByClause(property, parent);
    			case "SelectClause": return this.DeletedSelectClause(property, parent);
    			case "GroupClause": return this.DeletedGroupClause(property, parent);
    			case "DeclarationPattern": return this.DeletedDeclarationPattern(property, parent);
    			case "ConstantPattern": return this.DeletedConstantPattern(property, parent);
    			case "InterpolatedStringText": return this.DeletedInterpolatedStringText(property, parent);
    			case "Interpolation": return this.DeletedInterpolation(property, parent);
    			case "Block": return this.DeletedBlock(property, parent);
    			case "LocalFunctionStatement": return this.DeletedLocalFunctionStatement(property, parent);
    			case "LocalDeclarationStatement": return this.DeletedLocalDeclarationStatement(property, parent);
    			case "ExpressionStatement": return this.DeletedExpressionStatement(property, parent);
    			case "EmptyStatement": return this.DeletedEmptyStatement(property, parent);
    			case "LabeledStatement": return this.DeletedLabeledStatement(property, parent);
    			case "GotoStatement": return this.DeletedGotoStatement(property, parent);
    			case "BreakStatement": return this.DeletedBreakStatement(property, parent);
    			case "ContinueStatement": return this.DeletedContinueStatement(property, parent);
    			case "ReturnStatement": return this.DeletedReturnStatement(property, parent);
    			case "ThrowStatement": return this.DeletedThrowStatement(property, parent);
    			case "YieldStatement": return this.DeletedYieldStatement(property, parent);
    			case "WhileStatement": return this.DeletedWhileStatement(property, parent);
    			case "DoStatement": return this.DeletedDoStatement(property, parent);
    			case "ForStatement": return this.DeletedForStatement(property, parent);
    			case "UsingStatement": return this.DeletedUsingStatement(property, parent);
    			case "FixedStatement": return this.DeletedFixedStatement(property, parent);
    			case "CheckedStatement": return this.DeletedCheckedStatement(property, parent);
    			case "UnsafeStatement": return this.DeletedUnsafeStatement(property, parent);
    			case "LockStatement": return this.DeletedLockStatement(property, parent);
    			case "IfStatement": return this.DeletedIfStatement(property, parent);
    			case "SwitchStatement": return this.DeletedSwitchStatement(property, parent);
    			case "TryStatement": return this.DeletedTryStatement(property, parent);
    			case "ForEachStatement": return this.DeletedForEachStatement(property, parent);
    			case "ForEachVariableStatement": return this.DeletedForEachVariableStatement(property, parent);
    			case "SingleVariableDesignation": return this.DeletedSingleVariableDesignation(property, parent);
    			case "DiscardDesignation": return this.DeletedDiscardDesignation(property, parent);
    			case "ParenthesizedVariableDesignation": return this.DeletedParenthesizedVariableDesignation(property, parent);
    			case "CasePatternSwitchLabel": return this.DeletedCasePatternSwitchLabel(property, parent);
    			case "CaseSwitchLabel": return this.DeletedCaseSwitchLabel(property, parent);
    			case "DefaultSwitchLabel": return this.DeletedDefaultSwitchLabel(property, parent);
                case "SingleLineCommentTrivia": return this.DeletedFromSingleLineCommentTrivia(property, parent);
                case "MultiLineCommentTrivia": return this.DeletedFromMultiLineCommentTrivia(property, parent);
    			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
    		}
    	}		
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> Deleted(XElement property, XElement parent)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	DeletedBefore(property, parent, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.DeletedCore(property, parent);
        	DeletedAfter(property, parent, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Updated(XElement, XElement)'s Visit	
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Updated(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Updated(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCore(XElement, XElement)"/> is not executed and <see cref="Updated(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCore(XElement, XElement)"/>.</param>
        partial void UpdatedAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="Updated(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement.Parent == null)
    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
    		switch(oldElement.Parent.Name.LocalName)
    		{
    			case "AttributeArgument": return this.UpdatedAttributeArgument(oldElement, newElement);
    			case "NameEquals": return this.UpdatedNameEquals(oldElement, newElement);
    			case "TypeParameterList": return this.UpdatedTypeParameterList(oldElement, newElement);
    			case "TypeParameter": return this.UpdatedTypeParameter(oldElement, newElement);
    			case "BaseList": return this.UpdatedBaseList(oldElement, newElement);
    			case "TypeParameterConstraintClause": return this.UpdatedTypeParameterConstraintClause(oldElement, newElement);
    			case "ExplicitInterfaceSpecifier": return this.UpdatedExplicitInterfaceSpecifier(oldElement, newElement);
    			case "ConstructorInitializer": return this.UpdatedConstructorInitializer(oldElement, newElement);
    			case "ArrowExpressionClause": return this.UpdatedArrowExpressionClause(oldElement, newElement);
    			case "AccessorList": return this.UpdatedAccessorList(oldElement, newElement);
    			case "AccessorDeclaration": return this.UpdatedAccessorDeclaration(oldElement, newElement);
    			case "Parameter": return this.UpdatedParameter(oldElement, newElement);
    			case "CrefParameter": return this.UpdatedCrefParameter(oldElement, newElement);
    			case "XmlElementStartTag": return this.UpdatedXmlElementStartTag(oldElement, newElement);
    			case "XmlElementEndTag": return this.UpdatedXmlElementEndTag(oldElement, newElement);
    			case "XmlName": return this.UpdatedXmlName(oldElement, newElement);
    			case "XmlPrefix": return this.UpdatedXmlPrefix(oldElement, newElement);
    			case "TypeArgumentList": return this.UpdatedTypeArgumentList(oldElement, newElement);
    			case "ArrayRankSpecifier": return this.UpdatedArrayRankSpecifier(oldElement, newElement);
    			case "TupleElement": return this.UpdatedTupleElement(oldElement, newElement);
    			case "Argument": return this.UpdatedArgument(oldElement, newElement);
    			case "NameColon": return this.UpdatedNameColon(oldElement, newElement);
    			case "AnonymousObjectMemberDeclarator": return this.UpdatedAnonymousObjectMemberDeclarator(oldElement, newElement);
    			case "QueryBody": return this.UpdatedQueryBody(oldElement, newElement);
    			case "JoinIntoClause": return this.UpdatedJoinIntoClause(oldElement, newElement);
    			case "Ordering": return this.UpdatedOrdering(oldElement, newElement);
    			case "QueryContinuation": return this.UpdatedQueryContinuation(oldElement, newElement);
    			case "WhenClause": return this.UpdatedWhenClause(oldElement, newElement);
    			case "InterpolationAlignmentClause": return this.UpdatedInterpolationAlignmentClause(oldElement, newElement);
    			case "InterpolationFormatClause": return this.UpdatedInterpolationFormatClause(oldElement, newElement);
    			case "VariableDeclaration": return this.UpdatedVariableDeclaration(oldElement, newElement);
    			case "VariableDeclarator": return this.UpdatedVariableDeclarator(oldElement, newElement);
    			case "EqualsValueClause": return this.UpdatedEqualsValueClause(oldElement, newElement);
    			case "ElseClause": return this.UpdatedElseClause(oldElement, newElement);
    			case "SwitchSection": return this.UpdatedSwitchSection(oldElement, newElement);
    			case "CatchClause": return this.UpdatedCatchClause(oldElement, newElement);
    			case "CatchDeclaration": return this.UpdatedCatchDeclaration(oldElement, newElement);
    			case "CatchFilterClause": return this.UpdatedCatchFilterClause(oldElement, newElement);
    			case "FinallyClause": return this.UpdatedFinallyClause(oldElement, newElement);
    			case "CompilationUnit": return this.UpdatedCompilationUnit(oldElement, newElement);
    			case "ExternAliasDirective": return this.UpdatedExternAliasDirective(oldElement, newElement);
    			case "UsingDirective": return this.UpdatedUsingDirective(oldElement, newElement);
    			case "AttributeList": return this.UpdatedAttributeList(oldElement, newElement);
    			case "AttributeTargetSpecifier": return this.UpdatedAttributeTargetSpecifier(oldElement, newElement);
    			case "Attribute": return this.UpdatedAttribute(oldElement, newElement);
    			case "AttributeArgumentList": return this.UpdatedAttributeArgumentList(oldElement, newElement);
    			case "DelegateDeclaration": return this.UpdatedDelegateDeclaration(oldElement, newElement);
    			case "EnumMemberDeclaration": return this.UpdatedEnumMemberDeclaration(oldElement, newElement);
    			case "IncompleteMember": return this.UpdatedIncompleteMember(oldElement, newElement);
    			case "GlobalStatement": return this.UpdatedGlobalStatement(oldElement, newElement);
    			case "NamespaceDeclaration": return this.UpdatedNamespaceDeclaration(oldElement, newElement);
    			case "EnumDeclaration": return this.UpdatedEnumDeclaration(oldElement, newElement);
    			case "ClassDeclaration": return this.UpdatedClassDeclaration(oldElement, newElement);
    			case "StructDeclaration": return this.UpdatedStructDeclaration(oldElement, newElement);
    			case "InterfaceDeclaration": return this.UpdatedInterfaceDeclaration(oldElement, newElement);
    			case "FieldDeclaration": return this.UpdatedFieldDeclaration(oldElement, newElement);
    			case "EventFieldDeclaration": return this.UpdatedEventFieldDeclaration(oldElement, newElement);
    			case "MethodDeclaration": return this.UpdatedMethodDeclaration(oldElement, newElement);
    			case "OperatorDeclaration": return this.UpdatedOperatorDeclaration(oldElement, newElement);
    			case "ConversionOperatorDeclaration": return this.UpdatedConversionOperatorDeclaration(oldElement, newElement);
    			case "ConstructorDeclaration": return this.UpdatedConstructorDeclaration(oldElement, newElement);
    			case "DestructorDeclaration": return this.UpdatedDestructorDeclaration(oldElement, newElement);
    			case "PropertyDeclaration": return this.UpdatedPropertyDeclaration(oldElement, newElement);
    			case "EventDeclaration": return this.UpdatedEventDeclaration(oldElement, newElement);
    			case "IndexerDeclaration": return this.UpdatedIndexerDeclaration(oldElement, newElement);
    			case "SimpleBaseType": return this.UpdatedSimpleBaseType(oldElement, newElement);
    			case "ConstructorConstraint": return this.UpdatedConstructorConstraint(oldElement, newElement);
    			case "ClassOrStructConstraint": return this.UpdatedClassOrStructConstraint(oldElement, newElement);
    			case "TypeConstraint": return this.UpdatedTypeConstraint(oldElement, newElement);
    			case "ParameterList": return this.UpdatedParameterList(oldElement, newElement);
    			case "BracketedParameterList": return this.UpdatedBracketedParameterList(oldElement, newElement);
    			case "SkippedTokensTrivia": return this.UpdatedSkippedTokensTrivia(oldElement, newElement);
    			case "DocumentationCommentTrivia": return this.UpdatedDocumentationCommentTrivia(oldElement, newElement);
    			case "EndIfDirectiveTrivia": return this.UpdatedEndIfDirectiveTrivia(oldElement, newElement);
    			case "RegionDirectiveTrivia": return this.UpdatedRegionDirectiveTrivia(oldElement, newElement);
    			case "EndRegionDirectiveTrivia": return this.UpdatedEndRegionDirectiveTrivia(oldElement, newElement);
    			case "ErrorDirectiveTrivia": return this.UpdatedErrorDirectiveTrivia(oldElement, newElement);
    			case "WarningDirectiveTrivia": return this.UpdatedWarningDirectiveTrivia(oldElement, newElement);
    			case "BadDirectiveTrivia": return this.UpdatedBadDirectiveTrivia(oldElement, newElement);
    			case "DefineDirectiveTrivia": return this.UpdatedDefineDirectiveTrivia(oldElement, newElement);
    			case "UndefDirectiveTrivia": return this.UpdatedUndefDirectiveTrivia(oldElement, newElement);
    			case "LineDirectiveTrivia": return this.UpdatedLineDirectiveTrivia(oldElement, newElement);
    			case "PragmaWarningDirectiveTrivia": return this.UpdatedPragmaWarningDirectiveTrivia(oldElement, newElement);
    			case "PragmaChecksumDirectiveTrivia": return this.UpdatedPragmaChecksumDirectiveTrivia(oldElement, newElement);
    			case "ReferenceDirectiveTrivia": return this.UpdatedReferenceDirectiveTrivia(oldElement, newElement);
    			case "LoadDirectiveTrivia": return this.UpdatedLoadDirectiveTrivia(oldElement, newElement);
    			case "ShebangDirectiveTrivia": return this.UpdatedShebangDirectiveTrivia(oldElement, newElement);
    			case "ElseDirectiveTrivia": return this.UpdatedElseDirectiveTrivia(oldElement, newElement);
    			case "IfDirectiveTrivia": return this.UpdatedIfDirectiveTrivia(oldElement, newElement);
    			case "ElifDirectiveTrivia": return this.UpdatedElifDirectiveTrivia(oldElement, newElement);
    			case "TypeCref": return this.UpdatedTypeCref(oldElement, newElement);
    			case "QualifiedCref": return this.UpdatedQualifiedCref(oldElement, newElement);
    			case "NameMemberCref": return this.UpdatedNameMemberCref(oldElement, newElement);
    			case "IndexerMemberCref": return this.UpdatedIndexerMemberCref(oldElement, newElement);
    			case "OperatorMemberCref": return this.UpdatedOperatorMemberCref(oldElement, newElement);
    			case "ConversionOperatorMemberCref": return this.UpdatedConversionOperatorMemberCref(oldElement, newElement);
    			case "CrefParameterList": return this.UpdatedCrefParameterList(oldElement, newElement);
    			case "CrefBracketedParameterList": return this.UpdatedCrefBracketedParameterList(oldElement, newElement);
    			case "XmlElement": return this.UpdatedXmlElement(oldElement, newElement);
    			case "XmlEmptyElement": return this.UpdatedXmlEmptyElement(oldElement, newElement);
    			case "XmlText": return this.UpdatedXmlText(oldElement, newElement);
    			case "XmlCDataSection": return this.UpdatedXmlCDataSection(oldElement, newElement);
    			case "XmlProcessingInstruction": return this.UpdatedXmlProcessingInstruction(oldElement, newElement);
    			case "XmlComment": return this.UpdatedXmlComment(oldElement, newElement);
    			case "XmlTextAttribute": return this.UpdatedXmlTextAttribute(oldElement, newElement);
    			case "XmlCrefAttribute": return this.UpdatedXmlCrefAttribute(oldElement, newElement);
    			case "XmlNameAttribute": return this.UpdatedXmlNameAttribute(oldElement, newElement);
    			case "ParenthesizedExpression": return this.UpdatedParenthesizedExpression(oldElement, newElement);
    			case "TupleExpression": return this.UpdatedTupleExpression(oldElement, newElement);
    			case "PrefixUnaryExpression": return this.UpdatedPrefixUnaryExpression(oldElement, newElement);
    			case "AwaitExpression": return this.UpdatedAwaitExpression(oldElement, newElement);
    			case "PostfixUnaryExpression": return this.UpdatedPostfixUnaryExpression(oldElement, newElement);
    			case "MemberAccessExpression": return this.UpdatedMemberAccessExpression(oldElement, newElement);
    			case "ConditionalAccessExpression": return this.UpdatedConditionalAccessExpression(oldElement, newElement);
    			case "MemberBindingExpression": return this.UpdatedMemberBindingExpression(oldElement, newElement);
    			case "ElementBindingExpression": return this.UpdatedElementBindingExpression(oldElement, newElement);
    			case "ImplicitElementAccess": return this.UpdatedImplicitElementAccess(oldElement, newElement);
    			case "BinaryExpression": return this.UpdatedBinaryExpression(oldElement, newElement);
    			case "AssignmentExpression": return this.UpdatedAssignmentExpression(oldElement, newElement);
    			case "ConditionalExpression": return this.UpdatedConditionalExpression(oldElement, newElement);
    			case "LiteralExpression": return this.UpdatedLiteralExpression(oldElement, newElement);
    			case "MakeRefExpression": return this.UpdatedMakeRefExpression(oldElement, newElement);
    			case "RefTypeExpression": return this.UpdatedRefTypeExpression(oldElement, newElement);
    			case "RefValueExpression": return this.UpdatedRefValueExpression(oldElement, newElement);
    			case "CheckedExpression": return this.UpdatedCheckedExpression(oldElement, newElement);
    			case "DefaultExpression": return this.UpdatedDefaultExpression(oldElement, newElement);
    			case "TypeOfExpression": return this.UpdatedTypeOfExpression(oldElement, newElement);
    			case "SizeOfExpression": return this.UpdatedSizeOfExpression(oldElement, newElement);
    			case "InvocationExpression": return this.UpdatedInvocationExpression(oldElement, newElement);
    			case "ElementAccessExpression": return this.UpdatedElementAccessExpression(oldElement, newElement);
    			case "DeclarationExpression": return this.UpdatedDeclarationExpression(oldElement, newElement);
    			case "CastExpression": return this.UpdatedCastExpression(oldElement, newElement);
    			case "RefExpression": return this.UpdatedRefExpression(oldElement, newElement);
    			case "InitializerExpression": return this.UpdatedInitializerExpression(oldElement, newElement);
    			case "ObjectCreationExpression": return this.UpdatedObjectCreationExpression(oldElement, newElement);
    			case "AnonymousObjectCreationExpression": return this.UpdatedAnonymousObjectCreationExpression(oldElement, newElement);
    			case "ArrayCreationExpression": return this.UpdatedArrayCreationExpression(oldElement, newElement);
    			case "ImplicitArrayCreationExpression": return this.UpdatedImplicitArrayCreationExpression(oldElement, newElement);
    			case "StackAllocArrayCreationExpression": return this.UpdatedStackAllocArrayCreationExpression(oldElement, newElement);
    			case "QueryExpression": return this.UpdatedQueryExpression(oldElement, newElement);
    			case "OmittedArraySizeExpression": return this.UpdatedOmittedArraySizeExpression(oldElement, newElement);
    			case "InterpolatedStringExpression": return this.UpdatedInterpolatedStringExpression(oldElement, newElement);
    			case "IsPatternExpression": return this.UpdatedIsPatternExpression(oldElement, newElement);
    			case "ThrowExpression": return this.UpdatedThrowExpression(oldElement, newElement);
    			case "PredefinedType": return this.UpdatedPredefinedType(oldElement, newElement);
    			case "ArrayType": return this.UpdatedArrayType(oldElement, newElement);
    			case "PointerType": return this.UpdatedPointerType(oldElement, newElement);
    			case "NullableType": return this.UpdatedNullableType(oldElement, newElement);
    			case "TupleType": return this.UpdatedTupleType(oldElement, newElement);
    			case "OmittedTypeArgument": return this.UpdatedOmittedTypeArgument(oldElement, newElement);
    			case "RefType": return this.UpdatedRefType(oldElement, newElement);
    			case "QualifiedName": return this.UpdatedQualifiedName(oldElement, newElement);
    			case "AliasQualifiedName": return this.UpdatedAliasQualifiedName(oldElement, newElement);
    			case "IdentifierName": return this.UpdatedIdentifierName(oldElement, newElement);
    			case "GenericName": return this.UpdatedGenericName(oldElement, newElement);
    			case "ThisExpression": return this.UpdatedThisExpression(oldElement, newElement);
    			case "BaseExpression": return this.UpdatedBaseExpression(oldElement, newElement);
    			case "AnonymousMethodExpression": return this.UpdatedAnonymousMethodExpression(oldElement, newElement);
    			case "SimpleLambdaExpression": return this.UpdatedSimpleLambdaExpression(oldElement, newElement);
    			case "ParenthesizedLambdaExpression": return this.UpdatedParenthesizedLambdaExpression(oldElement, newElement);
    			case "ArgumentList": return this.UpdatedArgumentList(oldElement, newElement);
    			case "BracketedArgumentList": return this.UpdatedBracketedArgumentList(oldElement, newElement);
    			case "FromClause": return this.UpdatedFromClause(oldElement, newElement);
    			case "LetClause": return this.UpdatedLetClause(oldElement, newElement);
    			case "JoinClause": return this.UpdatedJoinClause(oldElement, newElement);
    			case "WhereClause": return this.UpdatedWhereClause(oldElement, newElement);
    			case "OrderByClause": return this.UpdatedOrderByClause(oldElement, newElement);
    			case "SelectClause": return this.UpdatedSelectClause(oldElement, newElement);
    			case "GroupClause": return this.UpdatedGroupClause(oldElement, newElement);
    			case "DeclarationPattern": return this.UpdatedDeclarationPattern(oldElement, newElement);
    			case "ConstantPattern": return this.UpdatedConstantPattern(oldElement, newElement);
    			case "InterpolatedStringText": return this.UpdatedInterpolatedStringText(oldElement, newElement);
    			case "Interpolation": return this.UpdatedInterpolation(oldElement, newElement);
    			case "Block": return this.UpdatedBlock(oldElement, newElement);
    			case "LocalFunctionStatement": return this.UpdatedLocalFunctionStatement(oldElement, newElement);
    			case "LocalDeclarationStatement": return this.UpdatedLocalDeclarationStatement(oldElement, newElement);
    			case "ExpressionStatement": return this.UpdatedExpressionStatement(oldElement, newElement);
    			case "EmptyStatement": return this.UpdatedEmptyStatement(oldElement, newElement);
    			case "LabeledStatement": return this.UpdatedLabeledStatement(oldElement, newElement);
    			case "GotoStatement": return this.UpdatedGotoStatement(oldElement, newElement);
    			case "BreakStatement": return this.UpdatedBreakStatement(oldElement, newElement);
    			case "ContinueStatement": return this.UpdatedContinueStatement(oldElement, newElement);
    			case "ReturnStatement": return this.UpdatedReturnStatement(oldElement, newElement);
    			case "ThrowStatement": return this.UpdatedThrowStatement(oldElement, newElement);
    			case "YieldStatement": return this.UpdatedYieldStatement(oldElement, newElement);
    			case "WhileStatement": return this.UpdatedWhileStatement(oldElement, newElement);
    			case "DoStatement": return this.UpdatedDoStatement(oldElement, newElement);
    			case "ForStatement": return this.UpdatedForStatement(oldElement, newElement);
    			case "UsingStatement": return this.UpdatedUsingStatement(oldElement, newElement);
    			case "FixedStatement": return this.UpdatedFixedStatement(oldElement, newElement);
    			case "CheckedStatement": return this.UpdatedCheckedStatement(oldElement, newElement);
    			case "UnsafeStatement": return this.UpdatedUnsafeStatement(oldElement, newElement);
    			case "LockStatement": return this.UpdatedLockStatement(oldElement, newElement);
    			case "IfStatement": return this.UpdatedIfStatement(oldElement, newElement);
    			case "SwitchStatement": return this.UpdatedSwitchStatement(oldElement, newElement);
    			case "TryStatement": return this.UpdatedTryStatement(oldElement, newElement);
    			case "ForEachStatement": return this.UpdatedForEachStatement(oldElement, newElement);
    			case "ForEachVariableStatement": return this.UpdatedForEachVariableStatement(oldElement, newElement);
    			case "SingleVariableDesignation": return this.UpdatedSingleVariableDesignation(oldElement, newElement);
    			case "DiscardDesignation": return this.UpdatedDiscardDesignation(oldElement, newElement);
    			case "ParenthesizedVariableDesignation": return this.UpdatedParenthesizedVariableDesignation(oldElement, newElement);
    			case "CasePatternSwitchLabel": return this.UpdatedCasePatternSwitchLabel(oldElement, newElement);
    			case "CaseSwitchLabel": return this.UpdatedCaseSwitchLabel(oldElement, newElement);
    			case "DefaultSwitchLabel": return this.UpdatedDefaultSwitchLabel(oldElement, newElement);
                case "SingleLineCommentTrivia": return this.UpdatedFromSingleLineCommentTrivia(oldElement, newElement);
                case "MultiLineCommentTrivia": return this.UpdatedFromMultiLineCommentTrivia(oldElement, newElement);
    			default: throw new ArgumentException($"The type {oldElement.Parent.Name.LocalName} has not been found.");;//return true
    		}
    	}		
    	
        /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> Updated(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCore(oldElement, newElement);
    		UpdatedAfter(oldElement, newElement, ref result);
    		return result;
    	}
        
        /// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Moved(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Moved(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="Moved(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="Moved(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(oldParent == null)
    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
    		switch(oldParent.Name.LocalName)
    		{
    			case "AttributeArgument": return this.MovedAttributeArgument(property, oldParent, position, newParent);
    			case "NameEquals": return this.MovedNameEquals(property, oldParent, position, newParent);
    			case "TypeParameterList": return this.MovedTypeParameterList(property, oldParent, position, newParent);
    			case "TypeParameter": return this.MovedTypeParameter(property, oldParent, position, newParent);
    			case "BaseList": return this.MovedBaseList(property, oldParent, position, newParent);
    			case "TypeParameterConstraintClause": return this.MovedTypeParameterConstraintClause(property, oldParent, position, newParent);
    			case "ExplicitInterfaceSpecifier": return this.MovedExplicitInterfaceSpecifier(property, oldParent, position, newParent);
    			case "ConstructorInitializer": return this.MovedConstructorInitializer(property, oldParent, position, newParent);
    			case "ArrowExpressionClause": return this.MovedArrowExpressionClause(property, oldParent, position, newParent);
    			case "AccessorList": return this.MovedAccessorList(property, oldParent, position, newParent);
    			case "AccessorDeclaration": return this.MovedAccessorDeclaration(property, oldParent, position, newParent);
    			case "Parameter": return this.MovedParameter(property, oldParent, position, newParent);
    			case "CrefParameter": return this.MovedCrefParameter(property, oldParent, position, newParent);
    			case "XmlElementStartTag": return this.MovedXmlElementStartTag(property, oldParent, position, newParent);
    			case "XmlElementEndTag": return this.MovedXmlElementEndTag(property, oldParent, position, newParent);
    			case "XmlName": return this.MovedXmlName(property, oldParent, position, newParent);
    			case "XmlPrefix": return this.MovedXmlPrefix(property, oldParent, position, newParent);
    			case "TypeArgumentList": return this.MovedTypeArgumentList(property, oldParent, position, newParent);
    			case "ArrayRankSpecifier": return this.MovedArrayRankSpecifier(property, oldParent, position, newParent);
    			case "TupleElement": return this.MovedTupleElement(property, oldParent, position, newParent);
    			case "Argument": return this.MovedArgument(property, oldParent, position, newParent);
    			case "NameColon": return this.MovedNameColon(property, oldParent, position, newParent);
    			case "AnonymousObjectMemberDeclarator": return this.MovedAnonymousObjectMemberDeclarator(property, oldParent, position, newParent);
    			case "QueryBody": return this.MovedQueryBody(property, oldParent, position, newParent);
    			case "JoinIntoClause": return this.MovedJoinIntoClause(property, oldParent, position, newParent);
    			case "Ordering": return this.MovedOrdering(property, oldParent, position, newParent);
    			case "QueryContinuation": return this.MovedQueryContinuation(property, oldParent, position, newParent);
    			case "WhenClause": return this.MovedWhenClause(property, oldParent, position, newParent);
    			case "InterpolationAlignmentClause": return this.MovedInterpolationAlignmentClause(property, oldParent, position, newParent);
    			case "InterpolationFormatClause": return this.MovedInterpolationFormatClause(property, oldParent, position, newParent);
    			case "VariableDeclaration": return this.MovedVariableDeclaration(property, oldParent, position, newParent);
    			case "VariableDeclarator": return this.MovedVariableDeclarator(property, oldParent, position, newParent);
    			case "EqualsValueClause": return this.MovedEqualsValueClause(property, oldParent, position, newParent);
    			case "ElseClause": return this.MovedElseClause(property, oldParent, position, newParent);
    			case "SwitchSection": return this.MovedSwitchSection(property, oldParent, position, newParent);
    			case "CatchClause": return this.MovedCatchClause(property, oldParent, position, newParent);
    			case "CatchDeclaration": return this.MovedCatchDeclaration(property, oldParent, position, newParent);
    			case "CatchFilterClause": return this.MovedCatchFilterClause(property, oldParent, position, newParent);
    			case "FinallyClause": return this.MovedFinallyClause(property, oldParent, position, newParent);
    			case "CompilationUnit": return this.MovedCompilationUnit(property, oldParent, position, newParent);
    			case "ExternAliasDirective": return this.MovedExternAliasDirective(property, oldParent, position, newParent);
    			case "UsingDirective": return this.MovedUsingDirective(property, oldParent, position, newParent);
    			case "AttributeList": return this.MovedAttributeList(property, oldParent, position, newParent);
    			case "AttributeTargetSpecifier": return this.MovedAttributeTargetSpecifier(property, oldParent, position, newParent);
    			case "Attribute": return this.MovedAttribute(property, oldParent, position, newParent);
    			case "AttributeArgumentList": return this.MovedAttributeArgumentList(property, oldParent, position, newParent);
    			case "DelegateDeclaration": return this.MovedDelegateDeclaration(property, oldParent, position, newParent);
    			case "EnumMemberDeclaration": return this.MovedEnumMemberDeclaration(property, oldParent, position, newParent);
    			case "IncompleteMember": return this.MovedIncompleteMember(property, oldParent, position, newParent);
    			case "GlobalStatement": return this.MovedGlobalStatement(property, oldParent, position, newParent);
    			case "NamespaceDeclaration": return this.MovedNamespaceDeclaration(property, oldParent, position, newParent);
    			case "EnumDeclaration": return this.MovedEnumDeclaration(property, oldParent, position, newParent);
    			case "ClassDeclaration": return this.MovedClassDeclaration(property, oldParent, position, newParent);
    			case "StructDeclaration": return this.MovedStructDeclaration(property, oldParent, position, newParent);
    			case "InterfaceDeclaration": return this.MovedInterfaceDeclaration(property, oldParent, position, newParent);
    			case "FieldDeclaration": return this.MovedFieldDeclaration(property, oldParent, position, newParent);
    			case "EventFieldDeclaration": return this.MovedEventFieldDeclaration(property, oldParent, position, newParent);
    			case "MethodDeclaration": return this.MovedMethodDeclaration(property, oldParent, position, newParent);
    			case "OperatorDeclaration": return this.MovedOperatorDeclaration(property, oldParent, position, newParent);
    			case "ConversionOperatorDeclaration": return this.MovedConversionOperatorDeclaration(property, oldParent, position, newParent);
    			case "ConstructorDeclaration": return this.MovedConstructorDeclaration(property, oldParent, position, newParent);
    			case "DestructorDeclaration": return this.MovedDestructorDeclaration(property, oldParent, position, newParent);
    			case "PropertyDeclaration": return this.MovedPropertyDeclaration(property, oldParent, position, newParent);
    			case "EventDeclaration": return this.MovedEventDeclaration(property, oldParent, position, newParent);
    			case "IndexerDeclaration": return this.MovedIndexerDeclaration(property, oldParent, position, newParent);
    			case "SimpleBaseType": return this.MovedSimpleBaseType(property, oldParent, position, newParent);
    			case "ConstructorConstraint": return this.MovedConstructorConstraint(property, oldParent, position, newParent);
    			case "ClassOrStructConstraint": return this.MovedClassOrStructConstraint(property, oldParent, position, newParent);
    			case "TypeConstraint": return this.MovedTypeConstraint(property, oldParent, position, newParent);
    			case "ParameterList": return this.MovedParameterList(property, oldParent, position, newParent);
    			case "BracketedParameterList": return this.MovedBracketedParameterList(property, oldParent, position, newParent);
    			case "SkippedTokensTrivia": return this.MovedSkippedTokensTrivia(property, oldParent, position, newParent);
    			case "DocumentationCommentTrivia": return this.MovedDocumentationCommentTrivia(property, oldParent, position, newParent);
    			case "EndIfDirectiveTrivia": return this.MovedEndIfDirectiveTrivia(property, oldParent, position, newParent);
    			case "RegionDirectiveTrivia": return this.MovedRegionDirectiveTrivia(property, oldParent, position, newParent);
    			case "EndRegionDirectiveTrivia": return this.MovedEndRegionDirectiveTrivia(property, oldParent, position, newParent);
    			case "ErrorDirectiveTrivia": return this.MovedErrorDirectiveTrivia(property, oldParent, position, newParent);
    			case "WarningDirectiveTrivia": return this.MovedWarningDirectiveTrivia(property, oldParent, position, newParent);
    			case "BadDirectiveTrivia": return this.MovedBadDirectiveTrivia(property, oldParent, position, newParent);
    			case "DefineDirectiveTrivia": return this.MovedDefineDirectiveTrivia(property, oldParent, position, newParent);
    			case "UndefDirectiveTrivia": return this.MovedUndefDirectiveTrivia(property, oldParent, position, newParent);
    			case "LineDirectiveTrivia": return this.MovedLineDirectiveTrivia(property, oldParent, position, newParent);
    			case "PragmaWarningDirectiveTrivia": return this.MovedPragmaWarningDirectiveTrivia(property, oldParent, position, newParent);
    			case "PragmaChecksumDirectiveTrivia": return this.MovedPragmaChecksumDirectiveTrivia(property, oldParent, position, newParent);
    			case "ReferenceDirectiveTrivia": return this.MovedReferenceDirectiveTrivia(property, oldParent, position, newParent);
    			case "LoadDirectiveTrivia": return this.MovedLoadDirectiveTrivia(property, oldParent, position, newParent);
    			case "ShebangDirectiveTrivia": return this.MovedShebangDirectiveTrivia(property, oldParent, position, newParent);
    			case "ElseDirectiveTrivia": return this.MovedElseDirectiveTrivia(property, oldParent, position, newParent);
    			case "IfDirectiveTrivia": return this.MovedIfDirectiveTrivia(property, oldParent, position, newParent);
    			case "ElifDirectiveTrivia": return this.MovedElifDirectiveTrivia(property, oldParent, position, newParent);
    			case "TypeCref": return this.MovedTypeCref(property, oldParent, position, newParent);
    			case "QualifiedCref": return this.MovedQualifiedCref(property, oldParent, position, newParent);
    			case "NameMemberCref": return this.MovedNameMemberCref(property, oldParent, position, newParent);
    			case "IndexerMemberCref": return this.MovedIndexerMemberCref(property, oldParent, position, newParent);
    			case "OperatorMemberCref": return this.MovedOperatorMemberCref(property, oldParent, position, newParent);
    			case "ConversionOperatorMemberCref": return this.MovedConversionOperatorMemberCref(property, oldParent, position, newParent);
    			case "CrefParameterList": return this.MovedCrefParameterList(property, oldParent, position, newParent);
    			case "CrefBracketedParameterList": return this.MovedCrefBracketedParameterList(property, oldParent, position, newParent);
    			case "XmlElement": return this.MovedXmlElement(property, oldParent, position, newParent);
    			case "XmlEmptyElement": return this.MovedXmlEmptyElement(property, oldParent, position, newParent);
    			case "XmlText": return this.MovedXmlText(property, oldParent, position, newParent);
    			case "XmlCDataSection": return this.MovedXmlCDataSection(property, oldParent, position, newParent);
    			case "XmlProcessingInstruction": return this.MovedXmlProcessingInstruction(property, oldParent, position, newParent);
    			case "XmlComment": return this.MovedXmlComment(property, oldParent, position, newParent);
    			case "XmlTextAttribute": return this.MovedXmlTextAttribute(property, oldParent, position, newParent);
    			case "XmlCrefAttribute": return this.MovedXmlCrefAttribute(property, oldParent, position, newParent);
    			case "XmlNameAttribute": return this.MovedXmlNameAttribute(property, oldParent, position, newParent);
    			case "ParenthesizedExpression": return this.MovedParenthesizedExpression(property, oldParent, position, newParent);
    			case "TupleExpression": return this.MovedTupleExpression(property, oldParent, position, newParent);
    			case "PrefixUnaryExpression": return this.MovedPrefixUnaryExpression(property, oldParent, position, newParent);
    			case "AwaitExpression": return this.MovedAwaitExpression(property, oldParent, position, newParent);
    			case "PostfixUnaryExpression": return this.MovedPostfixUnaryExpression(property, oldParent, position, newParent);
    			case "MemberAccessExpression": return this.MovedMemberAccessExpression(property, oldParent, position, newParent);
    			case "ConditionalAccessExpression": return this.MovedConditionalAccessExpression(property, oldParent, position, newParent);
    			case "MemberBindingExpression": return this.MovedMemberBindingExpression(property, oldParent, position, newParent);
    			case "ElementBindingExpression": return this.MovedElementBindingExpression(property, oldParent, position, newParent);
    			case "ImplicitElementAccess": return this.MovedImplicitElementAccess(property, oldParent, position, newParent);
    			case "BinaryExpression": return this.MovedBinaryExpression(property, oldParent, position, newParent);
    			case "AssignmentExpression": return this.MovedAssignmentExpression(property, oldParent, position, newParent);
    			case "ConditionalExpression": return this.MovedConditionalExpression(property, oldParent, position, newParent);
    			case "LiteralExpression": return this.MovedLiteralExpression(property, oldParent, position, newParent);
    			case "MakeRefExpression": return this.MovedMakeRefExpression(property, oldParent, position, newParent);
    			case "RefTypeExpression": return this.MovedRefTypeExpression(property, oldParent, position, newParent);
    			case "RefValueExpression": return this.MovedRefValueExpression(property, oldParent, position, newParent);
    			case "CheckedExpression": return this.MovedCheckedExpression(property, oldParent, position, newParent);
    			case "DefaultExpression": return this.MovedDefaultExpression(property, oldParent, position, newParent);
    			case "TypeOfExpression": return this.MovedTypeOfExpression(property, oldParent, position, newParent);
    			case "SizeOfExpression": return this.MovedSizeOfExpression(property, oldParent, position, newParent);
    			case "InvocationExpression": return this.MovedInvocationExpression(property, oldParent, position, newParent);
    			case "ElementAccessExpression": return this.MovedElementAccessExpression(property, oldParent, position, newParent);
    			case "DeclarationExpression": return this.MovedDeclarationExpression(property, oldParent, position, newParent);
    			case "CastExpression": return this.MovedCastExpression(property, oldParent, position, newParent);
    			case "RefExpression": return this.MovedRefExpression(property, oldParent, position, newParent);
    			case "InitializerExpression": return this.MovedInitializerExpression(property, oldParent, position, newParent);
    			case "ObjectCreationExpression": return this.MovedObjectCreationExpression(property, oldParent, position, newParent);
    			case "AnonymousObjectCreationExpression": return this.MovedAnonymousObjectCreationExpression(property, oldParent, position, newParent);
    			case "ArrayCreationExpression": return this.MovedArrayCreationExpression(property, oldParent, position, newParent);
    			case "ImplicitArrayCreationExpression": return this.MovedImplicitArrayCreationExpression(property, oldParent, position, newParent);
    			case "StackAllocArrayCreationExpression": return this.MovedStackAllocArrayCreationExpression(property, oldParent, position, newParent);
    			case "QueryExpression": return this.MovedQueryExpression(property, oldParent, position, newParent);
    			case "OmittedArraySizeExpression": return this.MovedOmittedArraySizeExpression(property, oldParent, position, newParent);
    			case "InterpolatedStringExpression": return this.MovedInterpolatedStringExpression(property, oldParent, position, newParent);
    			case "IsPatternExpression": return this.MovedIsPatternExpression(property, oldParent, position, newParent);
    			case "ThrowExpression": return this.MovedThrowExpression(property, oldParent, position, newParent);
    			case "PredefinedType": return this.MovedPredefinedType(property, oldParent, position, newParent);
    			case "ArrayType": return this.MovedArrayType(property, oldParent, position, newParent);
    			case "PointerType": return this.MovedPointerType(property, oldParent, position, newParent);
    			case "NullableType": return this.MovedNullableType(property, oldParent, position, newParent);
    			case "TupleType": return this.MovedTupleType(property, oldParent, position, newParent);
    			case "OmittedTypeArgument": return this.MovedOmittedTypeArgument(property, oldParent, position, newParent);
    			case "RefType": return this.MovedRefType(property, oldParent, position, newParent);
    			case "QualifiedName": return this.MovedQualifiedName(property, oldParent, position, newParent);
    			case "AliasQualifiedName": return this.MovedAliasQualifiedName(property, oldParent, position, newParent);
    			case "IdentifierName": return this.MovedIdentifierName(property, oldParent, position, newParent);
    			case "GenericName": return this.MovedGenericName(property, oldParent, position, newParent);
    			case "ThisExpression": return this.MovedThisExpression(property, oldParent, position, newParent);
    			case "BaseExpression": return this.MovedBaseExpression(property, oldParent, position, newParent);
    			case "AnonymousMethodExpression": return this.MovedAnonymousMethodExpression(property, oldParent, position, newParent);
    			case "SimpleLambdaExpression": return this.MovedSimpleLambdaExpression(property, oldParent, position, newParent);
    			case "ParenthesizedLambdaExpression": return this.MovedParenthesizedLambdaExpression(property, oldParent, position, newParent);
    			case "ArgumentList": return this.MovedArgumentList(property, oldParent, position, newParent);
    			case "BracketedArgumentList": return this.MovedBracketedArgumentList(property, oldParent, position, newParent);
    			case "FromClause": return this.MovedFromClause(property, oldParent, position, newParent);
    			case "LetClause": return this.MovedLetClause(property, oldParent, position, newParent);
    			case "JoinClause": return this.MovedJoinClause(property, oldParent, position, newParent);
    			case "WhereClause": return this.MovedWhereClause(property, oldParent, position, newParent);
    			case "OrderByClause": return this.MovedOrderByClause(property, oldParent, position, newParent);
    			case "SelectClause": return this.MovedSelectClause(property, oldParent, position, newParent);
    			case "GroupClause": return this.MovedGroupClause(property, oldParent, position, newParent);
    			case "DeclarationPattern": return this.MovedDeclarationPattern(property, oldParent, position, newParent);
    			case "ConstantPattern": return this.MovedConstantPattern(property, oldParent, position, newParent);
    			case "InterpolatedStringText": return this.MovedInterpolatedStringText(property, oldParent, position, newParent);
    			case "Interpolation": return this.MovedInterpolation(property, oldParent, position, newParent);
    			case "Block": return this.MovedBlock(property, oldParent, position, newParent);
    			case "LocalFunctionStatement": return this.MovedLocalFunctionStatement(property, oldParent, position, newParent);
    			case "LocalDeclarationStatement": return this.MovedLocalDeclarationStatement(property, oldParent, position, newParent);
    			case "ExpressionStatement": return this.MovedExpressionStatement(property, oldParent, position, newParent);
    			case "EmptyStatement": return this.MovedEmptyStatement(property, oldParent, position, newParent);
    			case "LabeledStatement": return this.MovedLabeledStatement(property, oldParent, position, newParent);
    			case "GotoStatement": return this.MovedGotoStatement(property, oldParent, position, newParent);
    			case "BreakStatement": return this.MovedBreakStatement(property, oldParent, position, newParent);
    			case "ContinueStatement": return this.MovedContinueStatement(property, oldParent, position, newParent);
    			case "ReturnStatement": return this.MovedReturnStatement(property, oldParent, position, newParent);
    			case "ThrowStatement": return this.MovedThrowStatement(property, oldParent, position, newParent);
    			case "YieldStatement": return this.MovedYieldStatement(property, oldParent, position, newParent);
    			case "WhileStatement": return this.MovedWhileStatement(property, oldParent, position, newParent);
    			case "DoStatement": return this.MovedDoStatement(property, oldParent, position, newParent);
    			case "ForStatement": return this.MovedForStatement(property, oldParent, position, newParent);
    			case "UsingStatement": return this.MovedUsingStatement(property, oldParent, position, newParent);
    			case "FixedStatement": return this.MovedFixedStatement(property, oldParent, position, newParent);
    			case "CheckedStatement": return this.MovedCheckedStatement(property, oldParent, position, newParent);
    			case "UnsafeStatement": return this.MovedUnsafeStatement(property, oldParent, position, newParent);
    			case "LockStatement": return this.MovedLockStatement(property, oldParent, position, newParent);
    			case "IfStatement": return this.MovedIfStatement(property, oldParent, position, newParent);
    			case "SwitchStatement": return this.MovedSwitchStatement(property, oldParent, position, newParent);
    			case "TryStatement": return this.MovedTryStatement(property, oldParent, position, newParent);
    			case "ForEachStatement": return this.MovedForEachStatement(property, oldParent, position, newParent);
    			case "ForEachVariableStatement": return this.MovedForEachVariableStatement(property, oldParent, position, newParent);
    			case "SingleVariableDesignation": return this.MovedSingleVariableDesignation(property, oldParent, position, newParent);
    			case "DiscardDesignation": return this.MovedDiscardDesignation(property, oldParent, position, newParent);
    			case "ParenthesizedVariableDesignation": return this.MovedParenthesizedVariableDesignation(property, oldParent, position, newParent);
    			case "CasePatternSwitchLabel": return this.MovedCasePatternSwitchLabel(property, oldParent, position, newParent);
    			case "CaseSwitchLabel": return this.MovedCaseSwitchLabel(property, oldParent, position, newParent);
    			case "DefaultSwitchLabel": return this.MovedDefaultSwitchLabel(property, oldParent, position, newParent);
                case "SingleLineCommentTrivia": return this.MovedFromSingleLineCommentTrivia(property, oldParent, position, newParent);
                case "MultiLineCommentTrivia": return this.MovedFromMultiLineCommentTrivia(property, oldParent, position, newParent);
    			default: throw new ArgumentException($"The type {oldParent.Name.LocalName} has not been found.");//return true
    		}
    	}		
        
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> Moved(XElement property, XElement oldParent, int position, XElement newParent)
        {
            IEnumerable<XElement> result = null;
            var ignoreCore = false;
            MovedBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
            if(ignoreCore) 
                return result;
            
            result = this.MovedCore(property, oldParent, position, newParent);
            MovedAfter(property, oldParent, position, newParent, ref result);
            return result;
        }
    
    	#endregion
    
    	#region AttributeArgument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAttributeArgument(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeArgument(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAttributeArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAttributeArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAttributeArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAttributeArgumentCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeArgumentCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAttributeArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAttributeArgument(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAttributeArgumentCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAttributeArgument(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAttributeArgumentBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAttributeArgumentCore(property, position, parent);
    		InsertedAttributeArgumentAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAttributeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAttributeArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedAttributeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAttributeArgumentBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAttributeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeArgumentCore(XElement, XElement)"/>.</param>
        partial void DeletedAttributeArgumentAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAttributeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAttributeArgumentCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAttributeArgument(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAttributeArgumentBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAttributeArgumentCore(property, parent);
    		DeletedAttributeArgumentAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAttributeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAttributeArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAttributeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAttributeArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAttributeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeArgumentCore(XElement, XElement)"/>.</param>
        partial void UpdatedAttributeArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAttributeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAttributeArgumentCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAttributeArgument(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAttributeArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAttributeArgumentCore(oldElement, newElement);
    		UpdatedAttributeArgumentAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAttributeArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAttributeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAttributeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAttributeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAttributeArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAttributeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAttributeArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAttributeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAttributeArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAttributeArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAttributeArgumentCore(property, oldParent, position, newParent);
    		MovedAttributeArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAttributeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAttributeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAttributeArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAttributeArgumentCore(property, oldParent, position, newParent);
    		MatchedAttributeArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region NameEquals
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedNameEquals(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameEquals(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedNameEqualsCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedNameEquals(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedNameEqualsBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedNameEqualsCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameEqualsCore(XElement, int, XElement)"/>.</param>
        partial void InsertedNameEqualsAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedNameEquals(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedNameEqualsCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedNameEquals(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedNameEqualsBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedNameEqualsCore(property, position, parent);
    		InsertedNameEqualsAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedNameEquals(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameEquals(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedNameEqualsCore(XElement, XElement)"/> is not executed and <see cref="DeletedNameEquals(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedNameEqualsBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedNameEqualsCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameEqualsCore(XElement, XElement)"/>.</param>
        partial void DeletedNameEqualsAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedNameEquals(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedNameEqualsCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedNameEquals(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedNameEqualsBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedNameEqualsCore(property, parent);
    		DeletedNameEqualsAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedNameEquals(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameEquals(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedNameEqualsCore(XElement, XElement)"/> is not executed and <see cref="UpdatedNameEquals(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedNameEqualsBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedNameEqualsCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameEqualsCore(XElement, XElement)"/>.</param>
        partial void UpdatedNameEqualsAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedNameEquals(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedNameEqualsCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedNameEquals(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedNameEqualsBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedNameEqualsCore(oldElement, newElement);
    		UpdatedNameEqualsAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedNameEquals(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameEquals(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedNameEqualsCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedNameEquals(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedNameEqualsBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedNameEqualsCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameEqualsCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedNameEqualsAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedNameEquals(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedNameEqualsCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedNameEquals(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedNameEqualsBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedNameEqualsCore(property, oldParent, position, newParent);
    		MovedNameEqualsAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameEquals(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameEquals(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameEqualsCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedNameEquals(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameEqualsBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameEqualsCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameEqualsCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedNameEqualsAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameEquals(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameEqualsCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedNameEquals(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedNameEqualsBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedNameEqualsCore(property, oldParent, position, newParent);
    		MatchedNameEqualsAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeParameterList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameterList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeParameterListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameterListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeParameterList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeParameterListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeParameterList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeParameterListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeParameterListCore(property, position, parent);
    		InsertedTypeParameterListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeParameterListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameterListCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeParameterListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeParameterListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeParameterList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeParameterListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeParameterListCore(property, parent);
    		DeletedTypeParameterListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameterListCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeParameterListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeParameterList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeParameterListCore(oldElement, newElement);
    		UpdatedTypeParameterListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeParameterListCore(property, oldParent, position, newParent);
    		MovedTypeParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeParameterListCore(property, oldParent, position, newParent);
    		MatchedTypeParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeParameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeParameter(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameter(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeParameterCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameterCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeParameter(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeParameterCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "VarianceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeParameter(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeParameterBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeParameterCore(property, position, parent);
    		InsertedTypeParameterAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeParameterBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameterCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeParameterAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeParameterCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "VarianceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeParameter(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeParameterBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeParameterCore(property, parent);
    		DeletedTypeParameterAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameterCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeParameterCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "VarianceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeParameter(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeParameterCore(oldElement, newElement);
    		UpdatedTypeParameterAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "VarianceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeParameterCore(property, oldParent, position, newParent);
    		MovedTypeParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "VarianceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeParameterCore(property, oldParent, position, newParent);
    		MatchedTypeParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BaseList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBaseList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBaseList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBaseListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBaseList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBaseListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBaseListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBaseListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBaseListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBaseList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBaseListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBaseList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBaseListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBaseListCore(property, position, parent);
    		InsertedBaseListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBaseList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBaseList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBaseListCore(XElement, XElement)"/> is not executed and <see cref="DeletedBaseList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBaseListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBaseListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBaseListCore(XElement, XElement)"/>.</param>
        partial void DeletedBaseListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBaseList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBaseListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBaseList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBaseListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBaseListCore(property, parent);
    		DeletedBaseListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBaseList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBaseList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBaseListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBaseList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBaseListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBaseListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBaseListCore(XElement, XElement)"/>.</param>
        partial void UpdatedBaseListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBaseList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBaseListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBaseList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBaseListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBaseListCore(oldElement, newElement);
    		UpdatedBaseListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBaseList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBaseList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBaseListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBaseList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBaseListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBaseListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBaseListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBaseListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBaseList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBaseListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBaseList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBaseListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBaseListCore(property, oldParent, position, newParent);
    		MovedBaseListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBaseList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBaseListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBaseList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBaseListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBaseListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBaseListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBaseList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBaseListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBaseList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBaseListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBaseListCore(property, oldParent, position, newParent);
    		MatchedBaseListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeParameterConstraintClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeParameterConstraintClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameterConstraintClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeParameterConstraintClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeParameterConstraintClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeParameterConstraintClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeParameterConstraintClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeParameterConstraintClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeParameterConstraintClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeParameterConstraintClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeParameterConstraintClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeParameterConstraintClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeParameterConstraintClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeParameterConstraintClauseCore(property, position, parent);
    		InsertedTypeParameterConstraintClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeParameterConstraintClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameterConstraintClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeParameterConstraintClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeParameterConstraintClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeParameterConstraintClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeParameterConstraintClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeParameterConstraintClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeParameterConstraintClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeParameterConstraintClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeParameterConstraintClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeParameterConstraintClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeParameterConstraintClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeParameterConstraintClauseCore(property, parent);
    		DeletedTypeParameterConstraintClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeParameterConstraintClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameterConstraintClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeParameterConstraintClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeParameterConstraintClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeParameterConstraintClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeParameterConstraintClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeParameterConstraintClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeParameterConstraintClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeParameterConstraintClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeParameterConstraintClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeParameterConstraintClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeParameterConstraintClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeParameterConstraintClauseCore(oldElement, newElement);
    		UpdatedTypeParameterConstraintClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeParameterConstraintClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeParameterConstraintClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeParameterConstraintClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeParameterConstraintClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeParameterConstraintClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeParameterConstraintClauseCore(property, oldParent, position, newParent);
    		MovedTypeParameterConstraintClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterConstraintClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeParameterConstraintClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterConstraintClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameterConstraintClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeParameterConstraintClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeParameterConstraintClauseCore(property, oldParent, position, newParent);
    		MatchedTypeParameterConstraintClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ExplicitInterfaceSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedExplicitInterfaceSpecifier(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExplicitInterfaceSpecifier(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedExplicitInterfaceSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedExplicitInterfaceSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedExplicitInterfaceSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedExplicitInterfaceSpecifierCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExplicitInterfaceSpecifierCore(XElement, int, XElement)"/>.</param>
        partial void InsertedExplicitInterfaceSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedExplicitInterfaceSpecifier(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedExplicitInterfaceSpecifierCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedExplicitInterfaceSpecifier(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedExplicitInterfaceSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedExplicitInterfaceSpecifierCore(property, position, parent);
    		InsertedExplicitInterfaceSpecifierAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedExplicitInterfaceSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExplicitInterfaceSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedExplicitInterfaceSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedExplicitInterfaceSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedExplicitInterfaceSpecifierBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.</param>
        partial void DeletedExplicitInterfaceSpecifierAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedExplicitInterfaceSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedExplicitInterfaceSpecifierCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedExplicitInterfaceSpecifier(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedExplicitInterfaceSpecifierBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedExplicitInterfaceSpecifierCore(property, parent);
    		DeletedExplicitInterfaceSpecifierAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedExplicitInterfaceSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExplicitInterfaceSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedExplicitInterfaceSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedExplicitInterfaceSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedExplicitInterfaceSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.</param>
        partial void UpdatedExplicitInterfaceSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedExplicitInterfaceSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedExplicitInterfaceSpecifierCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedExplicitInterfaceSpecifier(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedExplicitInterfaceSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedExplicitInterfaceSpecifierCore(oldElement, newElement);
    		UpdatedExplicitInterfaceSpecifierAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedExplicitInterfaceSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedExplicitInterfaceSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedExplicitInterfaceSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedExplicitInterfaceSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedExplicitInterfaceSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedExplicitInterfaceSpecifierCore(property, oldParent, position, newParent);
    		MovedExplicitInterfaceSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExplicitInterfaceSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedExplicitInterfaceSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExplicitInterfaceSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedExplicitInterfaceSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedExplicitInterfaceSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedExplicitInterfaceSpecifierCore(property, oldParent, position, newParent);
    		MatchedExplicitInterfaceSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConstructorInitializer
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConstructorInitializer(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorInitializer(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConstructorInitializerCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConstructorInitializer(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConstructorInitializerBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConstructorInitializerCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorInitializerCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConstructorInitializerAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConstructorInitializer(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConstructorInitializerCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConstructorInitializer(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConstructorInitializerBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConstructorInitializerCore(property, position, parent);
    		InsertedConstructorInitializerAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConstructorInitializer(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorInitializer(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConstructorInitializerCore(XElement, XElement)"/> is not executed and <see cref="DeletedConstructorInitializer(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConstructorInitializerBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConstructorInitializerCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorInitializerCore(XElement, XElement)"/>.</param>
        partial void DeletedConstructorInitializerAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConstructorInitializer(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConstructorInitializerCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConstructorInitializer(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConstructorInitializerBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConstructorInitializerCore(property, parent);
    		DeletedConstructorInitializerAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConstructorInitializer(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorInitializer(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConstructorInitializerCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConstructorInitializer(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConstructorInitializerBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConstructorInitializerCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorInitializerCore(XElement, XElement)"/>.</param>
        partial void UpdatedConstructorInitializerAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConstructorInitializer(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConstructorInitializerCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ThisOrBaseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConstructorInitializer(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConstructorInitializerBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConstructorInitializerCore(oldElement, newElement);
    		UpdatedConstructorInitializerAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConstructorInitializer(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorInitializer(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConstructorInitializerCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConstructorInitializer(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConstructorInitializerBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConstructorInitializerCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorInitializerCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConstructorInitializerAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConstructorInitializer(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConstructorInitializerCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConstructorInitializer(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConstructorInitializerBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConstructorInitializerCore(property, oldParent, position, newParent);
    		MovedConstructorInitializerAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorInitializer(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorInitializer(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorInitializerCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConstructorInitializer(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorInitializerBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorInitializerCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorInitializerCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConstructorInitializerAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorInitializer(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorInitializerCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorInitializer(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConstructorInitializerBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConstructorInitializerCore(property, oldParent, position, newParent);
    		MatchedConstructorInitializerAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ArrowExpressionClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArrowExpressionClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrowExpressionClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArrowExpressionClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArrowExpressionClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArrowExpressionClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArrowExpressionClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrowExpressionClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArrowExpressionClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArrowExpressionClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArrowExpressionClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArrowExpressionClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArrowExpressionClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArrowExpressionClauseCore(property, position, parent);
    		InsertedArrowExpressionClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArrowExpressionClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrowExpressionClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArrowExpressionClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedArrowExpressionClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArrowExpressionClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArrowExpressionClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrowExpressionClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedArrowExpressionClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArrowExpressionClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArrowExpressionClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArrowExpressionClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArrowExpressionClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArrowExpressionClauseCore(property, parent);
    		DeletedArrowExpressionClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArrowExpressionClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrowExpressionClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArrowExpressionClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArrowExpressionClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArrowExpressionClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArrowExpressionClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrowExpressionClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedArrowExpressionClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArrowExpressionClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArrowExpressionClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArrowExpressionClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArrowExpressionClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArrowExpressionClauseCore(oldElement, newElement);
    		UpdatedArrowExpressionClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArrowExpressionClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrowExpressionClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArrowExpressionClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArrowExpressionClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArrowExpressionClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArrowExpressionClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArrowExpressionClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArrowExpressionClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArrowExpressionClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArrowExpressionClauseCore(property, oldParent, position, newParent);
    		MovedArrowExpressionClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrowExpressionClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrowExpressionClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArrowExpressionClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrowExpressionClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArrowExpressionClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrowExpressionClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrowExpressionClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArrowExpressionClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArrowExpressionClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArrowExpressionClauseCore(property, oldParent, position, newParent);
    		MatchedArrowExpressionClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AccessorList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAccessorList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAccessorList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAccessorListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAccessorList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAccessorListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAccessorListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAccessorListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAccessorListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAccessorList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAccessorListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAccessorList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAccessorListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAccessorListCore(property, position, parent);
    		InsertedAccessorListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAccessorList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAccessorList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAccessorListCore(XElement, XElement)"/> is not executed and <see cref="DeletedAccessorList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAccessorListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAccessorListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAccessorListCore(XElement, XElement)"/>.</param>
        partial void DeletedAccessorListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAccessorList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAccessorListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAccessorList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAccessorListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAccessorListCore(property, parent);
    		DeletedAccessorListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAccessorList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAccessorList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAccessorListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAccessorList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAccessorListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAccessorListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAccessorListCore(XElement, XElement)"/>.</param>
        partial void UpdatedAccessorListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAccessorList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAccessorListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAccessorList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAccessorListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAccessorListCore(oldElement, newElement);
    		UpdatedAccessorListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAccessorList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAccessorList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAccessorListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAccessorList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAccessorListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAccessorListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAccessorListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAccessorListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAccessorList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAccessorListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAccessorList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAccessorListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAccessorListCore(property, oldParent, position, newParent);
    		MovedAccessorListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAccessorList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAccessorListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAccessorList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAccessorListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAccessorListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAccessorListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAccessorList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAccessorListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAccessorList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAccessorListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAccessorListCore(property, oldParent, position, newParent);
    		MatchedAccessorListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AccessorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAccessorDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAccessorDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAccessorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAccessorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAccessorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAccessorDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAccessorDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAccessorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAccessorDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAccessorDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAccessorDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAccessorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAccessorDeclarationCore(property, position, parent);
    		InsertedAccessorDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAccessorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAccessorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAccessorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedAccessorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAccessorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAccessorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAccessorDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedAccessorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAccessorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAccessorDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAccessorDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAccessorDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAccessorDeclarationCore(property, parent);
    		DeletedAccessorDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAccessorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAccessorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAccessorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAccessorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAccessorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAccessorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAccessorDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedAccessorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAccessorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAccessorDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAccessorDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAccessorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAccessorDeclarationCore(oldElement, newElement);
    		UpdatedAccessorDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAccessorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAccessorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAccessorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAccessorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAccessorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAccessorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAccessorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAccessorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAccessorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAccessorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAccessorDeclarationCore(property, oldParent, position, newParent);
    		MovedAccessorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAccessorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAccessorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAccessorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAccessorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAccessorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAccessorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAccessorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAccessorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAccessorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAccessorDeclarationCore(property, oldParent, position, newParent);
    		MatchedAccessorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Parameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedParameter(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParameter(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedParameterCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParameterCore(XElement, int, XElement)"/>.</param>
        partial void InsertedParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedParameter(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedParameterCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedParameter(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedParameterBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedParameterCore(property, position, parent);
    		InsertedParameterAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedParameterBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParameterCore(XElement, XElement)"/>.</param>
        partial void DeletedParameterAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedParameterCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedParameter(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedParameterBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedParameterCore(property, parent);
    		DeletedParameterAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParameterCore(XElement, XElement)"/>.</param>
        partial void UpdatedParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedParameterCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedParameter(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedParameterCore(oldElement, newElement);
    		UpdatedParameterAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedParameterCore(property, oldParent, position, newParent);
    		MovedParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedParameterCore(property, oldParent, position, newParent);
    		MatchedParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CrefParameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCrefParameter(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefParameter(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCrefParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCrefParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCrefParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCrefParameterCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefParameterCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCrefParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCrefParameter(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCrefParameterCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCrefParameter(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCrefParameterBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCrefParameterCore(property, position, parent);
    		InsertedCrefParameterAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCrefParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCrefParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedCrefParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCrefParameterBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCrefParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefParameterCore(XElement, XElement)"/>.</param>
        partial void DeletedCrefParameterAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCrefParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCrefParameterCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCrefParameter(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCrefParameterBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCrefParameterCore(property, parent);
    		DeletedCrefParameterAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCrefParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCrefParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCrefParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCrefParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCrefParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefParameterCore(XElement, XElement)"/>.</param>
        partial void UpdatedCrefParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCrefParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCrefParameterCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCrefParameter(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCrefParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCrefParameterCore(oldElement, newElement);
    		UpdatedCrefParameterAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCrefParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCrefParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCrefParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCrefParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCrefParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCrefParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCrefParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCrefParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCrefParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCrefParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCrefParameterCore(property, oldParent, position, newParent);
    		MovedCrefParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefParameter(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameter(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCrefParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefParameterCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCrefParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefParameter(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCrefParameter(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCrefParameterBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCrefParameterCore(property, oldParent, position, newParent);
    		MatchedCrefParameterAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlElementStartTag
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlElementStartTag(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElementStartTag(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlElementStartTagCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlElementStartTag(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlElementStartTagBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlElementStartTagCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElementStartTagCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlElementStartTagAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlElementStartTag(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlElementStartTagCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlElementStartTag(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlElementStartTagBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlElementStartTagCore(property, position, parent);
    		InsertedXmlElementStartTagAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlElementStartTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElementStartTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlElementStartTagCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlElementStartTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlElementStartTagBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlElementStartTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElementStartTagCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlElementStartTagAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlElementStartTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlElementStartTagCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlElementStartTag(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlElementStartTagBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlElementStartTagCore(property, parent);
    		DeletedXmlElementStartTagAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlElementStartTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElementStartTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlElementStartTagCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlElementStartTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlElementStartTagBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlElementStartTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElementStartTagCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlElementStartTagAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlElementStartTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlElementStartTagCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlElementStartTag(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlElementStartTagBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlElementStartTagCore(oldElement, newElement);
    		UpdatedXmlElementStartTagAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlElementStartTag(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElementStartTag(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlElementStartTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlElementStartTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlElementStartTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlElementStartTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlElementStartTag(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlElementStartTagCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlElementStartTag(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlElementStartTagBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlElementStartTagCore(property, oldParent, position, newParent);
    		MovedXmlElementStartTagAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElementStartTag(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementStartTag(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementStartTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlElementStartTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementStartTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlElementStartTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElementStartTag(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementStartTagCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElementStartTag(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlElementStartTagBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlElementStartTagCore(property, oldParent, position, newParent);
    		MatchedXmlElementStartTagAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlElementEndTag
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlElementEndTag(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElementEndTag(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlElementEndTagCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlElementEndTag(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlElementEndTagBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlElementEndTagCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElementEndTagCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlElementEndTagAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlElementEndTag(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlElementEndTagCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlElementEndTag(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlElementEndTagBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlElementEndTagCore(property, position, parent);
    		InsertedXmlElementEndTagAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlElementEndTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElementEndTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlElementEndTagCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlElementEndTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlElementEndTagBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlElementEndTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElementEndTagCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlElementEndTagAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlElementEndTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlElementEndTagCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlElementEndTag(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlElementEndTagBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlElementEndTagCore(property, parent);
    		DeletedXmlElementEndTagAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlElementEndTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElementEndTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlElementEndTagCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlElementEndTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlElementEndTagBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlElementEndTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElementEndTagCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlElementEndTagAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlElementEndTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlElementEndTagCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanSlashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlElementEndTag(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlElementEndTagBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlElementEndTagCore(oldElement, newElement);
    		UpdatedXmlElementEndTagAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlElementEndTag(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElementEndTag(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlElementEndTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlElementEndTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlElementEndTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlElementEndTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlElementEndTag(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlElementEndTagCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlElementEndTag(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlElementEndTagBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlElementEndTagCore(property, oldParent, position, newParent);
    		MovedXmlElementEndTagAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElementEndTag(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementEndTag(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementEndTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlElementEndTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementEndTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlElementEndTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElementEndTag(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementEndTagCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElementEndTag(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlElementEndTagBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlElementEndTagCore(property, oldParent, position, newParent);
    		MatchedXmlElementEndTagAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlName(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlName(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlNameBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlNameCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlNameCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlNameAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlName(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlNameCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlName(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlNameBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlNameCore(property, position, parent);
    		InsertedXmlNameAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlNameBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlNameCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlNameAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlNameCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlName(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlNameBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlNameCore(property, parent);
    		DeletedXmlNameAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlNameCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlNameCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlName(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlNameBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlNameCore(oldElement, newElement);
    		UpdatedXmlNameAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlNameCore(property, oldParent, position, newParent);
    		MovedXmlNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlNameCore(property, oldParent, position, newParent);
    		MatchedXmlNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlPrefix
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlPrefix(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlPrefix(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlPrefixCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlPrefix(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlPrefixBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlPrefixCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlPrefixCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlPrefixAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlPrefix(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlPrefixCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlPrefix(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlPrefixBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlPrefixCore(property, position, parent);
    		InsertedXmlPrefixAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlPrefix(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlPrefix(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlPrefixCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlPrefix(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlPrefixBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlPrefixCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlPrefixCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlPrefixAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlPrefix(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlPrefixCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlPrefix(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlPrefixBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlPrefixCore(property, parent);
    		DeletedXmlPrefixAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlPrefix(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlPrefix(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlPrefixCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlPrefix(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlPrefixBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlPrefixCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlPrefixCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlPrefixAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlPrefix(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlPrefixCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlPrefix(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlPrefixBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlPrefixCore(oldElement, newElement);
    		UpdatedXmlPrefixAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlPrefix(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlPrefix(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlPrefixCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlPrefix(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlPrefixBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlPrefixCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlPrefixCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlPrefixAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlPrefix(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlPrefixCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlPrefix(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlPrefixBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlPrefixCore(property, oldParent, position, newParent);
    		MovedXmlPrefixAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlPrefix(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlPrefix(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlPrefixCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlPrefix(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlPrefixBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlPrefixCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlPrefixCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlPrefixAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlPrefix(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlPrefixCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlPrefix(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlPrefixBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlPrefixCore(property, oldParent, position, newParent);
    		MatchedXmlPrefixAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeArgumentList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeArgumentList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeArgumentListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeArgumentListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeArgumentList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeArgumentListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeArgumentList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeArgumentListCore(property, position, parent);
    		InsertedTypeArgumentListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeArgumentListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeArgumentListCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeArgumentListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeArgumentListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeArgumentList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeArgumentListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeArgumentListCore(property, parent);
    		DeletedTypeArgumentListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeArgumentListCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeArgumentListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeArgumentList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeArgumentListCore(oldElement, newElement);
    		UpdatedTypeArgumentListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeArgumentListCore(property, oldParent, position, newParent);
    		MovedTypeArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "GreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeArgumentListCore(property, oldParent, position, newParent);
    		MatchedTypeArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ArrayRankSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArrayRankSpecifier(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayRankSpecifier(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArrayRankSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArrayRankSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArrayRankSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArrayRankSpecifierCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayRankSpecifierCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArrayRankSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArrayRankSpecifier(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArrayRankSpecifierCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArrayRankSpecifier(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArrayRankSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArrayRankSpecifierCore(property, position, parent);
    		InsertedArrayRankSpecifierAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArrayRankSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayRankSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArrayRankSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedArrayRankSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArrayRankSpecifierBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArrayRankSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayRankSpecifierCore(XElement, XElement)"/>.</param>
        partial void DeletedArrayRankSpecifierAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArrayRankSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArrayRankSpecifierCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArrayRankSpecifier(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArrayRankSpecifierBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArrayRankSpecifierCore(property, parent);
    		DeletedArrayRankSpecifierAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArrayRankSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayRankSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArrayRankSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArrayRankSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArrayRankSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArrayRankSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayRankSpecifierCore(XElement, XElement)"/>.</param>
        partial void UpdatedArrayRankSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArrayRankSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArrayRankSpecifierCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArrayRankSpecifier(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArrayRankSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArrayRankSpecifierCore(oldElement, newElement);
    		UpdatedArrayRankSpecifierAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArrayRankSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArrayRankSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArrayRankSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArrayRankSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArrayRankSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArrayRankSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArrayRankSpecifierCore(property, oldParent, position, newParent);
    		MovedArrayRankSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArrayRankSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayRankSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArrayRankSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayRankSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArrayRankSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArrayRankSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArrayRankSpecifierCore(property, oldParent, position, newParent);
    		MatchedArrayRankSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TupleElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTupleElement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleElement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTupleElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTupleElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTupleElementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTupleElementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleElementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTupleElementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTupleElement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTupleElementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTupleElement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTupleElementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTupleElementCore(property, position, parent);
    		InsertedTupleElementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTupleElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTupleElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedTupleElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTupleElementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTupleElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleElementCore(XElement, XElement)"/>.</param>
        partial void DeletedTupleElementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTupleElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTupleElementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTupleElement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTupleElementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTupleElementCore(property, parent);
    		DeletedTupleElementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTupleElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTupleElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTupleElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTupleElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTupleElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleElementCore(XElement, XElement)"/>.</param>
        partial void UpdatedTupleElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTupleElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTupleElementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTupleElement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTupleElementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTupleElementCore(oldElement, newElement);
    		UpdatedTupleElementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTupleElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTupleElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTupleElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTupleElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTupleElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTupleElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTupleElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTupleElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTupleElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTupleElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTupleElementCore(property, oldParent, position, newParent);
    		MovedTupleElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTupleElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTupleElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTupleElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTupleElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTupleElementCore(property, oldParent, position, newParent);
    		MatchedTupleElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Argument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArgument(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArgument(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArgumentCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArgumentCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArgument(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArgumentCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArgument(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArgumentBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArgumentCore(property, position, parent);
    		InsertedArgumentAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArgumentBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArgumentCore(XElement, XElement)"/>.</param>
        partial void DeletedArgumentAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArgumentCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArgument(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArgumentBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArgumentCore(property, parent);
    		DeletedArgumentAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArgumentCore(XElement, XElement)"/>.</param>
        partial void UpdatedArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArgumentCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArgument(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArgumentCore(oldElement, newElement);
    		UpdatedArgumentAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArgumentCore(property, oldParent, position, newParent);
    		MovedArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKindKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArgumentCore(property, oldParent, position, newParent);
    		MatchedArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region NameColon
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedNameColon(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameColon(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedNameColonCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedNameColon(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedNameColonBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedNameColonCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameColonCore(XElement, int, XElement)"/>.</param>
        partial void InsertedNameColonAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedNameColon(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedNameColonCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedNameColon(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedNameColonBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedNameColonCore(property, position, parent);
    		InsertedNameColonAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedNameColon(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameColon(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedNameColonCore(XElement, XElement)"/> is not executed and <see cref="DeletedNameColon(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedNameColonBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedNameColonCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameColonCore(XElement, XElement)"/>.</param>
        partial void DeletedNameColonAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedNameColon(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedNameColonCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedNameColon(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedNameColonBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedNameColonCore(property, parent);
    		DeletedNameColonAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedNameColon(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameColon(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedNameColonCore(XElement, XElement)"/> is not executed and <see cref="UpdatedNameColon(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedNameColonBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedNameColonCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameColonCore(XElement, XElement)"/>.</param>
        partial void UpdatedNameColonAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedNameColon(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedNameColonCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedNameColon(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedNameColonBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedNameColonCore(oldElement, newElement);
    		UpdatedNameColonAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedNameColon(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameColon(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedNameColonCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedNameColon(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedNameColonBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedNameColonCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameColonCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedNameColonAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedNameColon(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedNameColonCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedNameColon(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedNameColonBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedNameColonCore(property, oldParent, position, newParent);
    		MovedNameColonAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameColon(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameColon(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameColonCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedNameColon(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameColonBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameColonCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameColonCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedNameColonAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameColon(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameColonCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedNameColon(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedNameColonBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedNameColonCore(property, oldParent, position, newParent);
    		MatchedNameColonAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AnonymousObjectMemberDeclarator
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAnonymousObjectMemberDeclarator(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAnonymousObjectMemberDeclaratorBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAnonymousObjectMemberDeclaratorAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAnonymousObjectMemberDeclaratorCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAnonymousObjectMemberDeclarator(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAnonymousObjectMemberDeclaratorBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAnonymousObjectMemberDeclaratorCore(property, position, parent);
    		InsertedAnonymousObjectMemberDeclaratorAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="DeletedAnonymousObjectMemberDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAnonymousObjectMemberDeclaratorBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.</param>
        partial void DeletedAnonymousObjectMemberDeclaratorAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAnonymousObjectMemberDeclaratorCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAnonymousObjectMemberDeclarator(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAnonymousObjectMemberDeclaratorBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAnonymousObjectMemberDeclaratorCore(property, parent);
    		DeletedAnonymousObjectMemberDeclaratorAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAnonymousObjectMemberDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAnonymousObjectMemberDeclaratorBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.</param>
        partial void UpdatedAnonymousObjectMemberDeclaratorAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAnonymousObjectMemberDeclaratorCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAnonymousObjectMemberDeclarator(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAnonymousObjectMemberDeclaratorBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAnonymousObjectMemberDeclaratorCore(oldElement, newElement);
    		UpdatedAnonymousObjectMemberDeclaratorAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAnonymousObjectMemberDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAnonymousObjectMemberDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAnonymousObjectMemberDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAnonymousObjectMemberDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAnonymousObjectMemberDeclaratorBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAnonymousObjectMemberDeclaratorCore(property, oldParent, position, newParent);
    		MovedAnonymousObjectMemberDeclaratorAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousObjectMemberDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAnonymousObjectMemberDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectMemberDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectMemberDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAnonymousObjectMemberDeclaratorBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAnonymousObjectMemberDeclaratorCore(property, oldParent, position, newParent);
    		MatchedAnonymousObjectMemberDeclaratorAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region QueryBody
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedQueryBody(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryBody(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedQueryBodyCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedQueryBody(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedQueryBodyBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedQueryBodyCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryBodyCore(XElement, int, XElement)"/>.</param>
        partial void InsertedQueryBodyAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedQueryBody(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedQueryBodyCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedQueryBody(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedQueryBodyBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedQueryBodyCore(property, position, parent);
    		InsertedQueryBodyAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedQueryBody(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryBody(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedQueryBodyCore(XElement, XElement)"/> is not executed and <see cref="DeletedQueryBody(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedQueryBodyBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedQueryBodyCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryBodyCore(XElement, XElement)"/>.</param>
        partial void DeletedQueryBodyAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedQueryBody(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedQueryBodyCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedQueryBody(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedQueryBodyBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedQueryBodyCore(property, parent);
    		DeletedQueryBodyAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedQueryBody(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryBody(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedQueryBodyCore(XElement, XElement)"/> is not executed and <see cref="UpdatedQueryBody(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedQueryBodyBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedQueryBodyCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryBodyCore(XElement, XElement)"/>.</param>
        partial void UpdatedQueryBodyAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedQueryBody(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedQueryBodyCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedQueryBody(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedQueryBodyBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedQueryBodyCore(oldElement, newElement);
    		UpdatedQueryBodyAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedQueryBody(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryBody(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedQueryBodyCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedQueryBody(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedQueryBodyBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedQueryBodyCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryBodyCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedQueryBodyAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedQueryBody(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedQueryBodyCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedQueryBody(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedQueryBodyBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedQueryBodyCore(property, oldParent, position, newParent);
    		MovedQueryBodyAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryBody(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryBody(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryBodyCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedQueryBody(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryBodyBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryBodyCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryBodyCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedQueryBodyAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryBody(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryBodyCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedQueryBody(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedQueryBodyBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedQueryBodyCore(property, oldParent, position, newParent);
    		MatchedQueryBodyAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region JoinIntoClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedJoinIntoClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedJoinIntoClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedJoinIntoClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedJoinIntoClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedJoinIntoClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedJoinIntoClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedJoinIntoClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedJoinIntoClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedJoinIntoClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedJoinIntoClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedJoinIntoClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedJoinIntoClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedJoinIntoClauseCore(property, position, parent);
    		InsertedJoinIntoClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedJoinIntoClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedJoinIntoClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedJoinIntoClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedJoinIntoClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedJoinIntoClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedJoinIntoClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedJoinIntoClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedJoinIntoClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedJoinIntoClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedJoinIntoClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedJoinIntoClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedJoinIntoClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedJoinIntoClauseCore(property, parent);
    		DeletedJoinIntoClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedJoinIntoClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedJoinIntoClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedJoinIntoClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedJoinIntoClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedJoinIntoClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedJoinIntoClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedJoinIntoClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedJoinIntoClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedJoinIntoClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedJoinIntoClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedJoinIntoClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedJoinIntoClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedJoinIntoClauseCore(oldElement, newElement);
    		UpdatedJoinIntoClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedJoinIntoClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedJoinIntoClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedJoinIntoClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedJoinIntoClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedJoinIntoClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedJoinIntoClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedJoinIntoClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedJoinIntoClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedJoinIntoClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedJoinIntoClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedJoinIntoClauseCore(property, oldParent, position, newParent);
    		MovedJoinIntoClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedJoinIntoClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinIntoClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedJoinIntoClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedJoinIntoClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedJoinIntoClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedJoinIntoClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedJoinIntoClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedJoinIntoClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedJoinIntoClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedJoinIntoClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedJoinIntoClauseCore(property, oldParent, position, newParent);
    		MatchedJoinIntoClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Ordering
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOrdering(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOrdering(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOrderingCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOrdering(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOrderingBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOrderingCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOrderingCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOrderingAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOrdering(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOrderingCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOrdering(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOrderingBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOrderingCore(property, position, parent);
    		InsertedOrderingAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOrdering(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOrdering(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOrderingCore(XElement, XElement)"/> is not executed and <see cref="DeletedOrdering(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOrderingBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOrderingCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOrderingCore(XElement, XElement)"/>.</param>
        partial void DeletedOrderingAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOrdering(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOrderingCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOrdering(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOrderingBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOrderingCore(property, parent);
    		DeletedOrderingAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOrdering(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOrdering(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOrderingCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOrdering(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOrderingBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOrderingCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOrderingCore(XElement, XElement)"/>.</param>
        partial void UpdatedOrderingAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOrdering(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOrderingCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOrdering(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOrderingBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOrderingCore(oldElement, newElement);
    		UpdatedOrderingAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOrdering(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOrdering(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOrderingCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOrdering(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOrderingBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOrderingCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOrderingCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOrderingAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOrdering(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOrderingCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOrdering(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOrderingBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOrderingCore(property, oldParent, position, newParent);
    		MovedOrderingAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOrdering(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrdering(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOrderingCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOrdering(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOrderingBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOrderingCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderingCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOrderingAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOrdering(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOrderingCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOrdering(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOrderingBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOrderingCore(property, oldParent, position, newParent);
    		MatchedOrderingAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region QueryContinuation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedQueryContinuation(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryContinuation(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedQueryContinuationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedQueryContinuation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedQueryContinuationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedQueryContinuationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryContinuationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedQueryContinuationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedQueryContinuation(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedQueryContinuationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedQueryContinuation(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedQueryContinuationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedQueryContinuationCore(property, position, parent);
    		InsertedQueryContinuationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedQueryContinuation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryContinuation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedQueryContinuationCore(XElement, XElement)"/> is not executed and <see cref="DeletedQueryContinuation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedQueryContinuationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedQueryContinuationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryContinuationCore(XElement, XElement)"/>.</param>
        partial void DeletedQueryContinuationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedQueryContinuation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedQueryContinuationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedQueryContinuation(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedQueryContinuationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedQueryContinuationCore(property, parent);
    		DeletedQueryContinuationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedQueryContinuation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryContinuation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedQueryContinuationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedQueryContinuation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedQueryContinuationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedQueryContinuationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryContinuationCore(XElement, XElement)"/>.</param>
        partial void UpdatedQueryContinuationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedQueryContinuation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedQueryContinuationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedQueryContinuation(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedQueryContinuationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedQueryContinuationCore(oldElement, newElement);
    		UpdatedQueryContinuationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedQueryContinuation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryContinuation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedQueryContinuationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedQueryContinuation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedQueryContinuationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedQueryContinuationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryContinuationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedQueryContinuationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedQueryContinuation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedQueryContinuationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedQueryContinuation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedQueryContinuationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedQueryContinuationCore(property, oldParent, position, newParent);
    		MovedQueryContinuationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryContinuation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryContinuation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryContinuationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedQueryContinuation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryContinuationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryContinuationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryContinuationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedQueryContinuationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryContinuation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryContinuationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IntoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedQueryContinuation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedQueryContinuationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedQueryContinuationCore(property, oldParent, position, newParent);
    		MatchedQueryContinuationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region WhenClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedWhenClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhenClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedWhenClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedWhenClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedWhenClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedWhenClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhenClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedWhenClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedWhenClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedWhenClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedWhenClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedWhenClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedWhenClauseCore(property, position, parent);
    		InsertedWhenClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedWhenClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhenClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedWhenClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedWhenClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedWhenClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedWhenClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhenClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedWhenClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedWhenClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedWhenClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedWhenClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedWhenClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedWhenClauseCore(property, parent);
    		DeletedWhenClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedWhenClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhenClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedWhenClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedWhenClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedWhenClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedWhenClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhenClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedWhenClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedWhenClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedWhenClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedWhenClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedWhenClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedWhenClauseCore(oldElement, newElement);
    		UpdatedWhenClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedWhenClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhenClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedWhenClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedWhenClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedWhenClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedWhenClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhenClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedWhenClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedWhenClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedWhenClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedWhenClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedWhenClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedWhenClauseCore(property, oldParent, position, newParent);
    		MovedWhenClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhenClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhenClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhenClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedWhenClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhenClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhenClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhenClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedWhenClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhenClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhenClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedWhenClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedWhenClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedWhenClauseCore(property, oldParent, position, newParent);
    		MatchedWhenClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InterpolationAlignmentClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterpolationAlignmentClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolationAlignmentClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterpolationAlignmentClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterpolationAlignmentClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterpolationAlignmentClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterpolationAlignmentClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolationAlignmentClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterpolationAlignmentClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterpolationAlignmentClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterpolationAlignmentClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CommaToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterpolationAlignmentClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterpolationAlignmentClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterpolationAlignmentClauseCore(property, position, parent);
    		InsertedInterpolationAlignmentClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterpolationAlignmentClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolationAlignmentClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterpolationAlignmentClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterpolationAlignmentClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterpolationAlignmentClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterpolationAlignmentClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolationAlignmentClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedInterpolationAlignmentClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterpolationAlignmentClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterpolationAlignmentClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CommaToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterpolationAlignmentClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterpolationAlignmentClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterpolationAlignmentClauseCore(property, parent);
    		DeletedInterpolationAlignmentClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterpolationAlignmentClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolationAlignmentClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterpolationAlignmentClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterpolationAlignmentClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterpolationAlignmentClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterpolationAlignmentClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolationAlignmentClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterpolationAlignmentClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterpolationAlignmentClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterpolationAlignmentClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "CommaToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterpolationAlignmentClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterpolationAlignmentClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterpolationAlignmentClauseCore(oldElement, newElement);
    		UpdatedInterpolationAlignmentClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterpolationAlignmentClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterpolationAlignmentClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterpolationAlignmentClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CommaToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterpolationAlignmentClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterpolationAlignmentClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterpolationAlignmentClauseCore(property, oldParent, position, newParent);
    		MovedInterpolationAlignmentClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationAlignmentClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterpolationAlignmentClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationAlignmentClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CommaToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolationAlignmentClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterpolationAlignmentClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterpolationAlignmentClauseCore(property, oldParent, position, newParent);
    		MatchedInterpolationAlignmentClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InterpolationFormatClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterpolationFormatClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolationFormatClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterpolationFormatClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterpolationFormatClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterpolationFormatClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterpolationFormatClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolationFormatClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterpolationFormatClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterpolationFormatClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterpolationFormatClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterpolationFormatClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterpolationFormatClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterpolationFormatClauseCore(property, position, parent);
    		InsertedInterpolationFormatClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterpolationFormatClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolationFormatClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterpolationFormatClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterpolationFormatClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterpolationFormatClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterpolationFormatClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolationFormatClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedInterpolationFormatClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterpolationFormatClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterpolationFormatClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterpolationFormatClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterpolationFormatClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterpolationFormatClauseCore(property, parent);
    		DeletedInterpolationFormatClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterpolationFormatClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolationFormatClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterpolationFormatClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterpolationFormatClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterpolationFormatClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterpolationFormatClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolationFormatClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterpolationFormatClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterpolationFormatClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterpolationFormatClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterpolationFormatClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterpolationFormatClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterpolationFormatClauseCore(oldElement, newElement);
    		UpdatedInterpolationFormatClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterpolationFormatClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterpolationFormatClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterpolationFormatClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterpolationFormatClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterpolationFormatClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterpolationFormatClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterpolationFormatClauseCore(property, oldParent, position, newParent);
    		MovedInterpolationFormatClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterpolationFormatClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationFormatClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterpolationFormatClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationFormatClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolationFormatClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterpolationFormatClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterpolationFormatClauseCore(property, oldParent, position, newParent);
    		MatchedInterpolationFormatClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region VariableDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedVariableDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedVariableDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedVariableDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedVariableDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedVariableDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedVariableDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedVariableDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedVariableDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedVariableDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedVariableDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedVariableDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedVariableDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedVariableDeclarationCore(property, position, parent);
    		InsertedVariableDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedVariableDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedVariableDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedVariableDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedVariableDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedVariableDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedVariableDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedVariableDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedVariableDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedVariableDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedVariableDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedVariableDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedVariableDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedVariableDeclarationCore(property, parent);
    		DeletedVariableDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedVariableDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedVariableDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedVariableDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedVariableDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedVariableDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedVariableDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedVariableDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedVariableDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedVariableDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedVariableDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedVariableDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedVariableDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedVariableDeclarationCore(oldElement, newElement);
    		UpdatedVariableDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedVariableDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedVariableDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedVariableDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedVariableDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedVariableDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedVariableDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedVariableDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedVariableDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedVariableDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedVariableDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedVariableDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedVariableDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedVariableDeclarationCore(property, oldParent, position, newParent);
    		MovedVariableDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedVariableDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedVariableDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedVariableDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedVariableDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedVariableDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedVariableDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedVariableDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedVariableDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedVariableDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedVariableDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedVariableDeclarationCore(property, oldParent, position, newParent);
    		MatchedVariableDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region VariableDeclarator
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedVariableDeclarator(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedVariableDeclarator(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedVariableDeclaratorCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedVariableDeclarator(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedVariableDeclaratorBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedVariableDeclaratorCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedVariableDeclaratorCore(XElement, int, XElement)"/>.</param>
        partial void InsertedVariableDeclaratorAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedVariableDeclarator(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedVariableDeclaratorCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedVariableDeclarator(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedVariableDeclaratorBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedVariableDeclaratorCore(property, position, parent);
    		InsertedVariableDeclaratorAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedVariableDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedVariableDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedVariableDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="DeletedVariableDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedVariableDeclaratorBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedVariableDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedVariableDeclaratorCore(XElement, XElement)"/>.</param>
        partial void DeletedVariableDeclaratorAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedVariableDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedVariableDeclaratorCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedVariableDeclarator(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedVariableDeclaratorBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedVariableDeclaratorCore(property, parent);
    		DeletedVariableDeclaratorAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedVariableDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedVariableDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedVariableDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="UpdatedVariableDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedVariableDeclaratorBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedVariableDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedVariableDeclaratorCore(XElement, XElement)"/>.</param>
        partial void UpdatedVariableDeclaratorAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedVariableDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedVariableDeclaratorCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedVariableDeclarator(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedVariableDeclaratorBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedVariableDeclaratorCore(oldElement, newElement);
    		UpdatedVariableDeclaratorAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedVariableDeclarator(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedVariableDeclarator(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedVariableDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedVariableDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedVariableDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedVariableDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedVariableDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedVariableDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedVariableDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedVariableDeclaratorBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedVariableDeclaratorCore(property, oldParent, position, newParent);
    		MovedVariableDeclaratorAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedVariableDeclarator(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclarator(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedVariableDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedVariableDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedVariableDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedVariableDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedVariableDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedVariableDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedVariableDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedVariableDeclaratorBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedVariableDeclaratorCore(property, oldParent, position, newParent);
    		MatchedVariableDeclaratorAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EqualsValueClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEqualsValueClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEqualsValueClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEqualsValueClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEqualsValueClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEqualsValueClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEqualsValueClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEqualsValueClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEqualsValueClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEqualsValueClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEqualsValueClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEqualsValueClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEqualsValueClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEqualsValueClauseCore(property, position, parent);
    		InsertedEqualsValueClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEqualsValueClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEqualsValueClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEqualsValueClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedEqualsValueClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEqualsValueClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEqualsValueClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEqualsValueClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedEqualsValueClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEqualsValueClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEqualsValueClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEqualsValueClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEqualsValueClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEqualsValueClauseCore(property, parent);
    		DeletedEqualsValueClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEqualsValueClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEqualsValueClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEqualsValueClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEqualsValueClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEqualsValueClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEqualsValueClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEqualsValueClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedEqualsValueClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEqualsValueClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEqualsValueClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEqualsValueClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEqualsValueClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEqualsValueClauseCore(oldElement, newElement);
    		UpdatedEqualsValueClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEqualsValueClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEqualsValueClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEqualsValueClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEqualsValueClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEqualsValueClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEqualsValueClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEqualsValueClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEqualsValueClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEqualsValueClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEqualsValueClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEqualsValueClauseCore(property, oldParent, position, newParent);
    		MovedEqualsValueClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEqualsValueClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEqualsValueClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEqualsValueClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEqualsValueClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEqualsValueClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEqualsValueClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEqualsValueClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEqualsValueClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEqualsValueClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEqualsValueClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEqualsValueClauseCore(property, oldParent, position, newParent);
    		MatchedEqualsValueClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ElseClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedElseClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElseClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedElseClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedElseClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedElseClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedElseClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElseClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedElseClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedElseClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedElseClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedElseClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedElseClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedElseClauseCore(property, position, parent);
    		InsertedElseClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedElseClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElseClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedElseClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedElseClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedElseClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedElseClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElseClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedElseClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedElseClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedElseClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedElseClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedElseClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedElseClauseCore(property, parent);
    		DeletedElseClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedElseClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElseClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedElseClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedElseClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedElseClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedElseClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElseClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedElseClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedElseClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedElseClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedElseClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedElseClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedElseClauseCore(oldElement, newElement);
    		UpdatedElseClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedElseClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElseClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedElseClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedElseClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedElseClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedElseClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElseClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedElseClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedElseClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedElseClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedElseClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedElseClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedElseClauseCore(property, oldParent, position, newParent);
    		MovedElseClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElseClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElseClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedElseClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElseClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElseClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedElseClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElseClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElseClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedElseClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedElseClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedElseClauseCore(property, oldParent, position, newParent);
    		MatchedElseClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SwitchSection
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSwitchSection(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSwitchSection(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSwitchSectionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSwitchSection(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSwitchSectionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSwitchSectionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSwitchSectionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSwitchSectionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSwitchSection(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSwitchSectionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSwitchSection(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSwitchSectionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSwitchSectionCore(property, position, parent);
    		InsertedSwitchSectionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSwitchSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSwitchSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSwitchSectionCore(XElement, XElement)"/> is not executed and <see cref="DeletedSwitchSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSwitchSectionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSwitchSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSwitchSectionCore(XElement, XElement)"/>.</param>
        partial void DeletedSwitchSectionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSwitchSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSwitchSectionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSwitchSection(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSwitchSectionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSwitchSectionCore(property, parent);
    		DeletedSwitchSectionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSwitchSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSwitchSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSwitchSectionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSwitchSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSwitchSectionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSwitchSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSwitchSectionCore(XElement, XElement)"/>.</param>
        partial void UpdatedSwitchSectionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSwitchSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSwitchSectionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSwitchSection(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSwitchSectionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSwitchSectionCore(oldElement, newElement);
    		UpdatedSwitchSectionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSwitchSection(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSwitchSection(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSwitchSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSwitchSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSwitchSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSwitchSectionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSwitchSectionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSwitchSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSwitchSection(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSwitchSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSwitchSection(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSwitchSectionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSwitchSectionCore(property, oldParent, position, newParent);
    		MovedSwitchSectionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSwitchSection(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchSection(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSwitchSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSwitchSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSwitchSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSwitchSectionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchSectionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSwitchSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSwitchSection(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSwitchSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSwitchSection(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSwitchSectionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSwitchSectionCore(property, oldParent, position, newParent);
    		MatchedSwitchSectionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CatchClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCatchClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCatchClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCatchClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCatchClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCatchClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCatchClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCatchClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCatchClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CatchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCatchClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCatchClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCatchClauseCore(property, position, parent);
    		InsertedCatchClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCatchClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCatchClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedCatchClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCatchClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCatchClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedCatchClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCatchClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCatchClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CatchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCatchClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCatchClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCatchClauseCore(property, parent);
    		DeletedCatchClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCatchClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCatchClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCatchClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCatchClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCatchClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedCatchClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCatchClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCatchClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "CatchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCatchClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCatchClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCatchClauseCore(oldElement, newElement);
    		UpdatedCatchClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCatchClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCatchClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCatchClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCatchClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCatchClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCatchClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCatchClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCatchClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CatchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCatchClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCatchClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCatchClauseCore(property, oldParent, position, newParent);
    		MovedCatchClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCatchClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCatchClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "CatchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCatchClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCatchClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCatchClauseCore(property, oldParent, position, newParent);
    		MatchedCatchClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CatchDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCatchDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCatchDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCatchDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCatchDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCatchDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCatchDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCatchDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCatchDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCatchDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCatchDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCatchDeclarationCore(property, position, parent);
    		InsertedCatchDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCatchDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCatchDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedCatchDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCatchDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCatchDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedCatchDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCatchDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCatchDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCatchDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCatchDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCatchDeclarationCore(property, parent);
    		DeletedCatchDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCatchDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCatchDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCatchDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCatchDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCatchDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedCatchDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCatchDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCatchDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCatchDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCatchDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCatchDeclarationCore(oldElement, newElement);
    		UpdatedCatchDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCatchDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCatchDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCatchDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCatchDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCatchDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCatchDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCatchDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCatchDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCatchDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCatchDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCatchDeclarationCore(property, oldParent, position, newParent);
    		MovedCatchDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCatchDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCatchDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCatchDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCatchDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCatchDeclarationCore(property, oldParent, position, newParent);
    		MatchedCatchDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CatchFilterClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCatchFilterClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchFilterClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCatchFilterClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCatchFilterClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCatchFilterClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCatchFilterClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCatchFilterClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCatchFilterClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCatchFilterClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCatchFilterClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCatchFilterClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCatchFilterClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCatchFilterClauseCore(property, position, parent);
    		InsertedCatchFilterClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCatchFilterClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchFilterClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCatchFilterClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedCatchFilterClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCatchFilterClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCatchFilterClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCatchFilterClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedCatchFilterClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCatchFilterClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCatchFilterClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCatchFilterClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCatchFilterClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCatchFilterClauseCore(property, parent);
    		DeletedCatchFilterClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCatchFilterClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchFilterClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCatchFilterClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCatchFilterClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCatchFilterClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCatchFilterClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCatchFilterClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedCatchFilterClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCatchFilterClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCatchFilterClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCatchFilterClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCatchFilterClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCatchFilterClauseCore(oldElement, newElement);
    		UpdatedCatchFilterClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCatchFilterClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchFilterClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCatchFilterClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCatchFilterClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCatchFilterClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCatchFilterClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCatchFilterClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCatchFilterClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCatchFilterClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCatchFilterClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCatchFilterClauseCore(property, oldParent, position, newParent);
    		MovedCatchFilterClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchFilterClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchFilterClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchFilterClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCatchFilterClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchFilterClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCatchFilterClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchFilterClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchFilterClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhenKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCatchFilterClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCatchFilterClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCatchFilterClauseCore(property, oldParent, position, newParent);
    		MatchedCatchFilterClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region FinallyClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedFinallyClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFinallyClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedFinallyClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFinallyClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedFinallyClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedFinallyClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFinallyClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedFinallyClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedFinallyClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedFinallyClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FinallyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedFinallyClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedFinallyClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedFinallyClauseCore(property, position, parent);
    		InsertedFinallyClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedFinallyClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFinallyClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedFinallyClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFinallyClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedFinallyClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedFinallyClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFinallyClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedFinallyClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedFinallyClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedFinallyClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FinallyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedFinallyClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedFinallyClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedFinallyClauseCore(property, parent);
    		DeletedFinallyClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedFinallyClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFinallyClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedFinallyClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFinallyClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedFinallyClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedFinallyClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFinallyClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedFinallyClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedFinallyClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedFinallyClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "FinallyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedFinallyClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedFinallyClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedFinallyClauseCore(oldElement, newElement);
    		UpdatedFinallyClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedFinallyClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFinallyClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedFinallyClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFinallyClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedFinallyClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedFinallyClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFinallyClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedFinallyClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedFinallyClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedFinallyClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FinallyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedFinallyClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedFinallyClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedFinallyClauseCore(property, oldParent, position, newParent);
    		MovedFinallyClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFinallyClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFinallyClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFinallyClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedFinallyClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFinallyClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFinallyClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFinallyClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedFinallyClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFinallyClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFinallyClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FinallyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedFinallyClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedFinallyClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedFinallyClauseCore(property, oldParent, position, newParent);
    		MatchedFinallyClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CompilationUnit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCompilationUnit(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCompilationUnit(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCompilationUnitCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCompilationUnit(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCompilationUnitBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCompilationUnitCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCompilationUnitCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCompilationUnitAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCompilationUnit(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCompilationUnitCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfFileToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCompilationUnit(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCompilationUnitBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCompilationUnitCore(property, position, parent);
    		InsertedCompilationUnitAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCompilationUnit(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCompilationUnit(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCompilationUnitCore(XElement, XElement)"/> is not executed and <see cref="DeletedCompilationUnit(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCompilationUnitBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCompilationUnitCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCompilationUnitCore(XElement, XElement)"/>.</param>
        partial void DeletedCompilationUnitAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCompilationUnit(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCompilationUnitCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfFileToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCompilationUnit(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCompilationUnitBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCompilationUnitCore(property, parent);
    		DeletedCompilationUnitAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCompilationUnit(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCompilationUnit(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCompilationUnitCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCompilationUnit(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCompilationUnitBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCompilationUnitCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCompilationUnitCore(XElement, XElement)"/>.</param>
        partial void UpdatedCompilationUnitAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCompilationUnit(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCompilationUnitCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EndOfFileToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCompilationUnit(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCompilationUnitBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCompilationUnitCore(oldElement, newElement);
    		UpdatedCompilationUnitAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCompilationUnit(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCompilationUnit(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCompilationUnitCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCompilationUnit(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCompilationUnitBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCompilationUnitCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCompilationUnitCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCompilationUnitAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCompilationUnit(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCompilationUnitCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfFileToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCompilationUnit(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCompilationUnitBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCompilationUnitCore(property, oldParent, position, newParent);
    		MovedCompilationUnitAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCompilationUnit(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCompilationUnit(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCompilationUnitCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCompilationUnit(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCompilationUnitBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCompilationUnitCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCompilationUnitCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCompilationUnitAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCompilationUnit(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCompilationUnitCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfFileToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCompilationUnit(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCompilationUnitBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCompilationUnitCore(property, oldParent, position, newParent);
    		MatchedCompilationUnitAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ExternAliasDirective
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedExternAliasDirective(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExternAliasDirective(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedExternAliasDirectiveCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedExternAliasDirective(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedExternAliasDirectiveBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedExternAliasDirectiveCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExternAliasDirectiveCore(XElement, int, XElement)"/>.</param>
        partial void InsertedExternAliasDirectiveAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedExternAliasDirective(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedExternAliasDirectiveCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ExternKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "AliasKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedExternAliasDirective(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedExternAliasDirectiveBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedExternAliasDirectiveCore(property, position, parent);
    		InsertedExternAliasDirectiveAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedExternAliasDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExternAliasDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedExternAliasDirectiveCore(XElement, XElement)"/> is not executed and <see cref="DeletedExternAliasDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedExternAliasDirectiveBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedExternAliasDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExternAliasDirectiveCore(XElement, XElement)"/>.</param>
        partial void DeletedExternAliasDirectiveAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedExternAliasDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedExternAliasDirectiveCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ExternKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "AliasKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedExternAliasDirective(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedExternAliasDirectiveBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedExternAliasDirectiveCore(property, parent);
    		DeletedExternAliasDirectiveAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedExternAliasDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExternAliasDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedExternAliasDirectiveCore(XElement, XElement)"/> is not executed and <see cref="UpdatedExternAliasDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedExternAliasDirectiveBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedExternAliasDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExternAliasDirectiveCore(XElement, XElement)"/>.</param>
        partial void UpdatedExternAliasDirectiveAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedExternAliasDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedExternAliasDirectiveCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ExternKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "AliasKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedExternAliasDirective(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedExternAliasDirectiveBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedExternAliasDirectiveCore(oldElement, newElement);
    		UpdatedExternAliasDirectiveAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedExternAliasDirective(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExternAliasDirective(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedExternAliasDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedExternAliasDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedExternAliasDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedExternAliasDirective(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedExternAliasDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ExternKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "AliasKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedExternAliasDirective(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedExternAliasDirectiveBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedExternAliasDirectiveCore(property, oldParent, position, newParent);
    		MovedExternAliasDirectiveAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExternAliasDirective(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExternAliasDirective(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedExternAliasDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExternAliasDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedExternAliasDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExternAliasDirective(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExternAliasDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ExternKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "AliasKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedExternAliasDirective(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedExternAliasDirectiveBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedExternAliasDirectiveCore(property, oldParent, position, newParent);
    		MatchedExternAliasDirectiveAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region UsingDirective
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedUsingDirective(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUsingDirective(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedUsingDirectiveCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedUsingDirective(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedUsingDirectiveBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedUsingDirectiveCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUsingDirectiveCore(XElement, int, XElement)"/>.</param>
        partial void InsertedUsingDirectiveAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedUsingDirective(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedUsingDirectiveCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StaticKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedUsingDirective(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedUsingDirectiveBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedUsingDirectiveCore(property, position, parent);
    		InsertedUsingDirectiveAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedUsingDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUsingDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedUsingDirectiveCore(XElement, XElement)"/> is not executed and <see cref="DeletedUsingDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedUsingDirectiveBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedUsingDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUsingDirectiveCore(XElement, XElement)"/>.</param>
        partial void DeletedUsingDirectiveAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedUsingDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedUsingDirectiveCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StaticKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedUsingDirective(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedUsingDirectiveBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedUsingDirectiveCore(property, parent);
    		DeletedUsingDirectiveAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedUsingDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUsingDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedUsingDirectiveCore(XElement, XElement)"/> is not executed and <see cref="UpdatedUsingDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedUsingDirectiveBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedUsingDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUsingDirectiveCore(XElement, XElement)"/>.</param>
        partial void UpdatedUsingDirectiveAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedUsingDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedUsingDirectiveCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "StaticKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedUsingDirective(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedUsingDirectiveBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedUsingDirectiveCore(oldElement, newElement);
    		UpdatedUsingDirectiveAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedUsingDirective(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUsingDirective(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedUsingDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedUsingDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedUsingDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedUsingDirectiveCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUsingDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedUsingDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedUsingDirective(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedUsingDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StaticKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedUsingDirective(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedUsingDirectiveBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedUsingDirectiveCore(property, oldParent, position, newParent);
    		MovedUsingDirectiveAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUsingDirective(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingDirective(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUsingDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedUsingDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUsingDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUsingDirectiveCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedUsingDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUsingDirective(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUsingDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StaticKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedUsingDirective(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedUsingDirectiveBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedUsingDirectiveCore(property, oldParent, position, newParent);
    		MatchedUsingDirectiveAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AttributeList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAttributeList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAttributeListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAttributeList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAttributeListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAttributeListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAttributeListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAttributeList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAttributeListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAttributeList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAttributeListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAttributeListCore(property, position, parent);
    		InsertedAttributeListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAttributeList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAttributeListCore(XElement, XElement)"/> is not executed and <see cref="DeletedAttributeList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAttributeListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAttributeListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeListCore(XElement, XElement)"/>.</param>
        partial void DeletedAttributeListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAttributeList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAttributeListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAttributeList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAttributeListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAttributeListCore(property, parent);
    		DeletedAttributeListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAttributeList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAttributeListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAttributeList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAttributeListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAttributeListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeListCore(XElement, XElement)"/>.</param>
        partial void UpdatedAttributeListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAttributeList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAttributeListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAttributeList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAttributeListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAttributeListCore(oldElement, newElement);
    		UpdatedAttributeListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAttributeList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAttributeListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAttributeList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAttributeListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAttributeListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAttributeListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAttributeList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAttributeListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAttributeList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAttributeListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAttributeListCore(property, oldParent, position, newParent);
    		MovedAttributeListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAttributeList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAttributeListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAttributeListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAttributeListCore(property, oldParent, position, newParent);
    		MatchedAttributeListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AttributeTargetSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAttributeTargetSpecifier(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeTargetSpecifier(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAttributeTargetSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAttributeTargetSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAttributeTargetSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAttributeTargetSpecifierCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeTargetSpecifierCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAttributeTargetSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAttributeTargetSpecifier(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAttributeTargetSpecifierCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAttributeTargetSpecifier(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAttributeTargetSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAttributeTargetSpecifierCore(property, position, parent);
    		InsertedAttributeTargetSpecifierAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAttributeTargetSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeTargetSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAttributeTargetSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedAttributeTargetSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAttributeTargetSpecifierBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAttributeTargetSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeTargetSpecifierCore(XElement, XElement)"/>.</param>
        partial void DeletedAttributeTargetSpecifierAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAttributeTargetSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAttributeTargetSpecifierCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAttributeTargetSpecifier(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAttributeTargetSpecifierBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAttributeTargetSpecifierCore(property, parent);
    		DeletedAttributeTargetSpecifierAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAttributeTargetSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeTargetSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAttributeTargetSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAttributeTargetSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAttributeTargetSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAttributeTargetSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeTargetSpecifierCore(XElement, XElement)"/>.</param>
        partial void UpdatedAttributeTargetSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAttributeTargetSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAttributeTargetSpecifierCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAttributeTargetSpecifier(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAttributeTargetSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAttributeTargetSpecifierCore(oldElement, newElement);
    		UpdatedAttributeTargetSpecifierAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAttributeTargetSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAttributeTargetSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAttributeTargetSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAttributeTargetSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAttributeTargetSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAttributeTargetSpecifierCore(property, oldParent, position, newParent);
    		MovedAttributeTargetSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeTargetSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAttributeTargetSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeTargetSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeTargetSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAttributeTargetSpecifierBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAttributeTargetSpecifierCore(property, oldParent, position, newParent);
    		MatchedAttributeTargetSpecifierAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Attribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAttribute(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttribute(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAttributeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAttribute(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAttributeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAttribute(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAttributeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAttributeCore(property, position, parent);
    		InsertedAttributeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAttributeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeCore(XElement, XElement)"/>.</param>
        partial void DeletedAttributeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAttributeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAttribute(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAttributeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAttributeCore(property, parent);
    		DeletedAttributeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeCore(XElement, XElement)"/>.</param>
        partial void UpdatedAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAttributeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAttribute(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAttributeCore(oldElement, newElement);
    		UpdatedAttributeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAttributeCore(property, oldParent, position, newParent);
    		MovedAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAttributeCore(property, oldParent, position, newParent);
    		MatchedAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AttributeArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAttributeArgumentList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeArgumentList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAttributeArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAttributeArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAttributeArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAttributeArgumentListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAttributeArgumentListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAttributeArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAttributeArgumentList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAttributeArgumentListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAttributeArgumentList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAttributeArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAttributeArgumentListCore(property, position, parent);
    		InsertedAttributeArgumentListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAttributeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAttributeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedAttributeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAttributeArgumentListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAttributeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAttributeArgumentListCore(XElement, XElement)"/>.</param>
        partial void DeletedAttributeArgumentListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAttributeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAttributeArgumentListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAttributeArgumentList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAttributeArgumentListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAttributeArgumentListCore(property, parent);
    		DeletedAttributeArgumentListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAttributeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAttributeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAttributeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAttributeArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAttributeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAttributeArgumentListCore(XElement, XElement)"/>.</param>
        partial void UpdatedAttributeArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAttributeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAttributeArgumentListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAttributeArgumentList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAttributeArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAttributeArgumentListCore(oldElement, newElement);
    		UpdatedAttributeArgumentListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAttributeArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAttributeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAttributeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAttributeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAttributeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAttributeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAttributeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAttributeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAttributeArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAttributeArgumentListCore(property, oldParent, position, newParent);
    		MovedAttributeArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAttributeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAttributeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAttributeArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAttributeArgumentListCore(property, oldParent, position, newParent);
    		MatchedAttributeArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DelegateDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDelegateDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDelegateDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDelegateDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDelegateDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDelegateDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDelegateDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDelegateDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDelegateDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDelegateDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDelegateDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDelegateDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDelegateDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDelegateDeclarationCore(property, position, parent);
    		InsertedDelegateDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDelegateDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDelegateDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDelegateDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedDelegateDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDelegateDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDelegateDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDelegateDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedDelegateDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDelegateDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDelegateDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDelegateDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDelegateDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDelegateDeclarationCore(property, parent);
    		DeletedDelegateDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDelegateDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDelegateDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDelegateDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDelegateDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDelegateDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDelegateDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDelegateDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedDelegateDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDelegateDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDelegateDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDelegateDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDelegateDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDelegateDeclarationCore(oldElement, newElement);
    		UpdatedDelegateDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDelegateDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDelegateDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDelegateDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDelegateDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDelegateDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDelegateDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDelegateDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDelegateDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDelegateDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDelegateDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDelegateDeclarationCore(property, oldParent, position, newParent);
    		MovedDelegateDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDelegateDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDelegateDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDelegateDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDelegateDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDelegateDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDelegateDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDelegateDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDelegateDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDelegateDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDelegateDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDelegateDeclarationCore(property, oldParent, position, newParent);
    		MatchedDelegateDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EnumMemberDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEnumMemberDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEnumMemberDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEnumMemberDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEnumMemberDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEnumMemberDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEnumMemberDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEnumMemberDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEnumMemberDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEnumMemberDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEnumMemberDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEnumMemberDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEnumMemberDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEnumMemberDeclarationCore(property, position, parent);
    		InsertedEnumMemberDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEnumMemberDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEnumMemberDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEnumMemberDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedEnumMemberDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEnumMemberDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEnumMemberDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEnumMemberDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedEnumMemberDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEnumMemberDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEnumMemberDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEnumMemberDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEnumMemberDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEnumMemberDeclarationCore(property, parent);
    		DeletedEnumMemberDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEnumMemberDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEnumMemberDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEnumMemberDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEnumMemberDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEnumMemberDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEnumMemberDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEnumMemberDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedEnumMemberDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEnumMemberDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEnumMemberDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEnumMemberDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEnumMemberDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEnumMemberDeclarationCore(oldElement, newElement);
    		UpdatedEnumMemberDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEnumMemberDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEnumMemberDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEnumMemberDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEnumMemberDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEnumMemberDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEnumMemberDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEnumMemberDeclarationCore(property, oldParent, position, newParent);
    		MovedEnumMemberDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEnumMemberDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEnumMemberDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEnumMemberDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEnumMemberDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEnumMemberDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEnumMemberDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEnumMemberDeclarationCore(property, oldParent, position, newParent);
    		MatchedEnumMemberDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IncompleteMember
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIncompleteMember(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIncompleteMember(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIncompleteMemberCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIncompleteMember(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIncompleteMemberBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIncompleteMemberCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIncompleteMemberCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIncompleteMemberAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIncompleteMember(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIncompleteMemberCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIncompleteMember(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIncompleteMemberBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIncompleteMemberCore(property, position, parent);
    		InsertedIncompleteMemberAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIncompleteMember(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIncompleteMember(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIncompleteMemberCore(XElement, XElement)"/> is not executed and <see cref="DeletedIncompleteMember(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIncompleteMemberBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIncompleteMemberCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIncompleteMemberCore(XElement, XElement)"/>.</param>
        partial void DeletedIncompleteMemberAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIncompleteMember(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIncompleteMemberCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIncompleteMember(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIncompleteMemberBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIncompleteMemberCore(property, parent);
    		DeletedIncompleteMemberAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIncompleteMember(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIncompleteMember(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIncompleteMemberCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIncompleteMember(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIncompleteMemberBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIncompleteMemberCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIncompleteMemberCore(XElement, XElement)"/>.</param>
        partial void UpdatedIncompleteMemberAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIncompleteMember(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIncompleteMemberCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIncompleteMember(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIncompleteMemberBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIncompleteMemberCore(oldElement, newElement);
    		UpdatedIncompleteMemberAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIncompleteMember(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIncompleteMember(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIncompleteMemberCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIncompleteMember(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIncompleteMemberBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIncompleteMemberCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIncompleteMemberCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIncompleteMemberAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIncompleteMember(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIncompleteMemberCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIncompleteMember(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIncompleteMemberBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIncompleteMemberCore(property, oldParent, position, newParent);
    		MovedIncompleteMemberAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIncompleteMember(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIncompleteMember(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIncompleteMemberCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIncompleteMember(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIncompleteMemberBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIncompleteMemberCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIncompleteMemberCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIncompleteMemberAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIncompleteMember(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIncompleteMemberCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIncompleteMember(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIncompleteMemberBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIncompleteMemberCore(property, oldParent, position, newParent);
    		MatchedIncompleteMemberAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region GlobalStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedGlobalStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGlobalStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedGlobalStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedGlobalStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedGlobalStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedGlobalStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGlobalStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedGlobalStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedGlobalStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedGlobalStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedGlobalStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedGlobalStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedGlobalStatementCore(property, position, parent);
    		InsertedGlobalStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedGlobalStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGlobalStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedGlobalStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedGlobalStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedGlobalStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedGlobalStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGlobalStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedGlobalStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedGlobalStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedGlobalStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedGlobalStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedGlobalStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedGlobalStatementCore(property, parent);
    		DeletedGlobalStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedGlobalStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGlobalStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedGlobalStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedGlobalStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedGlobalStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedGlobalStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGlobalStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedGlobalStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedGlobalStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedGlobalStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedGlobalStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedGlobalStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedGlobalStatementCore(oldElement, newElement);
    		UpdatedGlobalStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedGlobalStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGlobalStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedGlobalStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedGlobalStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedGlobalStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedGlobalStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGlobalStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedGlobalStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedGlobalStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedGlobalStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedGlobalStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedGlobalStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedGlobalStatementCore(property, oldParent, position, newParent);
    		MovedGlobalStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGlobalStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGlobalStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGlobalStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedGlobalStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGlobalStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGlobalStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGlobalStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedGlobalStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGlobalStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGlobalStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedGlobalStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedGlobalStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedGlobalStatementCore(property, oldParent, position, newParent);
    		MatchedGlobalStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region NamespaceDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedNamespaceDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNamespaceDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedNamespaceDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedNamespaceDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedNamespaceDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedNamespaceDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNamespaceDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedNamespaceDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedNamespaceDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedNamespaceDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedNamespaceDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedNamespaceDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedNamespaceDeclarationCore(property, position, parent);
    		InsertedNamespaceDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedNamespaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNamespaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedNamespaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedNamespaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedNamespaceDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedNamespaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNamespaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedNamespaceDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedNamespaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedNamespaceDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedNamespaceDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedNamespaceDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedNamespaceDeclarationCore(property, parent);
    		DeletedNamespaceDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedNamespaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNamespaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedNamespaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedNamespaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedNamespaceDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedNamespaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNamespaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedNamespaceDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedNamespaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedNamespaceDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NamespaceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedNamespaceDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedNamespaceDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedNamespaceDeclarationCore(oldElement, newElement);
    		UpdatedNamespaceDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedNamespaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedNamespaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedNamespaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedNamespaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedNamespaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedNamespaceDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedNamespaceDeclarationCore(property, oldParent, position, newParent);
    		MovedNamespaceDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedNamespaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNamespaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedNamespaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNamespaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedNamespaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedNamespaceDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedNamespaceDeclarationCore(property, oldParent, position, newParent);
    		MatchedNamespaceDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EnumDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEnumDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEnumDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEnumDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEnumDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEnumDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEnumDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEnumDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEnumDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEnumDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEnumDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EnumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEnumDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEnumDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEnumDeclarationCore(property, position, parent);
    		InsertedEnumDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEnumDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEnumDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEnumDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedEnumDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEnumDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEnumDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEnumDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedEnumDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEnumDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEnumDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EnumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEnumDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEnumDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEnumDeclarationCore(property, parent);
    		DeletedEnumDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEnumDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEnumDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEnumDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEnumDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEnumDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEnumDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEnumDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedEnumDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEnumDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEnumDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EnumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEnumDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEnumDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEnumDeclarationCore(oldElement, newElement);
    		UpdatedEnumDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEnumDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEnumDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEnumDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEnumDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEnumDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEnumDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEnumDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEnumDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEnumDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEnumDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EnumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEnumDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEnumDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEnumDeclarationCore(property, oldParent, position, newParent);
    		MovedEnumDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEnumDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEnumDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEnumDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEnumDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEnumDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEnumDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEnumDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEnumDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EnumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEnumDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEnumDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEnumDeclarationCore(property, oldParent, position, newParent);
    		MatchedEnumDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ClassDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedClassDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedClassDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedClassDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedClassDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedClassDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedClassDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedClassDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedClassDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedClassDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedClassDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedClassDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedClassDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedClassDeclarationCore(property, position, parent);
    		InsertedClassDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedClassDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedClassDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedClassDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedClassDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedClassDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedClassDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedClassDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedClassDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedClassDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedClassDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedClassDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedClassDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedClassDeclarationCore(property, parent);
    		DeletedClassDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedClassDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedClassDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedClassDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedClassDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedClassDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedClassDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedClassDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedClassDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedClassDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedClassDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedClassDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedClassDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedClassDeclarationCore(oldElement, newElement);
    		UpdatedClassDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedClassDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedClassDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedClassDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedClassDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedClassDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedClassDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedClassDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedClassDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedClassDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedClassDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedClassDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedClassDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedClassDeclarationCore(property, oldParent, position, newParent);
    		MovedClassDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedClassDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedClassDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedClassDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedClassDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedClassDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedClassDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedClassDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedClassDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedClassDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedClassDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedClassDeclarationCore(property, oldParent, position, newParent);
    		MatchedClassDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region StructDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedStructDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedStructDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedStructDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedStructDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedStructDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedStructDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedStructDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedStructDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedStructDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedStructDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedStructDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedStructDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedStructDeclarationCore(property, position, parent);
    		InsertedStructDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedStructDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedStructDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedStructDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedStructDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedStructDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedStructDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedStructDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedStructDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedStructDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedStructDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedStructDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedStructDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedStructDeclarationCore(property, parent);
    		DeletedStructDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedStructDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedStructDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedStructDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedStructDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedStructDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedStructDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedStructDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedStructDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedStructDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedStructDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedStructDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedStructDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedStructDeclarationCore(oldElement, newElement);
    		UpdatedStructDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedStructDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedStructDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedStructDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedStructDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedStructDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedStructDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedStructDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedStructDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedStructDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedStructDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedStructDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedStructDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedStructDeclarationCore(property, oldParent, position, newParent);
    		MovedStructDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedStructDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStructDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedStructDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedStructDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedStructDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedStructDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStructDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedStructDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedStructDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedStructDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedStructDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedStructDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedStructDeclarationCore(property, oldParent, position, newParent);
    		MatchedStructDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InterfaceDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterfaceDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterfaceDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterfaceDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterfaceDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterfaceDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterfaceDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterfaceDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterfaceDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterfaceDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterfaceDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterfaceDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterfaceDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterfaceDeclarationCore(property, position, parent);
    		InsertedInterfaceDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterfaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterfaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterfaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterfaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterfaceDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterfaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterfaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedInterfaceDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterfaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterfaceDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterfaceDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterfaceDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterfaceDeclarationCore(property, parent);
    		DeletedInterfaceDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterfaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterfaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterfaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterfaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterfaceDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterfaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterfaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterfaceDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterfaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterfaceDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterfaceDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterfaceDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterfaceDeclarationCore(oldElement, newElement);
    		UpdatedInterfaceDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterfaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterfaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterfaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterfaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterfaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterfaceDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterfaceDeclarationCore(property, oldParent, position, newParent);
    		MovedInterfaceDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterfaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterfaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterfaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterfaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterfaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterfaceDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterfaceDeclarationCore(property, oldParent, position, newParent);
    		MatchedInterfaceDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region FieldDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedFieldDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFieldDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedFieldDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFieldDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedFieldDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedFieldDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFieldDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedFieldDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedFieldDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedFieldDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedFieldDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedFieldDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedFieldDeclarationCore(property, position, parent);
    		InsertedFieldDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedFieldDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedFieldDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedFieldDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedFieldDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedFieldDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedFieldDeclarationCore(property, parent);
    		DeletedFieldDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedFieldDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedFieldDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedFieldDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedFieldDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedFieldDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedFieldDeclarationCore(oldElement, newElement);
    		UpdatedFieldDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedFieldDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedFieldDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedFieldDeclarationCore(property, oldParent, position, newParent);
    		MovedFieldDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFieldDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedFieldDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedFieldDeclarationCore(property, oldParent, position, newParent);
    		MatchedFieldDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EventFieldDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEventFieldDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEventFieldDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEventFieldDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEventFieldDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEventFieldDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEventFieldDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEventFieldDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEventFieldDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEventFieldDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEventFieldDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEventFieldDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEventFieldDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEventFieldDeclarationCore(property, position, parent);
    		InsertedEventFieldDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEventFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEventFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEventFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedEventFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEventFieldDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEventFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEventFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedEventFieldDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEventFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEventFieldDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEventFieldDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEventFieldDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEventFieldDeclarationCore(property, parent);
    		DeletedEventFieldDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEventFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEventFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEventFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEventFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEventFieldDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEventFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEventFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedEventFieldDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEventFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEventFieldDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEventFieldDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEventFieldDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEventFieldDeclarationCore(oldElement, newElement);
    		UpdatedEventFieldDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEventFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEventFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEventFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEventFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEventFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEventFieldDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEventFieldDeclarationCore(property, oldParent, position, newParent);
    		MovedEventFieldDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEventFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEventFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEventFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEventFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEventFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEventFieldDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEventFieldDeclarationCore(property, oldParent, position, newParent);
    		MatchedEventFieldDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region MethodDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedMethodDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMethodDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedMethodDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedMethodDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedMethodDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedMethodDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMethodDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedMethodDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedMethodDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedMethodDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedMethodDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedMethodDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedMethodDeclarationCore(property, position, parent);
    		InsertedMethodDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedMethodDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMethodDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedMethodDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedMethodDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedMethodDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedMethodDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMethodDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedMethodDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedMethodDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedMethodDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedMethodDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedMethodDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedMethodDeclarationCore(property, parent);
    		DeletedMethodDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedMethodDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMethodDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedMethodDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedMethodDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedMethodDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedMethodDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMethodDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedMethodDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedMethodDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedMethodDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedMethodDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedMethodDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedMethodDeclarationCore(oldElement, newElement);
    		UpdatedMethodDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedMethodDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMethodDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedMethodDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedMethodDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedMethodDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedMethodDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMethodDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedMethodDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedMethodDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedMethodDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedMethodDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedMethodDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedMethodDeclarationCore(property, oldParent, position, newParent);
    		MovedMethodDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMethodDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMethodDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMethodDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedMethodDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMethodDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMethodDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMethodDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedMethodDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMethodDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMethodDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedMethodDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedMethodDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedMethodDeclarationCore(property, oldParent, position, newParent);
    		MatchedMethodDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region OperatorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOperatorDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOperatorDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOperatorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOperatorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOperatorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOperatorDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOperatorDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOperatorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOperatorDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOperatorDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOperatorDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOperatorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOperatorDeclarationCore(property, position, parent);
    		InsertedOperatorDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOperatorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedOperatorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOperatorDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOperatorDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOperatorDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOperatorDeclarationCore(property, parent);
    		DeletedOperatorDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOperatorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedOperatorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOperatorDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOperatorDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOperatorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOperatorDeclarationCore(oldElement, newElement);
    		UpdatedOperatorDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOperatorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOperatorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOperatorDeclarationCore(property, oldParent, position, newParent);
    		MovedOperatorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOperatorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOperatorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOperatorDeclarationCore(property, oldParent, position, newParent);
    		MatchedOperatorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConversionOperatorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConversionOperatorDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConversionOperatorDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConversionOperatorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConversionOperatorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConversionOperatorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConversionOperatorDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConversionOperatorDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConversionOperatorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConversionOperatorDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConversionOperatorDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConversionOperatorDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConversionOperatorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConversionOperatorDeclarationCore(property, position, parent);
    		InsertedConversionOperatorDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConversionOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConversionOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConversionOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedConversionOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConversionOperatorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConversionOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConversionOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedConversionOperatorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConversionOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConversionOperatorDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConversionOperatorDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConversionOperatorDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConversionOperatorDeclarationCore(property, parent);
    		DeletedConversionOperatorDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConversionOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConversionOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConversionOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConversionOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConversionOperatorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConversionOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConversionOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedConversionOperatorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConversionOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConversionOperatorDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConversionOperatorDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConversionOperatorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConversionOperatorDeclarationCore(oldElement, newElement);
    		UpdatedConversionOperatorDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConversionOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConversionOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConversionOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConversionOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConversionOperatorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConversionOperatorDeclarationCore(property, oldParent, position, newParent);
    		MovedConversionOperatorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConversionOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConversionOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConversionOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConversionOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConversionOperatorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConversionOperatorDeclarationCore(property, oldParent, position, newParent);
    		MatchedConversionOperatorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConstructorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConstructorDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConstructorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConstructorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConstructorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConstructorDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConstructorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConstructorDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConstructorDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConstructorDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConstructorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConstructorDeclarationCore(property, position, parent);
    		InsertedConstructorDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConstructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConstructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedConstructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConstructorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConstructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedConstructorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConstructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConstructorDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConstructorDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConstructorDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConstructorDeclarationCore(property, parent);
    		DeletedConstructorDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConstructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConstructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConstructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConstructorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConstructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedConstructorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConstructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConstructorDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConstructorDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConstructorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConstructorDeclarationCore(oldElement, newElement);
    		UpdatedConstructorDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConstructorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConstructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConstructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConstructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConstructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConstructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConstructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConstructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConstructorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConstructorDeclarationCore(property, oldParent, position, newParent);
    		MovedConstructorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConstructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConstructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConstructorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConstructorDeclarationCore(property, oldParent, position, newParent);
    		MatchedConstructorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DestructorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDestructorDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDestructorDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDestructorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDestructorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDestructorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDestructorDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDestructorDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDestructorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDestructorDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDestructorDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TildeToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDestructorDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDestructorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDestructorDeclarationCore(property, position, parent);
    		InsertedDestructorDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDestructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDestructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDestructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedDestructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDestructorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDestructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDestructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedDestructorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDestructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDestructorDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TildeToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDestructorDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDestructorDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDestructorDeclarationCore(property, parent);
    		DeletedDestructorDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDestructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDestructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDestructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDestructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDestructorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDestructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDestructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedDestructorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDestructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDestructorDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "TildeToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDestructorDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDestructorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDestructorDeclarationCore(oldElement, newElement);
    		UpdatedDestructorDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDestructorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDestructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDestructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDestructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDestructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDestructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDestructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDestructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TildeToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDestructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDestructorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDestructorDeclarationCore(property, oldParent, position, newParent);
    		MovedDestructorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDestructorDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDestructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDestructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDestructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDestructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDestructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDestructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDestructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TildeToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDestructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDestructorDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDestructorDeclarationCore(property, oldParent, position, newParent);
    		MatchedDestructorDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PropertyDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPropertyDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPropertyDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPropertyDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPropertyDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPropertyDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPropertyDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPropertyDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPropertyDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPropertyDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPropertyDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPropertyDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPropertyDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPropertyDeclarationCore(property, position, parent);
    		InsertedPropertyDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPropertyDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPropertyDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPropertyDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedPropertyDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPropertyDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPropertyDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPropertyDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedPropertyDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPropertyDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPropertyDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPropertyDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPropertyDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPropertyDeclarationCore(property, parent);
    		DeletedPropertyDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPropertyDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPropertyDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPropertyDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPropertyDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPropertyDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPropertyDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPropertyDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedPropertyDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPropertyDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPropertyDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPropertyDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPropertyDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPropertyDeclarationCore(oldElement, newElement);
    		UpdatedPropertyDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPropertyDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPropertyDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPropertyDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPropertyDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPropertyDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPropertyDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPropertyDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPropertyDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPropertyDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPropertyDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPropertyDeclarationCore(property, oldParent, position, newParent);
    		MovedPropertyDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPropertyDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPropertyDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPropertyDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPropertyDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPropertyDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPropertyDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPropertyDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPropertyDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPropertyDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPropertyDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPropertyDeclarationCore(property, oldParent, position, newParent);
    		MatchedPropertyDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EventDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEventDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEventDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEventDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEventDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEventDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEventDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEventDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEventDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEventDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEventDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEventDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEventDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEventDeclarationCore(property, position, parent);
    		InsertedEventDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEventDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEventDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEventDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedEventDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEventDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEventDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEventDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedEventDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEventDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEventDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEventDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEventDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEventDeclarationCore(property, parent);
    		DeletedEventDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEventDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEventDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEventDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEventDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEventDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEventDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEventDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedEventDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEventDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEventDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEventDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEventDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEventDeclarationCore(oldElement, newElement);
    		UpdatedEventDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEventDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEventDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEventDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEventDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEventDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEventDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEventDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEventDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEventDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEventDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEventDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEventDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEventDeclarationCore(property, oldParent, position, newParent);
    		MovedEventDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEventDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEventDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEventDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEventDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEventDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEventDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEventDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEventDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EventKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEventDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEventDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEventDeclarationCore(property, oldParent, position, newParent);
    		MatchedEventDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IndexerDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIndexerDeclaration(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIndexerDeclaration(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIndexerDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIndexerDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIndexerDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIndexerDeclarationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIndexerDeclarationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIndexerDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIndexerDeclaration(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIndexerDeclarationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIndexerDeclaration(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIndexerDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIndexerDeclarationCore(property, position, parent);
    		InsertedIndexerDeclarationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIndexerDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIndexerDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIndexerDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedIndexerDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIndexerDeclarationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIndexerDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIndexerDeclarationCore(XElement, XElement)"/>.</param>
        partial void DeletedIndexerDeclarationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIndexerDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIndexerDeclarationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIndexerDeclaration(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIndexerDeclarationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIndexerDeclarationCore(property, parent);
    		DeletedIndexerDeclarationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIndexerDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIndexerDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIndexerDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIndexerDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIndexerDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIndexerDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIndexerDeclarationCore(XElement, XElement)"/>.</param>
        partial void UpdatedIndexerDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIndexerDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIndexerDeclarationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIndexerDeclaration(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIndexerDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIndexerDeclarationCore(oldElement, newElement);
    		UpdatedIndexerDeclarationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIndexerDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIndexerDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIndexerDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIndexerDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIndexerDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIndexerDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIndexerDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIndexerDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIndexerDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIndexerDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIndexerDeclarationCore(property, oldParent, position, newParent);
    		MovedIndexerDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIndexerDeclaration(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerDeclaration(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIndexerDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIndexerDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIndexerDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIndexerDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIndexerDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIndexerDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIndexerDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIndexerDeclarationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIndexerDeclarationCore(property, oldParent, position, newParent);
    		MatchedIndexerDeclarationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SimpleBaseType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSimpleBaseType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSimpleBaseType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSimpleBaseTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSimpleBaseType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSimpleBaseTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSimpleBaseTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSimpleBaseTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSimpleBaseTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSimpleBaseType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSimpleBaseTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSimpleBaseType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSimpleBaseTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSimpleBaseTypeCore(property, position, parent);
    		InsertedSimpleBaseTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSimpleBaseType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSimpleBaseType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSimpleBaseTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedSimpleBaseType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSimpleBaseTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSimpleBaseTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSimpleBaseTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedSimpleBaseTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSimpleBaseType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSimpleBaseTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSimpleBaseType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSimpleBaseTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSimpleBaseTypeCore(property, parent);
    		DeletedSimpleBaseTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSimpleBaseType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSimpleBaseType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSimpleBaseTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSimpleBaseType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSimpleBaseTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSimpleBaseTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSimpleBaseTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedSimpleBaseTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSimpleBaseType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSimpleBaseTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSimpleBaseType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSimpleBaseTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSimpleBaseTypeCore(oldElement, newElement);
    		UpdatedSimpleBaseTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSimpleBaseType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSimpleBaseType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSimpleBaseType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSimpleBaseTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSimpleBaseTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSimpleBaseType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSimpleBaseTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSimpleBaseType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSimpleBaseTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSimpleBaseTypeCore(property, oldParent, position, newParent);
    		MovedSimpleBaseTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSimpleBaseType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleBaseType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSimpleBaseType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSimpleBaseTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSimpleBaseTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSimpleBaseType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSimpleBaseTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSimpleBaseType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSimpleBaseTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSimpleBaseTypeCore(property, oldParent, position, newParent);
    		MatchedSimpleBaseTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConstructorConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConstructorConstraint(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorConstraint(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConstructorConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConstructorConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConstructorConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConstructorConstraintCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstructorConstraintCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConstructorConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConstructorConstraint(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConstructorConstraintCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConstructorConstraint(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConstructorConstraintBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConstructorConstraintCore(property, position, parent);
    		InsertedConstructorConstraintAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConstructorConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConstructorConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedConstructorConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConstructorConstraintBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConstructorConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstructorConstraintCore(XElement, XElement)"/>.</param>
        partial void DeletedConstructorConstraintAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConstructorConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConstructorConstraintCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConstructorConstraint(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConstructorConstraintBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConstructorConstraintCore(property, parent);
    		DeletedConstructorConstraintAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConstructorConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConstructorConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConstructorConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConstructorConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConstructorConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstructorConstraintCore(XElement, XElement)"/>.</param>
        partial void UpdatedConstructorConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConstructorConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConstructorConstraintCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConstructorConstraint(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConstructorConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConstructorConstraintCore(oldElement, newElement);
    		UpdatedConstructorConstraintAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConstructorConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConstructorConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConstructorConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConstructorConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConstructorConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstructorConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConstructorConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConstructorConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConstructorConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConstructorConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConstructorConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConstructorConstraintCore(property, oldParent, position, newParent);
    		MovedConstructorConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConstructorConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConstructorConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConstructorConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConstructorConstraintCore(property, oldParent, position, newParent);
    		MatchedConstructorConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ClassOrStructConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedClassOrStructConstraint(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedClassOrStructConstraint(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedClassOrStructConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedClassOrStructConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedClassOrStructConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedClassOrStructConstraintCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedClassOrStructConstraintCore(XElement, int, XElement)"/>.</param>
        partial void InsertedClassOrStructConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedClassOrStructConstraint(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedClassOrStructConstraintCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedClassOrStructConstraint(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedClassOrStructConstraintBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedClassOrStructConstraintCore(property, position, parent);
    		InsertedClassOrStructConstraintAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedClassOrStructConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedClassOrStructConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedClassOrStructConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedClassOrStructConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedClassOrStructConstraintBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedClassOrStructConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedClassOrStructConstraintCore(XElement, XElement)"/>.</param>
        partial void DeletedClassOrStructConstraintAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedClassOrStructConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedClassOrStructConstraintCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedClassOrStructConstraint(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedClassOrStructConstraintBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedClassOrStructConstraintCore(property, parent);
    		DeletedClassOrStructConstraintAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedClassOrStructConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedClassOrStructConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedClassOrStructConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedClassOrStructConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedClassOrStructConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedClassOrStructConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedClassOrStructConstraintCore(XElement, XElement)"/>.</param>
        partial void UpdatedClassOrStructConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedClassOrStructConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedClassOrStructConstraintCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ClassOrStructKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedClassOrStructConstraint(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedClassOrStructConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedClassOrStructConstraintCore(oldElement, newElement);
    		UpdatedClassOrStructConstraintAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedClassOrStructConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedClassOrStructConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedClassOrStructConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedClassOrStructConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedClassOrStructConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedClassOrStructConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedClassOrStructConstraintCore(property, oldParent, position, newParent);
    		MovedClassOrStructConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedClassOrStructConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedClassOrStructConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedClassOrStructConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedClassOrStructConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedClassOrStructConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedClassOrStructConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedClassOrStructConstraintCore(property, oldParent, position, newParent);
    		MatchedClassOrStructConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeConstraint(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeConstraint(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeConstraintCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeConstraintCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeConstraint(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeConstraintCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeConstraint(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeConstraintBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeConstraintCore(property, position, parent);
    		InsertedTypeConstraintAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeConstraintBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeConstraintCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeConstraintAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeConstraintCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeConstraint(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeConstraintBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeConstraintCore(property, parent);
    		DeletedTypeConstraintAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeConstraintCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeConstraintCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeConstraint(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeConstraintCore(oldElement, newElement);
    		UpdatedTypeConstraintAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeConstraintCore(property, oldParent, position, newParent);
    		MovedTypeConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeConstraint(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeConstraint(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeConstraintCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeConstraintCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeConstraint(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeConstraint(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeConstraintBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeConstraintCore(property, oldParent, position, newParent);
    		MatchedTypeConstraintAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedParameterList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParameterList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedParameterListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParameterListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedParameterList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedParameterListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedParameterList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedParameterListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedParameterListCore(property, position, parent);
    		InsertedParameterListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedParameterListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParameterListCore(XElement, XElement)"/>.</param>
        partial void DeletedParameterListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedParameterListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedParameterList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedParameterListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedParameterListCore(property, parent);
    		DeletedParameterListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParameterListCore(XElement, XElement)"/>.</param>
        partial void UpdatedParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedParameterListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedParameterList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedParameterListCore(oldElement, newElement);
    		UpdatedParameterListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedParameterListCore(property, oldParent, position, newParent);
    		MovedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedParameterListCore(property, oldParent, position, newParent);
    		MatchedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BracketedParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBracketedParameterList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBracketedParameterList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBracketedParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBracketedParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBracketedParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBracketedParameterListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBracketedParameterListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBracketedParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBracketedParameterList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBracketedParameterListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBracketedParameterList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBracketedParameterListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBracketedParameterListCore(property, position, parent);
    		InsertedBracketedParameterListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBracketedParameterListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void DeletedBracketedParameterListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBracketedParameterListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBracketedParameterList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBracketedParameterListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBracketedParameterListCore(property, parent);
    		DeletedBracketedParameterListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBracketedParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void UpdatedBracketedParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBracketedParameterListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBracketedParameterList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBracketedParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBracketedParameterListCore(oldElement, newElement);
    		UpdatedBracketedParameterListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBracketedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBracketedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBracketedParameterListCore(property, oldParent, position, newParent);
    		MovedBracketedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBracketedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBracketedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBracketedParameterListCore(property, oldParent, position, newParent);
    		MatchedBracketedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SkippedTokensTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSkippedTokensTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSkippedTokensTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSkippedTokensTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSkippedTokensTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSkippedTokensTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSkippedTokensTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSkippedTokensTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSkippedTokensTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSkippedTokensTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSkippedTokensTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSkippedTokensTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSkippedTokensTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSkippedTokensTriviaCore(property, position, parent);
    		InsertedSkippedTokensTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSkippedTokensTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSkippedTokensTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSkippedTokensTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedSkippedTokensTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSkippedTokensTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSkippedTokensTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSkippedTokensTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedSkippedTokensTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSkippedTokensTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSkippedTokensTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSkippedTokensTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSkippedTokensTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSkippedTokensTriviaCore(property, parent);
    		DeletedSkippedTokensTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSkippedTokensTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSkippedTokensTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSkippedTokensTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSkippedTokensTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSkippedTokensTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSkippedTokensTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSkippedTokensTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedSkippedTokensTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSkippedTokensTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSkippedTokensTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSkippedTokensTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSkippedTokensTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSkippedTokensTriviaCore(oldElement, newElement);
    		UpdatedSkippedTokensTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSkippedTokensTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSkippedTokensTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSkippedTokensTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSkippedTokensTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSkippedTokensTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSkippedTokensTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSkippedTokensTriviaCore(property, oldParent, position, newParent);
    		MovedSkippedTokensTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSkippedTokensTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSkippedTokensTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSkippedTokensTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSkippedTokensTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSkippedTokensTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSkippedTokensTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSkippedTokensTriviaCore(property, oldParent, position, newParent);
    		MatchedSkippedTokensTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DocumentationCommentTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDocumentationCommentTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDocumentationCommentTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDocumentationCommentTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDocumentationCommentTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDocumentationCommentTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDocumentationCommentTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDocumentationCommentTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDocumentationCommentTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDocumentationCommentTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDocumentationCommentTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfComment")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDocumentationCommentTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDocumentationCommentTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDocumentationCommentTriviaCore(property, position, parent);
    		InsertedDocumentationCommentTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDocumentationCommentTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDocumentationCommentTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDocumentationCommentTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedDocumentationCommentTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDocumentationCommentTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDocumentationCommentTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDocumentationCommentTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedDocumentationCommentTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDocumentationCommentTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDocumentationCommentTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfComment")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDocumentationCommentTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDocumentationCommentTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDocumentationCommentTriviaCore(property, parent);
    		DeletedDocumentationCommentTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDocumentationCommentTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDocumentationCommentTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDocumentationCommentTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDocumentationCommentTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDocumentationCommentTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDocumentationCommentTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDocumentationCommentTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedDocumentationCommentTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDocumentationCommentTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDocumentationCommentTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EndOfComment")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDocumentationCommentTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDocumentationCommentTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDocumentationCommentTriviaCore(oldElement, newElement);
    		UpdatedDocumentationCommentTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDocumentationCommentTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDocumentationCommentTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDocumentationCommentTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfComment")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDocumentationCommentTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDocumentationCommentTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDocumentationCommentTriviaCore(property, oldParent, position, newParent);
    		MovedDocumentationCommentTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDocumentationCommentTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDocumentationCommentTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDocumentationCommentTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EndOfComment")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDocumentationCommentTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDocumentationCommentTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDocumentationCommentTriviaCore(property, oldParent, position, newParent);
    		MatchedDocumentationCommentTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EndIfDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEndIfDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEndIfDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEndIfDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEndIfDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEndIfDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEndIfDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEndIfDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEndIfDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEndIfDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEndIfDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndIfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEndIfDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEndIfDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEndIfDirectiveTriviaCore(property, position, parent);
    		InsertedEndIfDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEndIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEndIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEndIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedEndIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEndIfDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEndIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEndIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedEndIfDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEndIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEndIfDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndIfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEndIfDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEndIfDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEndIfDirectiveTriviaCore(property, parent);
    		DeletedEndIfDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEndIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEndIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEndIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEndIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEndIfDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEndIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEndIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedEndIfDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEndIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEndIfDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndIfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEndIfDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEndIfDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEndIfDirectiveTriviaCore(oldElement, newElement);
    		UpdatedEndIfDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEndIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEndIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEndIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndIfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEndIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEndIfDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEndIfDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedEndIfDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEndIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEndIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEndIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndIfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEndIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEndIfDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEndIfDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedEndIfDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region RegionDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedRegionDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRegionDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedRegionDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedRegionDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedRegionDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedRegionDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRegionDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedRegionDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedRegionDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedRegionDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "RegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedRegionDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedRegionDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedRegionDirectiveTriviaCore(property, position, parent);
    		InsertedRegionDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedRegionDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedRegionDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedRegionDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "RegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedRegionDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedRegionDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedRegionDirectiveTriviaCore(property, parent);
    		DeletedRegionDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedRegionDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedRegionDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedRegionDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "RegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedRegionDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedRegionDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedRegionDirectiveTriviaCore(oldElement, newElement);
    		UpdatedRegionDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "RegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedRegionDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedRegionDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedRegionDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "RegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedRegionDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedRegionDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedRegionDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EndRegionDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEndRegionDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEndRegionDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEndRegionDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEndRegionDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEndRegionDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEndRegionDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEndRegionDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEndRegionDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEndRegionDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEndRegionDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEndRegionDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEndRegionDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEndRegionDirectiveTriviaCore(property, position, parent);
    		InsertedEndRegionDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEndRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEndRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEndRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedEndRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEndRegionDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedEndRegionDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEndRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEndRegionDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEndRegionDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEndRegionDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEndRegionDirectiveTriviaCore(property, parent);
    		DeletedEndRegionDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEndRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEndRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEndRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEndRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEndRegionDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedEndRegionDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEndRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEndRegionDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndRegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEndRegionDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEndRegionDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEndRegionDirectiveTriviaCore(oldElement, newElement);
    		UpdatedEndRegionDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEndRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEndRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEndRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEndRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEndRegionDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEndRegionDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedEndRegionDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEndRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEndRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEndRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEndRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEndRegionDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEndRegionDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedEndRegionDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ErrorDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedErrorDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedErrorDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedErrorDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedErrorDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedErrorDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedErrorDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedErrorDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedErrorDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedErrorDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedErrorDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ErrorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedErrorDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedErrorDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedErrorDirectiveTriviaCore(property, position, parent);
    		InsertedErrorDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedErrorDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedErrorDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedErrorDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedErrorDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedErrorDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedErrorDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedErrorDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedErrorDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedErrorDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedErrorDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ErrorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedErrorDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedErrorDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedErrorDirectiveTriviaCore(property, parent);
    		DeletedErrorDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedErrorDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedErrorDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedErrorDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedErrorDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedErrorDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedErrorDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedErrorDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedErrorDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedErrorDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedErrorDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ErrorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedErrorDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedErrorDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedErrorDirectiveTriviaCore(oldElement, newElement);
    		UpdatedErrorDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedErrorDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedErrorDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedErrorDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ErrorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedErrorDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedErrorDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedErrorDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedErrorDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedErrorDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedErrorDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedErrorDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ErrorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedErrorDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedErrorDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedErrorDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedErrorDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region WarningDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedWarningDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWarningDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedWarningDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedWarningDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedWarningDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedWarningDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWarningDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedWarningDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedWarningDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedWarningDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedWarningDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedWarningDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedWarningDirectiveTriviaCore(property, position, parent);
    		InsertedWarningDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedWarningDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedWarningDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedWarningDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedWarningDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedWarningDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedWarningDirectiveTriviaCore(property, parent);
    		DeletedWarningDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedWarningDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedWarningDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedWarningDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedWarningDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedWarningDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedWarningDirectiveTriviaCore(oldElement, newElement);
    		UpdatedWarningDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedWarningDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedWarningDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedWarningDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedWarningDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedWarningDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedWarningDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BadDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBadDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBadDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBadDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBadDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBadDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBadDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBadDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBadDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBadDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBadDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBadDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBadDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBadDirectiveTriviaCore(property, position, parent);
    		InsertedBadDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedBadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBadDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedBadDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBadDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBadDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBadDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBadDirectiveTriviaCore(property, parent);
    		DeletedBadDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBadDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedBadDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBadDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBadDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBadDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBadDirectiveTriviaCore(oldElement, newElement);
    		UpdatedBadDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBadDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBadDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedBadDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBadDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBadDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedBadDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DefineDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDefineDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefineDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDefineDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDefineDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDefineDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDefineDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefineDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDefineDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDefineDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDefineDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DefineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDefineDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDefineDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDefineDirectiveTriviaCore(property, position, parent);
    		InsertedDefineDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDefineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDefineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedDefineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDefineDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDefineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedDefineDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDefineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDefineDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DefineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDefineDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDefineDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDefineDirectiveTriviaCore(property, parent);
    		DeletedDefineDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDefineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDefineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDefineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDefineDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDefineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedDefineDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDefineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDefineDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "DefineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDefineDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDefineDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDefineDirectiveTriviaCore(oldElement, newElement);
    		UpdatedDefineDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDefineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDefineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDefineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DefineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDefineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDefineDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDefineDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedDefineDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDefineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DefineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDefineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDefineDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDefineDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedDefineDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region UndefDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedUndefDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUndefDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedUndefDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedUndefDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedUndefDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedUndefDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUndefDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedUndefDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedUndefDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedUndefDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "UndefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedUndefDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedUndefDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedUndefDirectiveTriviaCore(property, position, parent);
    		InsertedUndefDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedUndefDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUndefDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedUndefDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedUndefDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedUndefDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedUndefDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUndefDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedUndefDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedUndefDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedUndefDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "UndefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedUndefDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedUndefDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedUndefDirectiveTriviaCore(property, parent);
    		DeletedUndefDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedUndefDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUndefDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedUndefDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedUndefDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedUndefDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedUndefDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUndefDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedUndefDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedUndefDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedUndefDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "UndefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedUndefDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedUndefDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedUndefDirectiveTriviaCore(oldElement, newElement);
    		UpdatedUndefDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedUndefDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedUndefDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedUndefDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "UndefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedUndefDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedUndefDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedUndefDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedUndefDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUndefDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedUndefDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUndefDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "UndefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedUndefDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedUndefDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedUndefDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedUndefDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LineDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLineDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLineDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLineDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLineDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLineDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLineDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLineDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLineDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLineDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLineDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLineDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLineDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLineDirectiveTriviaCore(property, position, parent);
    		InsertedLineDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedLineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLineDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedLineDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLineDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLineDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLineDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLineDirectiveTriviaCore(property, parent);
    		DeletedLineDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLineDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedLineDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLineDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "LineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLineDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLineDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLineDirectiveTriviaCore(oldElement, newElement);
    		UpdatedLineDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLineDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLineDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedLineDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LineKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLineDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLineDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedLineDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PragmaWarningDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPragmaWarningDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPragmaWarningDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPragmaWarningDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPragmaWarningDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPragmaWarningDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPragmaWarningDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPragmaWarningDirectiveTriviaCore(property, position, parent);
    		InsertedPragmaWarningDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedPragmaWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPragmaWarningDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedPragmaWarningDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPragmaWarningDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPragmaWarningDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPragmaWarningDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPragmaWarningDirectiveTriviaCore(property, parent);
    		DeletedPragmaWarningDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPragmaWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPragmaWarningDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedPragmaWarningDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPragmaWarningDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPragmaWarningDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPragmaWarningDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPragmaWarningDirectiveTriviaCore(oldElement, newElement);
    		UpdatedPragmaWarningDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPragmaWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPragmaWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPragmaWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPragmaWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPragmaWarningDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPragmaWarningDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedPragmaWarningDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPragmaWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPragmaWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPragmaWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WarningKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPragmaWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPragmaWarningDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPragmaWarningDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedPragmaWarningDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PragmaChecksumDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPragmaChecksumDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPragmaChecksumDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPragmaChecksumDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPragmaChecksumDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPragmaChecksumDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPragmaChecksumDirectiveTriviaCore(property, position, parent);
    		InsertedPragmaChecksumDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedPragmaChecksumDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPragmaChecksumDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedPragmaChecksumDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPragmaChecksumDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPragmaChecksumDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPragmaChecksumDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPragmaChecksumDirectiveTriviaCore(property, parent);
    		DeletedPragmaChecksumDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPragmaChecksumDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPragmaChecksumDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedPragmaChecksumDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPragmaChecksumDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ChecksumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPragmaChecksumDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPragmaChecksumDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPragmaChecksumDirectiveTriviaCore(oldElement, newElement);
    		UpdatedPragmaChecksumDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPragmaChecksumDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPragmaChecksumDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPragmaChecksumDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPragmaChecksumDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPragmaChecksumDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPragmaChecksumDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedPragmaChecksumDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPragmaChecksumDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPragmaChecksumDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPragmaChecksumDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "PragmaKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPragmaChecksumDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPragmaChecksumDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPragmaChecksumDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedPragmaChecksumDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ReferenceDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedReferenceDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedReferenceDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedReferenceDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedReferenceDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedReferenceDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedReferenceDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedReferenceDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedReferenceDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedReferenceDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedReferenceDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedReferenceDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedReferenceDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedReferenceDirectiveTriviaCore(property, position, parent);
    		InsertedReferenceDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedReferenceDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedReferenceDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedReferenceDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedReferenceDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedReferenceDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedReferenceDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedReferenceDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedReferenceDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedReferenceDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedReferenceDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedReferenceDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedReferenceDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedReferenceDirectiveTriviaCore(property, parent);
    		DeletedReferenceDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedReferenceDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedReferenceDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedReferenceDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedReferenceDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedReferenceDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedReferenceDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedReferenceDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedReferenceDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedReferenceDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedReferenceDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ReferenceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedReferenceDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedReferenceDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedReferenceDirectiveTriviaCore(oldElement, newElement);
    		UpdatedReferenceDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedReferenceDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedReferenceDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedReferenceDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedReferenceDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedReferenceDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedReferenceDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedReferenceDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedReferenceDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedReferenceDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedReferenceDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedReferenceDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedReferenceDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedReferenceDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedReferenceDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LoadDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLoadDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLoadDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLoadDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLoadDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLoadDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLoadDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLoadDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLoadDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLoadDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLoadDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LoadKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLoadDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLoadDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLoadDirectiveTriviaCore(property, position, parent);
    		InsertedLoadDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLoadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLoadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLoadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedLoadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLoadDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLoadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLoadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedLoadDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLoadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLoadDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LoadKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLoadDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLoadDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLoadDirectiveTriviaCore(property, parent);
    		DeletedLoadDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLoadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLoadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLoadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLoadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLoadDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLoadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLoadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedLoadDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLoadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLoadDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "LoadKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLoadDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLoadDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLoadDirectiveTriviaCore(oldElement, newElement);
    		UpdatedLoadDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLoadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLoadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLoadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LoadKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLoadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLoadDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLoadDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedLoadDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLoadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLoadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLoadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "LoadKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLoadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLoadDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLoadDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedLoadDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ShebangDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedShebangDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedShebangDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedShebangDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedShebangDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedShebangDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedShebangDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedShebangDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedShebangDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedShebangDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedShebangDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ExclamationToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedShebangDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedShebangDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedShebangDirectiveTriviaCore(property, position, parent);
    		InsertedShebangDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedShebangDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedShebangDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedShebangDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedShebangDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedShebangDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedShebangDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedShebangDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedShebangDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedShebangDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedShebangDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ExclamationToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedShebangDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedShebangDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedShebangDirectiveTriviaCore(property, parent);
    		DeletedShebangDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedShebangDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedShebangDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedShebangDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedShebangDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedShebangDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedShebangDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedShebangDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedShebangDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedShebangDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedShebangDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ExclamationToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedShebangDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedShebangDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedShebangDirectiveTriviaCore(oldElement, newElement);
    		UpdatedShebangDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedShebangDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedShebangDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedShebangDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ExclamationToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedShebangDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedShebangDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedShebangDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedShebangDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedShebangDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedShebangDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedShebangDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ExclamationToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedShebangDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedShebangDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedShebangDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedShebangDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ElseDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedElseDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElseDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedElseDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedElseDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedElseDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedElseDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElseDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedElseDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedElseDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedElseDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedElseDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedElseDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedElseDirectiveTriviaCore(property, position, parent);
    		InsertedElseDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedElseDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElseDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedElseDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedElseDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedElseDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedElseDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElseDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedElseDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedElseDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedElseDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedElseDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedElseDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedElseDirectiveTriviaCore(property, parent);
    		DeletedElseDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedElseDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElseDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedElseDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedElseDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedElseDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedElseDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElseDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedElseDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedElseDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedElseDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedElseDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedElseDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedElseDirectiveTriviaCore(oldElement, newElement);
    		UpdatedElseDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedElseDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedElseDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedElseDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedElseDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedElseDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedElseDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedElseDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedElseDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedElseDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElseDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedElseDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElseDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElseKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedElseDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedElseDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedElseDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedElseDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IfDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIfDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIfDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIfDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIfDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIfDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIfDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIfDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIfDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIfDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIfDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIfDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIfDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIfDirectiveTriviaCore(property, position, parent);
    		InsertedIfDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIfDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedIfDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIfDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIfDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIfDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIfDirectiveTriviaCore(property, parent);
    		DeletedIfDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIfDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedIfDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIfDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIfDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIfDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIfDirectiveTriviaCore(oldElement, newElement);
    		UpdatedIfDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIfDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIfDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedIfDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIfDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIfDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedIfDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ElifDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedElifDirectiveTrivia(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElifDirectiveTrivia(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedElifDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedElifDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedElifDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedElifDirectiveTriviaCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElifDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
        partial void InsertedElifDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedElifDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedElifDirectiveTriviaCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElifKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedElifDirectiveTrivia(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedElifDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedElifDirectiveTriviaCore(property, position, parent);
    		InsertedElifDirectiveTriviaAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedElifDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElifDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedElifDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedElifDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedElifDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedElifDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElifDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void DeletedElifDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedElifDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedElifDirectiveTriviaCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElifKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedElifDirectiveTrivia(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedElifDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedElifDirectiveTriviaCore(property, parent);
    		DeletedElifDirectiveTriviaAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedElifDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElifDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedElifDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedElifDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedElifDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedElifDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElifDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void UpdatedElifDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedElifDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedElifDirectiveTriviaCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ElifKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedElifDirectiveTrivia(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedElifDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedElifDirectiveTriviaCore(oldElement, newElement);
    		UpdatedElifDirectiveTriviaAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedElifDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedElifDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedElifDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedElifDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElifKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedElifDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedElifDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedElifDirectiveTriviaCore(property, oldParent, position, newParent);
    		MovedElifDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedElifDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElifDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedElifDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElifDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "HashToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ElifKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedElifDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedElifDirectiveTriviaBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedElifDirectiveTriviaCore(property, oldParent, position, newParent);
    		MatchedElifDirectiveTriviaAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeCrefCore(property, position, parent);
    		InsertedTypeCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeCrefCore(property, parent);
    		DeletedTypeCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeCrefCore(oldElement, newElement);
    		UpdatedTypeCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeCrefCore(property, oldParent, position, newParent);
    		MovedTypeCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeCrefCore(property, oldParent, position, newParent);
    		MatchedTypeCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region QualifiedCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedQualifiedCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQualifiedCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedQualifiedCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedQualifiedCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedQualifiedCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedQualifiedCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQualifiedCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedQualifiedCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedQualifiedCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedQualifiedCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedQualifiedCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedQualifiedCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedQualifiedCrefCore(property, position, parent);
    		InsertedQualifiedCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedQualifiedCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQualifiedCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedQualifiedCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedQualifiedCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedQualifiedCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedQualifiedCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQualifiedCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedQualifiedCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedQualifiedCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedQualifiedCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedQualifiedCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedQualifiedCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedQualifiedCrefCore(property, parent);
    		DeletedQualifiedCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedQualifiedCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQualifiedCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedQualifiedCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedQualifiedCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedQualifiedCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedQualifiedCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQualifiedCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedQualifiedCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedQualifiedCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedQualifiedCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedQualifiedCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedQualifiedCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedQualifiedCrefCore(oldElement, newElement);
    		UpdatedQualifiedCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedQualifiedCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQualifiedCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedQualifiedCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedQualifiedCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedQualifiedCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedQualifiedCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQualifiedCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedQualifiedCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedQualifiedCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedQualifiedCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedQualifiedCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedQualifiedCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedQualifiedCrefCore(property, oldParent, position, newParent);
    		MovedQualifiedCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQualifiedCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQualifiedCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedQualifiedCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQualifiedCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQualifiedCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedQualifiedCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQualifiedCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQualifiedCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedQualifiedCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedQualifiedCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedQualifiedCrefCore(property, oldParent, position, newParent);
    		MatchedQualifiedCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region NameMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedNameMemberCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameMemberCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedNameMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedNameMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedNameMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedNameMemberCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNameMemberCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedNameMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedNameMemberCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedNameMemberCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedNameMemberCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedNameMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedNameMemberCrefCore(property, position, parent);
    		InsertedNameMemberCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedNameMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedNameMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedNameMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedNameMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedNameMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNameMemberCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedNameMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedNameMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedNameMemberCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedNameMemberCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedNameMemberCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedNameMemberCrefCore(property, parent);
    		DeletedNameMemberCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedNameMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedNameMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedNameMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedNameMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedNameMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNameMemberCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedNameMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedNameMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedNameMemberCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedNameMemberCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedNameMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedNameMemberCrefCore(oldElement, newElement);
    		UpdatedNameMemberCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedNameMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedNameMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedNameMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedNameMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedNameMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNameMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedNameMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedNameMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedNameMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedNameMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedNameMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedNameMemberCrefCore(property, oldParent, position, newParent);
    		MovedNameMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedNameMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedNameMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedNameMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedNameMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedNameMemberCrefCore(property, oldParent, position, newParent);
    		MatchedNameMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IndexerMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIndexerMemberCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIndexerMemberCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIndexerMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIndexerMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIndexerMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIndexerMemberCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIndexerMemberCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIndexerMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIndexerMemberCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIndexerMemberCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIndexerMemberCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIndexerMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIndexerMemberCrefCore(property, position, parent);
    		InsertedIndexerMemberCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIndexerMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIndexerMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIndexerMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedIndexerMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIndexerMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIndexerMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIndexerMemberCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedIndexerMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIndexerMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIndexerMemberCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIndexerMemberCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIndexerMemberCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIndexerMemberCrefCore(property, parent);
    		DeletedIndexerMemberCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIndexerMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIndexerMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIndexerMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIndexerMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIndexerMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIndexerMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIndexerMemberCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedIndexerMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIndexerMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIndexerMemberCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIndexerMemberCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIndexerMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIndexerMemberCrefCore(oldElement, newElement);
    		UpdatedIndexerMemberCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIndexerMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIndexerMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIndexerMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIndexerMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIndexerMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIndexerMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIndexerMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIndexerMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIndexerMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIndexerMemberCrefCore(property, oldParent, position, newParent);
    		MovedIndexerMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIndexerMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIndexerMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIndexerMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIndexerMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIndexerMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIndexerMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThisKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIndexerMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIndexerMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIndexerMemberCrefCore(property, oldParent, position, newParent);
    		MatchedIndexerMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region OperatorMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOperatorMemberCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOperatorMemberCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOperatorMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOperatorMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOperatorMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOperatorMemberCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOperatorMemberCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOperatorMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOperatorMemberCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOperatorMemberCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOperatorMemberCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOperatorMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOperatorMemberCrefCore(property, position, parent);
    		InsertedOperatorMemberCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOperatorMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedOperatorMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOperatorMemberCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOperatorMemberCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOperatorMemberCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOperatorMemberCrefCore(property, parent);
    		DeletedOperatorMemberCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOperatorMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedOperatorMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOperatorMemberCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOperatorMemberCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOperatorMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOperatorMemberCrefCore(oldElement, newElement);
    		UpdatedOperatorMemberCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOperatorMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOperatorMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOperatorMemberCrefCore(property, oldParent, position, newParent);
    		MovedOperatorMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOperatorMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOperatorMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOperatorMemberCrefCore(property, oldParent, position, newParent);
    		MatchedOperatorMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConversionOperatorMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConversionOperatorMemberCref(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConversionOperatorMemberCref(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConversionOperatorMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConversionOperatorMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConversionOperatorMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConversionOperatorMemberCrefCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConversionOperatorMemberCrefCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConversionOperatorMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConversionOperatorMemberCref(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConversionOperatorMemberCrefCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConversionOperatorMemberCref(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConversionOperatorMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConversionOperatorMemberCrefCore(property, position, parent);
    		InsertedConversionOperatorMemberCrefAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConversionOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConversionOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConversionOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedConversionOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConversionOperatorMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConversionOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConversionOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void DeletedConversionOperatorMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConversionOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConversionOperatorMemberCrefCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConversionOperatorMemberCref(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConversionOperatorMemberCrefBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConversionOperatorMemberCrefCore(property, parent);
    		DeletedConversionOperatorMemberCrefAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConversionOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConversionOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConversionOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConversionOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConversionOperatorMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConversionOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConversionOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void UpdatedConversionOperatorMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConversionOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConversionOperatorMemberCrefCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConversionOperatorMemberCref(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConversionOperatorMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConversionOperatorMemberCrefCore(oldElement, newElement);
    		UpdatedConversionOperatorMemberCrefAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConversionOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConversionOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConversionOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConversionOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConversionOperatorMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConversionOperatorMemberCrefCore(property, oldParent, position, newParent);
    		MovedConversionOperatorMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConversionOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConversionOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConversionOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OperatorKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConversionOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConversionOperatorMemberCrefBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConversionOperatorMemberCrefCore(property, oldParent, position, newParent);
    		MatchedConversionOperatorMemberCrefAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CrefParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCrefParameterList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefParameterList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCrefParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCrefParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCrefParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCrefParameterListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefParameterListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCrefParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCrefParameterList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCrefParameterListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCrefParameterList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCrefParameterListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCrefParameterListCore(property, position, parent);
    		InsertedCrefParameterListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCrefParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCrefParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedCrefParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCrefParameterListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCrefParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefParameterListCore(XElement, XElement)"/>.</param>
        partial void DeletedCrefParameterListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCrefParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCrefParameterListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCrefParameterList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCrefParameterListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCrefParameterListCore(property, parent);
    		DeletedCrefParameterListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCrefParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCrefParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCrefParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCrefParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCrefParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefParameterListCore(XElement, XElement)"/>.</param>
        partial void UpdatedCrefParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCrefParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCrefParameterListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCrefParameterList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCrefParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCrefParameterListCore(oldElement, newElement);
    		UpdatedCrefParameterListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCrefParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCrefParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCrefParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCrefParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCrefParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCrefParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCrefParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCrefParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCrefParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCrefParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCrefParameterListCore(property, oldParent, position, newParent);
    		MovedCrefParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCrefParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCrefParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCrefParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCrefParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCrefParameterListCore(property, oldParent, position, newParent);
    		MatchedCrefParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CrefBracketedParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCrefBracketedParameterList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefBracketedParameterList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCrefBracketedParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCrefBracketedParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCrefBracketedParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCrefBracketedParameterListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCrefBracketedParameterListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCrefBracketedParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCrefBracketedParameterList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCrefBracketedParameterListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCrefBracketedParameterList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCrefBracketedParameterListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCrefBracketedParameterListCore(property, position, parent);
    		InsertedCrefBracketedParameterListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCrefBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCrefBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedCrefBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCrefBracketedParameterListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCrefBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCrefBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void DeletedCrefBracketedParameterListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCrefBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCrefBracketedParameterListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCrefBracketedParameterList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCrefBracketedParameterListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCrefBracketedParameterListCore(property, parent);
    		DeletedCrefBracketedParameterListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCrefBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCrefBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCrefBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCrefBracketedParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCrefBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCrefBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void UpdatedCrefBracketedParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCrefBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCrefBracketedParameterListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCrefBracketedParameterList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCrefBracketedParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCrefBracketedParameterListCore(oldElement, newElement);
    		UpdatedCrefBracketedParameterListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCrefBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCrefBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCrefBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCrefBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCrefBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCrefBracketedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCrefBracketedParameterListCore(property, oldParent, position, newParent);
    		MovedCrefBracketedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCrefBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCrefBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCrefBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCrefBracketedParameterListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCrefBracketedParameterListCore(property, oldParent, position, newParent);
    		MatchedCrefBracketedParameterListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlElement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlElementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlElementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlElementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlElementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlElement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlElementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlElement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlElementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlElementCore(property, position, parent);
    		InsertedXmlElementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlElementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlElementCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlElementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlElementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlElement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlElementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlElementCore(property, parent);
    		DeletedXmlElementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlElementCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlElementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlElement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlElementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlElementCore(oldElement, newElement);
    		UpdatedXmlElementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlElementCore(property, oldParent, position, newParent);
    		MovedXmlElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlElementCore(property, oldParent, position, newParent);
    		MatchedXmlElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlEmptyElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlEmptyElement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlEmptyElement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlEmptyElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlEmptyElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlEmptyElementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlEmptyElementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlEmptyElementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlEmptyElementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlEmptyElement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlEmptyElementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlEmptyElement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlEmptyElementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlEmptyElementCore(property, position, parent);
    		InsertedXmlEmptyElementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlEmptyElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlEmptyElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlEmptyElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlEmptyElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlEmptyElementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlEmptyElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlEmptyElementCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlEmptyElementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlEmptyElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlEmptyElementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlEmptyElement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlEmptyElementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlEmptyElementCore(property, parent);
    		DeletedXmlEmptyElementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlEmptyElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlEmptyElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlEmptyElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlEmptyElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlEmptyElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlEmptyElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlEmptyElementCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlEmptyElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlEmptyElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlEmptyElementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SlashGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlEmptyElement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlEmptyElementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlEmptyElementCore(oldElement, newElement);
    		UpdatedXmlEmptyElementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlEmptyElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlEmptyElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlEmptyElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlEmptyElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlEmptyElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlEmptyElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlEmptyElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlEmptyElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlEmptyElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlEmptyElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlEmptyElementCore(property, oldParent, position, newParent);
    		MovedXmlEmptyElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlEmptyElement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlEmptyElement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlEmptyElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlEmptyElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlEmptyElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlEmptyElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlEmptyElement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlEmptyElementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlEmptyElement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlEmptyElementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlEmptyElementCore(property, oldParent, position, newParent);
    		MatchedXmlEmptyElementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlText
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlText(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlText(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlTextCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlText(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlTextBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlTextCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlTextCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlTextAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlText(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlTextCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlText(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlTextBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlTextCore(property, position, parent);
    		InsertedXmlTextAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlTextCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlTextBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlTextCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlTextAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlTextCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlText(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlTextBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlTextCore(property, parent);
    		DeletedXmlTextAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlTextCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlTextBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlTextCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlTextAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlTextCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlText(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlTextBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlTextCore(oldElement, newElement);
    		UpdatedXmlTextAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlText(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlText(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlTextCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlTextCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlText(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlTextCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlText(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlTextBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlTextCore(property, oldParent, position, newParent);
    		MovedXmlTextAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlText(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlText(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlTextCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlText(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlTextCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlText(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlTextBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlTextCore(property, oldParent, position, newParent);
    		MatchedXmlTextAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlCDataSection
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlCDataSection(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlCDataSection(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlCDataSectionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlCDataSection(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlCDataSectionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlCDataSectionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlCDataSectionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlCDataSectionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlCDataSection(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlCDataSectionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlCDataSection(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlCDataSectionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlCDataSectionCore(property, position, parent);
    		InsertedXmlCDataSectionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlCDataSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlCDataSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlCDataSectionCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlCDataSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlCDataSectionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlCDataSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlCDataSectionCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlCDataSectionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlCDataSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlCDataSectionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlCDataSection(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlCDataSectionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlCDataSectionCore(property, parent);
    		DeletedXmlCDataSectionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlCDataSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlCDataSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlCDataSectionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlCDataSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlCDataSectionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlCDataSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlCDataSectionCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlCDataSectionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlCDataSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlCDataSectionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "StartCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlCDataSection(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlCDataSectionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlCDataSectionCore(oldElement, newElement);
    		UpdatedXmlCDataSectionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlCDataSection(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlCDataSection(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlCDataSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlCDataSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlCDataSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlCDataSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlCDataSection(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlCDataSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlCDataSection(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlCDataSectionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlCDataSectionCore(property, oldParent, position, newParent);
    		MovedXmlCDataSectionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlCDataSection(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCDataSection(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCDataSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlCDataSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCDataSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlCDataSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlCDataSection(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCDataSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndCDataToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlCDataSection(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlCDataSectionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlCDataSectionCore(property, oldParent, position, newParent);
    		MatchedXmlCDataSectionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlProcessingInstruction
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlProcessingInstruction(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlProcessingInstruction(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlProcessingInstructionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlProcessingInstruction(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlProcessingInstructionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlProcessingInstructionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlProcessingInstructionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlProcessingInstructionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlProcessingInstruction(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlProcessingInstructionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlProcessingInstruction(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlProcessingInstructionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlProcessingInstructionCore(property, position, parent);
    		InsertedXmlProcessingInstructionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlProcessingInstruction(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlProcessingInstruction(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlProcessingInstructionCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlProcessingInstruction(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlProcessingInstructionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlProcessingInstructionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlProcessingInstructionCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlProcessingInstructionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlProcessingInstruction(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlProcessingInstructionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlProcessingInstruction(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlProcessingInstructionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlProcessingInstructionCore(property, parent);
    		DeletedXmlProcessingInstructionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlProcessingInstruction(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlProcessingInstruction(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlProcessingInstructionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlProcessingInstruction(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlProcessingInstructionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlProcessingInstructionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlProcessingInstructionCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlProcessingInstructionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlProcessingInstruction(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlProcessingInstructionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "StartProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlProcessingInstruction(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlProcessingInstructionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlProcessingInstructionCore(oldElement, newElement);
    		UpdatedXmlProcessingInstructionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlProcessingInstruction(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlProcessingInstructionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlProcessingInstructionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlProcessingInstructionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlProcessingInstruction(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlProcessingInstructionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlProcessingInstructionCore(property, oldParent, position, newParent);
    		MovedXmlProcessingInstructionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlProcessingInstruction(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlProcessingInstructionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlProcessingInstructionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlProcessingInstructionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlProcessingInstruction(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlProcessingInstructionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlProcessingInstructionCore(property, oldParent, position, newParent);
    		MatchedXmlProcessingInstructionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlComment
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlComment(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlComment(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlCommentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlComment(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlCommentBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlCommentCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlCommentCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlCommentAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlComment(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlCommentCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlComment(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlCommentBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlCommentCore(property, position, parent);
    		InsertedXmlCommentAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlComment(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlComment(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlCommentCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlComment(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlCommentBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlCommentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlCommentCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlCommentAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlComment(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlCommentCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlComment(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlCommentBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlCommentCore(property, parent);
    		DeletedXmlCommentAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlComment(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlComment(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlCommentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlComment(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlCommentBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlCommentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlCommentCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlCommentAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlComment(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlCommentCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlComment(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlCommentBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlCommentCore(oldElement, newElement);
    		UpdatedXmlCommentAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlComment(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlComment(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlCommentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlComment(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlCommentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlCommentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlCommentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlCommentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlComment(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlCommentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlComment(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlCommentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlCommentCore(property, oldParent, position, newParent);
    		MovedXmlCommentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlComment(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlComment(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCommentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlComment(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCommentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCommentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCommentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlCommentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlComment(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCommentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlComment(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlCommentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlCommentCore(property, oldParent, position, newParent);
    		MatchedXmlCommentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlTextAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlTextAttribute(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlTextAttribute(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlTextAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlTextAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlTextAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlTextAttributeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlTextAttributeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlTextAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlTextAttribute(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlTextAttributeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlTextAttribute(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlTextAttributeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlTextAttributeCore(property, position, parent);
    		InsertedXmlTextAttributeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlTextAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlTextAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlTextAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlTextAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlTextAttributeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlTextAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlTextAttributeCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlTextAttributeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlTextAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlTextAttributeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlTextAttribute(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlTextAttributeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlTextAttributeCore(property, parent);
    		DeletedXmlTextAttributeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlTextAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlTextAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlTextAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlTextAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlTextAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlTextAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlTextAttributeCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlTextAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlTextAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlTextAttributeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlTextAttribute(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlTextAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlTextAttributeCore(oldElement, newElement);
    		UpdatedXmlTextAttributeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlTextAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlTextAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlTextAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlTextAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlTextAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlTextAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlTextAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlTextAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlTextAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlTextAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlTextAttributeCore(property, oldParent, position, newParent);
    		MovedXmlTextAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlTextAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlTextAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlTextAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlTextAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlTextAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlTextAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlTextAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlTextAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlTextAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlTextAttributeCore(property, oldParent, position, newParent);
    		MatchedXmlTextAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlCrefAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlCrefAttribute(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlCrefAttribute(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlCrefAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlCrefAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlCrefAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlCrefAttributeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlCrefAttributeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlCrefAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlCrefAttribute(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlCrefAttributeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlCrefAttribute(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlCrefAttributeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlCrefAttributeCore(property, position, parent);
    		InsertedXmlCrefAttributeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlCrefAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlCrefAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlCrefAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlCrefAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlCrefAttributeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlCrefAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlCrefAttributeCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlCrefAttributeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlCrefAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlCrefAttributeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlCrefAttribute(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlCrefAttributeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlCrefAttributeCore(property, parent);
    		DeletedXmlCrefAttributeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlCrefAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlCrefAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlCrefAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlCrefAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlCrefAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlCrefAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlCrefAttributeCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlCrefAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlCrefAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlCrefAttributeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlCrefAttribute(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlCrefAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlCrefAttributeCore(oldElement, newElement);
    		UpdatedXmlCrefAttributeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlCrefAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlCrefAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlCrefAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlCrefAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlCrefAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlCrefAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlCrefAttributeCore(property, oldParent, position, newParent);
    		MovedXmlCrefAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlCrefAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCrefAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlCrefAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCrefAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlCrefAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlCrefAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlCrefAttributeCore(property, oldParent, position, newParent);
    		MatchedXmlCrefAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region XmlNameAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedXmlNameAttribute(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlNameAttribute(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedXmlNameAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedXmlNameAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedXmlNameAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedXmlNameAttributeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedXmlNameAttributeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedXmlNameAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedXmlNameAttribute(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedXmlNameAttributeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedXmlNameAttribute(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedXmlNameAttributeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedXmlNameAttributeCore(property, position, parent);
    		InsertedXmlNameAttributeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedXmlNameAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlNameAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedXmlNameAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedXmlNameAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedXmlNameAttributeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedXmlNameAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedXmlNameAttributeCore(XElement, XElement)"/>.</param>
        partial void DeletedXmlNameAttributeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedXmlNameAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedXmlNameAttributeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedXmlNameAttribute(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedXmlNameAttributeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedXmlNameAttributeCore(property, parent);
    		DeletedXmlNameAttributeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedXmlNameAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlNameAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedXmlNameAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedXmlNameAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedXmlNameAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedXmlNameAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedXmlNameAttributeCore(XElement, XElement)"/>.</param>
        partial void UpdatedXmlNameAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedXmlNameAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedXmlNameAttributeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedXmlNameAttribute(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedXmlNameAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedXmlNameAttributeCore(oldElement, newElement);
    		UpdatedXmlNameAttributeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedXmlNameAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlNameAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedXmlNameAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedXmlNameAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedXmlNameAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedXmlNameAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedXmlNameAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedXmlNameAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedXmlNameAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedXmlNameAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedXmlNameAttributeCore(property, oldParent, position, newParent);
    		MovedXmlNameAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlNameAttribute(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameAttribute(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlNameAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedXmlNameAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlNameAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedXmlNameAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlNameAttribute(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlNameAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Name")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StartQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EndQuoteToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedXmlNameAttribute(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedXmlNameAttributeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedXmlNameAttributeCore(property, oldParent, position, newParent);
    		MatchedXmlNameAttributeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ParenthesizedExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedParenthesizedExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedParenthesizedExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedParenthesizedExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedParenthesizedExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedParenthesizedExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedParenthesizedExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedParenthesizedExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedParenthesizedExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedParenthesizedExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedParenthesizedExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedParenthesizedExpressionCore(property, position, parent);
    		InsertedParenthesizedExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedParenthesizedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedParenthesizedExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedParenthesizedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedParenthesizedExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedParenthesizedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedParenthesizedExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedParenthesizedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedParenthesizedExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedParenthesizedExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedParenthesizedExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedParenthesizedExpressionCore(property, parent);
    		DeletedParenthesizedExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedParenthesizedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedParenthesizedExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedParenthesizedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedParenthesizedExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedParenthesizedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedParenthesizedExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedParenthesizedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedParenthesizedExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedParenthesizedExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedParenthesizedExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedParenthesizedExpressionCore(oldElement, newElement);
    		UpdatedParenthesizedExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedParenthesizedExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedParenthesizedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedParenthesizedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedParenthesizedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedParenthesizedExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedParenthesizedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedParenthesizedExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedParenthesizedExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedParenthesizedExpressionCore(property, oldParent, position, newParent);
    		MovedParenthesizedExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedParenthesizedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedParenthesizedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedParenthesizedExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedParenthesizedExpressionCore(property, oldParent, position, newParent);
    		MatchedParenthesizedExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TupleExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTupleExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTupleExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTupleExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTupleExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTupleExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTupleExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTupleExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTupleExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTupleExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTupleExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTupleExpressionCore(property, position, parent);
    		InsertedTupleExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTupleExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTupleExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedTupleExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTupleExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTupleExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedTupleExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTupleExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTupleExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTupleExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTupleExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTupleExpressionCore(property, parent);
    		DeletedTupleExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTupleExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTupleExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTupleExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTupleExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTupleExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedTupleExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTupleExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTupleExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTupleExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTupleExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTupleExpressionCore(oldElement, newElement);
    		UpdatedTupleExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTupleExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTupleExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTupleExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTupleExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTupleExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTupleExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTupleExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTupleExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTupleExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTupleExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTupleExpressionCore(property, oldParent, position, newParent);
    		MovedTupleExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTupleExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTupleExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTupleExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTupleExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTupleExpressionCore(property, oldParent, position, newParent);
    		MatchedTupleExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PrefixUnaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPrefixUnaryExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPrefixUnaryExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPrefixUnaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPrefixUnaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPrefixUnaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPrefixUnaryExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPrefixUnaryExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPrefixUnaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPrefixUnaryExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPrefixUnaryExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPrefixUnaryExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPrefixUnaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPrefixUnaryExpressionCore(property, position, parent);
    		InsertedPrefixUnaryExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPrefixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPrefixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPrefixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedPrefixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPrefixUnaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPrefixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPrefixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedPrefixUnaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPrefixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPrefixUnaryExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPrefixUnaryExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPrefixUnaryExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPrefixUnaryExpressionCore(property, parent);
    		DeletedPrefixUnaryExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPrefixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPrefixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPrefixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPrefixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPrefixUnaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPrefixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPrefixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedPrefixUnaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPrefixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPrefixUnaryExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPrefixUnaryExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPrefixUnaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPrefixUnaryExpressionCore(oldElement, newElement);
    		UpdatedPrefixUnaryExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPrefixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPrefixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPrefixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPrefixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPrefixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPrefixUnaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPrefixUnaryExpressionCore(property, oldParent, position, newParent);
    		MovedPrefixUnaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPrefixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPrefixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPrefixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPrefixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPrefixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPrefixUnaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPrefixUnaryExpressionCore(property, oldParent, position, newParent);
    		MatchedPrefixUnaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AwaitExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAwaitExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAwaitExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAwaitExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAwaitExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAwaitExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAwaitExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAwaitExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAwaitExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAwaitExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAwaitExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AwaitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAwaitExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAwaitExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAwaitExpressionCore(property, position, parent);
    		InsertedAwaitExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAwaitExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAwaitExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAwaitExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedAwaitExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAwaitExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAwaitExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAwaitExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedAwaitExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAwaitExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAwaitExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AwaitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAwaitExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAwaitExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAwaitExpressionCore(property, parent);
    		DeletedAwaitExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAwaitExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAwaitExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAwaitExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAwaitExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAwaitExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAwaitExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAwaitExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedAwaitExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAwaitExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAwaitExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AwaitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAwaitExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAwaitExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAwaitExpressionCore(oldElement, newElement);
    		UpdatedAwaitExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAwaitExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAwaitExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAwaitExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAwaitExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAwaitExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAwaitExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAwaitExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAwaitExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAwaitExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAwaitExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AwaitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAwaitExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAwaitExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAwaitExpressionCore(property, oldParent, position, newParent);
    		MovedAwaitExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAwaitExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAwaitExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAwaitExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAwaitExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAwaitExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAwaitExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAwaitExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAwaitExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAwaitExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAwaitExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AwaitKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAwaitExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAwaitExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAwaitExpressionCore(property, oldParent, position, newParent);
    		MatchedAwaitExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PostfixUnaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPostfixUnaryExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPostfixUnaryExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPostfixUnaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPostfixUnaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPostfixUnaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPostfixUnaryExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPostfixUnaryExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPostfixUnaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPostfixUnaryExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPostfixUnaryExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPostfixUnaryExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPostfixUnaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPostfixUnaryExpressionCore(property, position, parent);
    		InsertedPostfixUnaryExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPostfixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPostfixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPostfixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedPostfixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPostfixUnaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPostfixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPostfixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedPostfixUnaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPostfixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPostfixUnaryExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPostfixUnaryExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPostfixUnaryExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPostfixUnaryExpressionCore(property, parent);
    		DeletedPostfixUnaryExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPostfixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPostfixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPostfixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPostfixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPostfixUnaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPostfixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPostfixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedPostfixUnaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPostfixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPostfixUnaryExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPostfixUnaryExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPostfixUnaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPostfixUnaryExpressionCore(oldElement, newElement);
    		UpdatedPostfixUnaryExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPostfixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPostfixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPostfixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPostfixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPostfixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPostfixUnaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPostfixUnaryExpressionCore(property, oldParent, position, newParent);
    		MovedPostfixUnaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPostfixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPostfixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPostfixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPostfixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPostfixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPostfixUnaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPostfixUnaryExpressionCore(property, oldParent, position, newParent);
    		MatchedPostfixUnaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region MemberAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedMemberAccessExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMemberAccessExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedMemberAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedMemberAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedMemberAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedMemberAccessExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMemberAccessExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedMemberAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedMemberAccessExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedMemberAccessExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedMemberAccessExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedMemberAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedMemberAccessExpressionCore(property, position, parent);
    		InsertedMemberAccessExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedMemberAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMemberAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedMemberAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedMemberAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedMemberAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedMemberAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMemberAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedMemberAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedMemberAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedMemberAccessExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedMemberAccessExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedMemberAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedMemberAccessExpressionCore(property, parent);
    		DeletedMemberAccessExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedMemberAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMemberAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedMemberAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedMemberAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedMemberAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedMemberAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMemberAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedMemberAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedMemberAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedMemberAccessExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedMemberAccessExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedMemberAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedMemberAccessExpressionCore(oldElement, newElement);
    		UpdatedMemberAccessExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedMemberAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMemberAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedMemberAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedMemberAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedMemberAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedMemberAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedMemberAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedMemberAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedMemberAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedMemberAccessExpressionCore(property, oldParent, position, newParent);
    		MovedMemberAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMemberAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedMemberAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMemberAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedMemberAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMemberAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMemberAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedMemberAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedMemberAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedMemberAccessExpressionCore(property, oldParent, position, newParent);
    		MatchedMemberAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConditionalAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConditionalAccessExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConditionalAccessExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConditionalAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConditionalAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConditionalAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConditionalAccessExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConditionalAccessExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConditionalAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConditionalAccessExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConditionalAccessExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConditionalAccessExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConditionalAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConditionalAccessExpressionCore(property, position, parent);
    		InsertedConditionalAccessExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConditionalAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConditionalAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConditionalAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedConditionalAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConditionalAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConditionalAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConditionalAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedConditionalAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConditionalAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConditionalAccessExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConditionalAccessExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConditionalAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConditionalAccessExpressionCore(property, parent);
    		DeletedConditionalAccessExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConditionalAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConditionalAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConditionalAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConditionalAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConditionalAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConditionalAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConditionalAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedConditionalAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConditionalAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConditionalAccessExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConditionalAccessExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConditionalAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConditionalAccessExpressionCore(oldElement, newElement);
    		UpdatedConditionalAccessExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConditionalAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConditionalAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConditionalAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConditionalAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConditionalAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConditionalAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConditionalAccessExpressionCore(property, oldParent, position, newParent);
    		MovedConditionalAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConditionalAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConditionalAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConditionalAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConditionalAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConditionalAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConditionalAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConditionalAccessExpressionCore(property, oldParent, position, newParent);
    		MatchedConditionalAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region MemberBindingExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedMemberBindingExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMemberBindingExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedMemberBindingExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedMemberBindingExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedMemberBindingExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedMemberBindingExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMemberBindingExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedMemberBindingExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedMemberBindingExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedMemberBindingExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedMemberBindingExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedMemberBindingExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedMemberBindingExpressionCore(property, position, parent);
    		InsertedMemberBindingExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedMemberBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMemberBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedMemberBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedMemberBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedMemberBindingExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedMemberBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMemberBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedMemberBindingExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedMemberBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedMemberBindingExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedMemberBindingExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedMemberBindingExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedMemberBindingExpressionCore(property, parent);
    		DeletedMemberBindingExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedMemberBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMemberBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedMemberBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedMemberBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedMemberBindingExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedMemberBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMemberBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedMemberBindingExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedMemberBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedMemberBindingExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedMemberBindingExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedMemberBindingExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedMemberBindingExpressionCore(oldElement, newElement);
    		UpdatedMemberBindingExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedMemberBindingExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMemberBindingExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedMemberBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedMemberBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedMemberBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedMemberBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedMemberBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedMemberBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedMemberBindingExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedMemberBindingExpressionCore(property, oldParent, position, newParent);
    		MovedMemberBindingExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMemberBindingExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberBindingExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedMemberBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMemberBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedMemberBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMemberBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMemberBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedMemberBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedMemberBindingExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedMemberBindingExpressionCore(property, oldParent, position, newParent);
    		MatchedMemberBindingExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ElementBindingExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedElementBindingExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElementBindingExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedElementBindingExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedElementBindingExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedElementBindingExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedElementBindingExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElementBindingExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedElementBindingExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedElementBindingExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedElementBindingExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedElementBindingExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedElementBindingExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedElementBindingExpressionCore(property, position, parent);
    		InsertedElementBindingExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedElementBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElementBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedElementBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedElementBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedElementBindingExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedElementBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElementBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedElementBindingExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedElementBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedElementBindingExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedElementBindingExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedElementBindingExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedElementBindingExpressionCore(property, parent);
    		DeletedElementBindingExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedElementBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElementBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedElementBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedElementBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedElementBindingExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedElementBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElementBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedElementBindingExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedElementBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedElementBindingExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedElementBindingExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedElementBindingExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedElementBindingExpressionCore(oldElement, newElement);
    		UpdatedElementBindingExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedElementBindingExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElementBindingExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedElementBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedElementBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedElementBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedElementBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedElementBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedElementBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedElementBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedElementBindingExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedElementBindingExpressionCore(property, oldParent, position, newParent);
    		MovedElementBindingExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElementBindingExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementBindingExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElementBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedElementBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElementBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedElementBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElementBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElementBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedElementBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedElementBindingExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedElementBindingExpressionCore(property, oldParent, position, newParent);
    		MatchedElementBindingExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ImplicitElementAccess
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedImplicitElementAccess(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedImplicitElementAccess(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedImplicitElementAccessCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedImplicitElementAccess(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedImplicitElementAccessBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedImplicitElementAccessCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedImplicitElementAccessCore(XElement, int, XElement)"/>.</param>
        partial void InsertedImplicitElementAccessAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedImplicitElementAccess(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedImplicitElementAccessCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedImplicitElementAccess(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedImplicitElementAccessBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedImplicitElementAccessCore(property, position, parent);
    		InsertedImplicitElementAccessAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedImplicitElementAccess(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedImplicitElementAccess(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedImplicitElementAccessCore(XElement, XElement)"/> is not executed and <see cref="DeletedImplicitElementAccess(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedImplicitElementAccessBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedImplicitElementAccessCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedImplicitElementAccessCore(XElement, XElement)"/>.</param>
        partial void DeletedImplicitElementAccessAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedImplicitElementAccess(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedImplicitElementAccessCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedImplicitElementAccess(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedImplicitElementAccessBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedImplicitElementAccessCore(property, parent);
    		DeletedImplicitElementAccessAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedImplicitElementAccess(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedImplicitElementAccess(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedImplicitElementAccessCore(XElement, XElement)"/> is not executed and <see cref="UpdatedImplicitElementAccess(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedImplicitElementAccessBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedImplicitElementAccessCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedImplicitElementAccessCore(XElement, XElement)"/>.</param>
        partial void UpdatedImplicitElementAccessAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedImplicitElementAccess(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedImplicitElementAccessCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedImplicitElementAccess(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedImplicitElementAccessBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedImplicitElementAccessCore(oldElement, newElement);
    		UpdatedImplicitElementAccessAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedImplicitElementAccess(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedImplicitElementAccess(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedImplicitElementAccessCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedImplicitElementAccess(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedImplicitElementAccessBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedImplicitElementAccessAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedImplicitElementAccess(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedImplicitElementAccessCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedImplicitElementAccess(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedImplicitElementAccessBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedImplicitElementAccessCore(property, oldParent, position, newParent);
    		MovedImplicitElementAccessAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedImplicitElementAccess(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitElementAccess(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedImplicitElementAccessCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedImplicitElementAccess(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedImplicitElementAccessBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedImplicitElementAccessAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedImplicitElementAccess(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedImplicitElementAccessCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedImplicitElementAccess(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedImplicitElementAccessBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedImplicitElementAccessCore(property, oldParent, position, newParent);
    		MatchedImplicitElementAccessAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BinaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBinaryExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBinaryExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBinaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBinaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBinaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBinaryExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBinaryExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBinaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBinaryExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBinaryExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBinaryExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBinaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBinaryExpressionCore(property, position, parent);
    		InsertedBinaryExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBinaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBinaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBinaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedBinaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBinaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBinaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBinaryExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedBinaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBinaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBinaryExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBinaryExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBinaryExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBinaryExpressionCore(property, parent);
    		DeletedBinaryExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBinaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBinaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBinaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBinaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBinaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBinaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBinaryExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedBinaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBinaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBinaryExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBinaryExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBinaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBinaryExpressionCore(oldElement, newElement);
    		UpdatedBinaryExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBinaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBinaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBinaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBinaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBinaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBinaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBinaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBinaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBinaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBinaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBinaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBinaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBinaryExpressionCore(property, oldParent, position, newParent);
    		MovedBinaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBinaryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBinaryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBinaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBinaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBinaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBinaryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBinaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBinaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBinaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBinaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBinaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBinaryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBinaryExpressionCore(property, oldParent, position, newParent);
    		MatchedBinaryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AssignmentExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAssignmentExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAssignmentExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAssignmentExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAssignmentExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAssignmentExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAssignmentExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAssignmentExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAssignmentExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAssignmentExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAssignmentExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAssignmentExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAssignmentExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAssignmentExpressionCore(property, position, parent);
    		InsertedAssignmentExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAssignmentExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAssignmentExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAssignmentExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedAssignmentExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAssignmentExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAssignmentExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAssignmentExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedAssignmentExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAssignmentExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAssignmentExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAssignmentExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAssignmentExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAssignmentExpressionCore(property, parent);
    		DeletedAssignmentExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAssignmentExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAssignmentExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAssignmentExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAssignmentExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAssignmentExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAssignmentExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAssignmentExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedAssignmentExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAssignmentExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAssignmentExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAssignmentExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAssignmentExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAssignmentExpressionCore(oldElement, newElement);
    		UpdatedAssignmentExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAssignmentExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAssignmentExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAssignmentExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAssignmentExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAssignmentExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAssignmentExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAssignmentExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAssignmentExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAssignmentExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAssignmentExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAssignmentExpressionCore(property, oldParent, position, newParent);
    		MovedAssignmentExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAssignmentExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAssignmentExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAssignmentExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAssignmentExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAssignmentExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAssignmentExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAssignmentExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAssignmentExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OperatorToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAssignmentExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAssignmentExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAssignmentExpressionCore(property, oldParent, position, newParent);
    		MatchedAssignmentExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConditionalExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConditionalExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConditionalExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConditionalExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConditionalExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConditionalExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConditionalExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConditionalExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConditionalExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConditionalExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConditionalExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConditionalExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConditionalExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConditionalExpressionCore(property, position, parent);
    		InsertedConditionalExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConditionalExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConditionalExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConditionalExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedConditionalExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConditionalExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConditionalExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConditionalExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedConditionalExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConditionalExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConditionalExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConditionalExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConditionalExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConditionalExpressionCore(property, parent);
    		DeletedConditionalExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConditionalExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConditionalExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConditionalExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConditionalExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConditionalExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConditionalExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConditionalExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedConditionalExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConditionalExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConditionalExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConditionalExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConditionalExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConditionalExpressionCore(oldElement, newElement);
    		UpdatedConditionalExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConditionalExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConditionalExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConditionalExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConditionalExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConditionalExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConditionalExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConditionalExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConditionalExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConditionalExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConditionalExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConditionalExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConditionalExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConditionalExpressionCore(property, oldParent, position, newParent);
    		MovedConditionalExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConditionalExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConditionalExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConditionalExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConditionalExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConditionalExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConditionalExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConditionalExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConditionalExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConditionalExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConditionalExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConditionalExpressionCore(property, oldParent, position, newParent);
    		MatchedConditionalExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LiteralExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLiteralExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLiteralExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLiteralExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLiteralExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLiteralExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLiteralExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLiteralExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLiteralExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLiteralExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLiteralExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLiteralExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLiteralExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLiteralExpressionCore(property, position, parent);
    		InsertedLiteralExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLiteralExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLiteralExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLiteralExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedLiteralExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLiteralExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLiteralExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLiteralExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedLiteralExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLiteralExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLiteralExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLiteralExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLiteralExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLiteralExpressionCore(property, parent);
    		DeletedLiteralExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLiteralExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLiteralExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLiteralExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLiteralExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLiteralExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLiteralExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLiteralExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedLiteralExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLiteralExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLiteralExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLiteralExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLiteralExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLiteralExpressionCore(oldElement, newElement);
    		UpdatedLiteralExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLiteralExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLiteralExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLiteralExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLiteralExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLiteralExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLiteralExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLiteralExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLiteralExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLiteralExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLiteralExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLiteralExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLiteralExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLiteralExpressionCore(property, oldParent, position, newParent);
    		MovedLiteralExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLiteralExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLiteralExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLiteralExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLiteralExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLiteralExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLiteralExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLiteralExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLiteralExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLiteralExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLiteralExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLiteralExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLiteralExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLiteralExpressionCore(property, oldParent, position, newParent);
    		MatchedLiteralExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region MakeRefExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedMakeRefExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMakeRefExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedMakeRefExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedMakeRefExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedMakeRefExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedMakeRefExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedMakeRefExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedMakeRefExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedMakeRefExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedMakeRefExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedMakeRefExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedMakeRefExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedMakeRefExpressionCore(property, position, parent);
    		InsertedMakeRefExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedMakeRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMakeRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedMakeRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedMakeRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedMakeRefExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedMakeRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedMakeRefExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedMakeRefExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedMakeRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedMakeRefExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedMakeRefExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedMakeRefExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedMakeRefExpressionCore(property, parent);
    		DeletedMakeRefExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedMakeRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMakeRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedMakeRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedMakeRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedMakeRefExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedMakeRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedMakeRefExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedMakeRefExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedMakeRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedMakeRefExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedMakeRefExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedMakeRefExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedMakeRefExpressionCore(oldElement, newElement);
    		UpdatedMakeRefExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedMakeRefExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMakeRefExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedMakeRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedMakeRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedMakeRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedMakeRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedMakeRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedMakeRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedMakeRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedMakeRefExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedMakeRefExpressionCore(property, oldParent, position, newParent);
    		MovedMakeRefExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMakeRefExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMakeRefExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMakeRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedMakeRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMakeRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedMakeRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMakeRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMakeRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedMakeRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedMakeRefExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedMakeRefExpressionCore(property, oldParent, position, newParent);
    		MatchedMakeRefExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region RefTypeExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedRefTypeExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefTypeExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedRefTypeExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedRefTypeExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedRefTypeExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedRefTypeExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefTypeExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedRefTypeExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedRefTypeExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedRefTypeExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedRefTypeExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedRefTypeExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedRefTypeExpressionCore(property, position, parent);
    		InsertedRefTypeExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedRefTypeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefTypeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedRefTypeExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedRefTypeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedRefTypeExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedRefTypeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefTypeExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedRefTypeExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedRefTypeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedRefTypeExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedRefTypeExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedRefTypeExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedRefTypeExpressionCore(property, parent);
    		DeletedRefTypeExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedRefTypeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefTypeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedRefTypeExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedRefTypeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedRefTypeExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedRefTypeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefTypeExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedRefTypeExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedRefTypeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedRefTypeExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedRefTypeExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedRefTypeExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedRefTypeExpressionCore(oldElement, newElement);
    		UpdatedRefTypeExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedRefTypeExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefTypeExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedRefTypeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedRefTypeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedRefTypeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedRefTypeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedRefTypeExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedRefTypeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedRefTypeExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedRefTypeExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedRefTypeExpressionCore(property, oldParent, position, newParent);
    		MovedRefTypeExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefTypeExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefTypeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedRefTypeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefTypeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedRefTypeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefTypeExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefTypeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedRefTypeExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedRefTypeExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedRefTypeExpressionCore(property, oldParent, position, newParent);
    		MatchedRefTypeExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region RefValueExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedRefValueExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefValueExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedRefValueExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedRefValueExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedRefValueExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedRefValueExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefValueExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedRefValueExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedRefValueExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedRefValueExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "Comma")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedRefValueExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedRefValueExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedRefValueExpressionCore(property, position, parent);
    		InsertedRefValueExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedRefValueExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefValueExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedRefValueExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedRefValueExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedRefValueExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedRefValueExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefValueExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedRefValueExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedRefValueExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedRefValueExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "Comma")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedRefValueExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedRefValueExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedRefValueExpressionCore(property, parent);
    		DeletedRefValueExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedRefValueExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefValueExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedRefValueExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedRefValueExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedRefValueExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedRefValueExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefValueExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedRefValueExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedRefValueExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedRefValueExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "Comma")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedRefValueExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedRefValueExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedRefValueExpressionCore(oldElement, newElement);
    		UpdatedRefValueExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedRefValueExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefValueExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedRefValueExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedRefValueExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedRefValueExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedRefValueExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefValueExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedRefValueExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedRefValueExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedRefValueExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "Comma")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedRefValueExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedRefValueExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedRefValueExpressionCore(property, oldParent, position, newParent);
    		MovedRefValueExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefValueExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefValueExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefValueExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedRefValueExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefValueExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefValueExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefValueExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedRefValueExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefValueExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefValueExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "Comma")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedRefValueExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedRefValueExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedRefValueExpressionCore(property, oldParent, position, newParent);
    		MatchedRefValueExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CheckedExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCheckedExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCheckedExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCheckedExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCheckedExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCheckedExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCheckedExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCheckedExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCheckedExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCheckedExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCheckedExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCheckedExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCheckedExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCheckedExpressionCore(property, position, parent);
    		InsertedCheckedExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCheckedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCheckedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCheckedExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedCheckedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCheckedExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCheckedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCheckedExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedCheckedExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCheckedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCheckedExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCheckedExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCheckedExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCheckedExpressionCore(property, parent);
    		DeletedCheckedExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCheckedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCheckedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCheckedExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCheckedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCheckedExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCheckedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCheckedExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedCheckedExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCheckedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCheckedExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCheckedExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCheckedExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCheckedExpressionCore(oldElement, newElement);
    		UpdatedCheckedExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCheckedExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCheckedExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCheckedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCheckedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCheckedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCheckedExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCheckedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCheckedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCheckedExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCheckedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCheckedExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCheckedExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCheckedExpressionCore(property, oldParent, position, newParent);
    		MovedCheckedExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCheckedExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCheckedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCheckedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCheckedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCheckedExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCheckedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCheckedExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCheckedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCheckedExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCheckedExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCheckedExpressionCore(property, oldParent, position, newParent);
    		MatchedCheckedExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DefaultExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDefaultExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefaultExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDefaultExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDefaultExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDefaultExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDefaultExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefaultExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDefaultExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDefaultExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDefaultExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDefaultExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDefaultExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDefaultExpressionCore(property, position, parent);
    		InsertedDefaultExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDefaultExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefaultExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDefaultExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedDefaultExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDefaultExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDefaultExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefaultExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedDefaultExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDefaultExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDefaultExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDefaultExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDefaultExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDefaultExpressionCore(property, parent);
    		DeletedDefaultExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDefaultExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefaultExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDefaultExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDefaultExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDefaultExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDefaultExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefaultExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedDefaultExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDefaultExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDefaultExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDefaultExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDefaultExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDefaultExpressionCore(oldElement, newElement);
    		UpdatedDefaultExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDefaultExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefaultExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDefaultExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDefaultExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDefaultExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDefaultExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefaultExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDefaultExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDefaultExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDefaultExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDefaultExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDefaultExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDefaultExpressionCore(property, oldParent, position, newParent);
    		MovedDefaultExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefaultExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefaultExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDefaultExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefaultExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefaultExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDefaultExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefaultExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefaultExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDefaultExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDefaultExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDefaultExpressionCore(property, oldParent, position, newParent);
    		MatchedDefaultExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TypeOfExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTypeOfExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeOfExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTypeOfExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTypeOfExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTypeOfExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTypeOfExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTypeOfExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTypeOfExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTypeOfExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTypeOfExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTypeOfExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTypeOfExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTypeOfExpressionCore(property, position, parent);
    		InsertedTypeOfExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTypeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTypeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedTypeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTypeOfExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTypeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTypeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedTypeOfExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTypeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTypeOfExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTypeOfExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTypeOfExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTypeOfExpressionCore(property, parent);
    		DeletedTypeOfExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTypeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTypeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTypeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTypeOfExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTypeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTypeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedTypeOfExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTypeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTypeOfExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTypeOfExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTypeOfExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTypeOfExpressionCore(oldElement, newElement);
    		UpdatedTypeOfExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTypeOfExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeOfExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTypeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTypeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTypeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTypeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTypeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTypeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTypeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTypeOfExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTypeOfExpressionCore(property, oldParent, position, newParent);
    		MovedTypeOfExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeOfExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeOfExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTypeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTypeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTypeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTypeOfExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTypeOfExpressionCore(property, oldParent, position, newParent);
    		MatchedTypeOfExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SizeOfExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSizeOfExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSizeOfExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSizeOfExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSizeOfExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSizeOfExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSizeOfExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSizeOfExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSizeOfExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSizeOfExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSizeOfExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSizeOfExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSizeOfExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSizeOfExpressionCore(property, position, parent);
    		InsertedSizeOfExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSizeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSizeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSizeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedSizeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSizeOfExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSizeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSizeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedSizeOfExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSizeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSizeOfExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSizeOfExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSizeOfExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSizeOfExpressionCore(property, parent);
    		DeletedSizeOfExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSizeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSizeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSizeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSizeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSizeOfExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSizeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSizeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedSizeOfExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSizeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSizeOfExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSizeOfExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSizeOfExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSizeOfExpressionCore(oldElement, newElement);
    		UpdatedSizeOfExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSizeOfExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSizeOfExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSizeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSizeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSizeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSizeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSizeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSizeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSizeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSizeOfExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSizeOfExpressionCore(property, oldParent, position, newParent);
    		MovedSizeOfExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSizeOfExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSizeOfExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSizeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSizeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSizeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSizeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSizeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSizeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSizeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSizeOfExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSizeOfExpressionCore(property, oldParent, position, newParent);
    		MatchedSizeOfExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InvocationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInvocationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInvocationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInvocationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInvocationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInvocationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInvocationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInvocationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInvocationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInvocationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInvocationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInvocationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInvocationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInvocationExpressionCore(property, position, parent);
    		InsertedInvocationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInvocationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInvocationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInvocationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedInvocationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInvocationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInvocationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInvocationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedInvocationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInvocationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInvocationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInvocationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInvocationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInvocationExpressionCore(property, parent);
    		DeletedInvocationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInvocationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInvocationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInvocationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInvocationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInvocationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInvocationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInvocationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedInvocationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInvocationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInvocationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInvocationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInvocationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInvocationExpressionCore(oldElement, newElement);
    		UpdatedInvocationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInvocationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInvocationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInvocationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInvocationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInvocationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInvocationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInvocationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInvocationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInvocationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInvocationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInvocationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInvocationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInvocationExpressionCore(property, oldParent, position, newParent);
    		MovedInvocationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInvocationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInvocationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInvocationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInvocationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInvocationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInvocationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInvocationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInvocationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInvocationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInvocationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInvocationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInvocationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInvocationExpressionCore(property, oldParent, position, newParent);
    		MatchedInvocationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ElementAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedElementAccessExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElementAccessExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedElementAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedElementAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedElementAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedElementAccessExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedElementAccessExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedElementAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedElementAccessExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedElementAccessExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedElementAccessExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedElementAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedElementAccessExpressionCore(property, position, parent);
    		InsertedElementAccessExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedElementAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElementAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedElementAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedElementAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedElementAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedElementAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedElementAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedElementAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedElementAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedElementAccessExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedElementAccessExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedElementAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedElementAccessExpressionCore(property, parent);
    		DeletedElementAccessExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedElementAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElementAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedElementAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedElementAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedElementAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedElementAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedElementAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedElementAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedElementAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedElementAccessExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedElementAccessExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedElementAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedElementAccessExpressionCore(oldElement, newElement);
    		UpdatedElementAccessExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedElementAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElementAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedElementAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedElementAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedElementAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedElementAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedElementAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedElementAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedElementAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedElementAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedElementAccessExpressionCore(property, oldParent, position, newParent);
    		MovedElementAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElementAccessExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementAccessExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElementAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedElementAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElementAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedElementAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElementAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElementAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedElementAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedElementAccessExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedElementAccessExpressionCore(property, oldParent, position, newParent);
    		MatchedElementAccessExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DeclarationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDeclarationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDeclarationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDeclarationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDeclarationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDeclarationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDeclarationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDeclarationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDeclarationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDeclarationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDeclarationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDeclarationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDeclarationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDeclarationExpressionCore(property, position, parent);
    		InsertedDeclarationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDeclarationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDeclarationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDeclarationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedDeclarationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDeclarationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDeclarationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDeclarationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedDeclarationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDeclarationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDeclarationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDeclarationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDeclarationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDeclarationExpressionCore(property, parent);
    		DeletedDeclarationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDeclarationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDeclarationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDeclarationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDeclarationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDeclarationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDeclarationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDeclarationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedDeclarationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDeclarationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDeclarationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDeclarationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDeclarationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDeclarationExpressionCore(oldElement, newElement);
    		UpdatedDeclarationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDeclarationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDeclarationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDeclarationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDeclarationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDeclarationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDeclarationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDeclarationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDeclarationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDeclarationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDeclarationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDeclarationExpressionCore(property, oldParent, position, newParent);
    		MovedDeclarationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDeclarationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDeclarationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDeclarationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDeclarationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDeclarationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDeclarationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDeclarationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDeclarationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDeclarationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDeclarationExpressionCore(property, oldParent, position, newParent);
    		MatchedDeclarationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CastExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCastExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCastExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCastExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCastExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCastExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCastExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCastExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCastExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCastExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCastExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCastExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCastExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCastExpressionCore(property, position, parent);
    		InsertedCastExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCastExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCastExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCastExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedCastExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCastExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCastExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCastExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedCastExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCastExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCastExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCastExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCastExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCastExpressionCore(property, parent);
    		DeletedCastExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCastExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCastExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCastExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCastExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCastExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCastExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCastExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedCastExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCastExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCastExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCastExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCastExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCastExpressionCore(oldElement, newElement);
    		UpdatedCastExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCastExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCastExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCastExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCastExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCastExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCastExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCastExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCastExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCastExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCastExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCastExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCastExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCastExpressionCore(property, oldParent, position, newParent);
    		MovedCastExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCastExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCastExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCastExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCastExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCastExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCastExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCastExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCastExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCastExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCastExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCastExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCastExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCastExpressionCore(property, oldParent, position, newParent);
    		MatchedCastExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region RefExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedRefExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedRefExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedRefExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedRefExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedRefExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedRefExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedRefExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedRefExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedRefExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedRefExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedRefExpressionCore(property, position, parent);
    		InsertedRefExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedRefExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedRefExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedRefExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedRefExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedRefExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedRefExpressionCore(property, parent);
    		DeletedRefExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedRefExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedRefExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedRefExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedRefExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedRefExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedRefExpressionCore(oldElement, newElement);
    		UpdatedRefExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedRefExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedRefExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedRefExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedRefExpressionCore(property, oldParent, position, newParent);
    		MovedRefExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedRefExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedRefExpressionCore(property, oldParent, position, newParent);
    		MatchedRefExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InitializerExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInitializerExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInitializerExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInitializerExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInitializerExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInitializerExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInitializerExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInitializerExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInitializerExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInitializerExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInitializerExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInitializerExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInitializerExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInitializerExpressionCore(property, position, parent);
    		InsertedInitializerExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInitializerExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInitializerExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInitializerExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedInitializerExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInitializerExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInitializerExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInitializerExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedInitializerExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInitializerExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInitializerExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInitializerExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInitializerExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInitializerExpressionCore(property, parent);
    		DeletedInitializerExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInitializerExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInitializerExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInitializerExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInitializerExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInitializerExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInitializerExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInitializerExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedInitializerExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInitializerExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInitializerExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInitializerExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInitializerExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInitializerExpressionCore(oldElement, newElement);
    		UpdatedInitializerExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInitializerExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInitializerExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInitializerExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInitializerExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInitializerExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInitializerExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInitializerExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInitializerExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInitializerExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInitializerExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInitializerExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInitializerExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInitializerExpressionCore(property, oldParent, position, newParent);
    		MovedInitializerExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInitializerExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInitializerExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInitializerExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInitializerExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInitializerExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInitializerExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInitializerExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInitializerExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInitializerExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInitializerExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInitializerExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInitializerExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInitializerExpressionCore(property, oldParent, position, newParent);
    		MatchedInitializerExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ObjectCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedObjectCreationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedObjectCreationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedObjectCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedObjectCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedObjectCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedObjectCreationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedObjectCreationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedObjectCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedObjectCreationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedObjectCreationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedObjectCreationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedObjectCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedObjectCreationExpressionCore(property, position, parent);
    		InsertedObjectCreationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedObjectCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedObjectCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedObjectCreationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedObjectCreationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedObjectCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedObjectCreationExpressionCore(property, parent);
    		DeletedObjectCreationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedObjectCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedObjectCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedObjectCreationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedObjectCreationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedObjectCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedObjectCreationExpressionCore(oldElement, newElement);
    		UpdatedObjectCreationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedObjectCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedObjectCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedObjectCreationExpressionCore(property, oldParent, position, newParent);
    		MovedObjectCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedObjectCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedObjectCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedObjectCreationExpressionCore(property, oldParent, position, newParent);
    		MatchedObjectCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AnonymousObjectCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAnonymousObjectCreationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousObjectCreationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAnonymousObjectCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAnonymousObjectCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAnonymousObjectCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAnonymousObjectCreationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAnonymousObjectCreationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAnonymousObjectCreationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAnonymousObjectCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAnonymousObjectCreationExpressionCore(property, position, parent);
    		InsertedAnonymousObjectCreationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAnonymousObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAnonymousObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedAnonymousObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAnonymousObjectCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedAnonymousObjectCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAnonymousObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAnonymousObjectCreationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAnonymousObjectCreationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAnonymousObjectCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAnonymousObjectCreationExpressionCore(property, parent);
    		DeletedAnonymousObjectCreationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAnonymousObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAnonymousObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAnonymousObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAnonymousObjectCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedAnonymousObjectCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAnonymousObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAnonymousObjectCreationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAnonymousObjectCreationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAnonymousObjectCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAnonymousObjectCreationExpressionCore(oldElement, newElement);
    		UpdatedAnonymousObjectCreationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAnonymousObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAnonymousObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAnonymousObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAnonymousObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAnonymousObjectCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAnonymousObjectCreationExpressionCore(property, oldParent, position, newParent);
    		MovedAnonymousObjectCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAnonymousObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAnonymousObjectCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAnonymousObjectCreationExpressionCore(property, oldParent, position, newParent);
    		MatchedAnonymousObjectCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArrayCreationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayCreationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArrayCreationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArrayCreationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArrayCreationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArrayCreationExpressionCore(property, position, parent);
    		InsertedArrayCreationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArrayCreationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArrayCreationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArrayCreationExpressionCore(property, parent);
    		DeletedArrayCreationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArrayCreationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArrayCreationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArrayCreationExpressionCore(oldElement, newElement);
    		UpdatedArrayCreationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MovedArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MatchedArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ImplicitArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedImplicitArrayCreationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedImplicitArrayCreationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedImplicitArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedImplicitArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedImplicitArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedImplicitArrayCreationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedImplicitArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedImplicitArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedImplicitArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedImplicitArrayCreationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedImplicitArrayCreationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedImplicitArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedImplicitArrayCreationExpressionCore(property, position, parent);
    		InsertedImplicitArrayCreationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedImplicitArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedImplicitArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedImplicitArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedImplicitArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedImplicitArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedImplicitArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedImplicitArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedImplicitArrayCreationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedImplicitArrayCreationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedImplicitArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedImplicitArrayCreationExpressionCore(property, parent);
    		DeletedImplicitArrayCreationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedImplicitArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedImplicitArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedImplicitArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedImplicitArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedImplicitArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedImplicitArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedImplicitArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedImplicitArrayCreationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedImplicitArrayCreationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedImplicitArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedImplicitArrayCreationExpressionCore(oldElement, newElement);
    		UpdatedImplicitArrayCreationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedImplicitArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedImplicitArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedImplicitArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedImplicitArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedImplicitArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedImplicitArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MovedImplicitArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedImplicitArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedImplicitArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedImplicitArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "NewKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedImplicitArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedImplicitArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedImplicitArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MatchedImplicitArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region StackAllocArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedStackAllocArrayCreationExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedStackAllocArrayCreationExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedStackAllocArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedStackAllocArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedStackAllocArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedStackAllocArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedStackAllocArrayCreationExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedStackAllocArrayCreationExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedStackAllocArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedStackAllocArrayCreationExpressionCore(property, position, parent);
    		InsertedStackAllocArrayCreationExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedStackAllocArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedStackAllocArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedStackAllocArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedStackAllocArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedStackAllocArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedStackAllocArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedStackAllocArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedStackAllocArrayCreationExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedStackAllocArrayCreationExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedStackAllocArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedStackAllocArrayCreationExpressionCore(property, parent);
    		DeletedStackAllocArrayCreationExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedStackAllocArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedStackAllocArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedStackAllocArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedStackAllocArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedStackAllocArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedStackAllocArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedStackAllocArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedStackAllocArrayCreationExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "StackAllocKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedStackAllocArrayCreationExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedStackAllocArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedStackAllocArrayCreationExpressionCore(oldElement, newElement);
    		UpdatedStackAllocArrayCreationExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedStackAllocArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedStackAllocArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedStackAllocArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedStackAllocArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedStackAllocArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedStackAllocArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MovedStackAllocArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedStackAllocArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedStackAllocArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedStackAllocArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedStackAllocArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedStackAllocArrayCreationExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedStackAllocArrayCreationExpressionCore(property, oldParent, position, newParent);
    		MatchedStackAllocArrayCreationExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region QueryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedQueryExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedQueryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedQueryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedQueryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedQueryExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQueryExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedQueryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedQueryExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedQueryExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedQueryExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedQueryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedQueryExpressionCore(property, position, parent);
    		InsertedQueryExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedQueryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedQueryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedQueryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedQueryExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedQueryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQueryExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedQueryExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedQueryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedQueryExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedQueryExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedQueryExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedQueryExpressionCore(property, parent);
    		DeletedQueryExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedQueryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedQueryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedQueryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedQueryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedQueryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQueryExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedQueryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedQueryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedQueryExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedQueryExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedQueryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedQueryExpressionCore(oldElement, newElement);
    		UpdatedQueryExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedQueryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedQueryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedQueryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedQueryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedQueryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQueryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedQueryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedQueryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedQueryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedQueryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedQueryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedQueryExpressionCore(property, oldParent, position, newParent);
    		MovedQueryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedQueryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedQueryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedQueryExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedQueryExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedQueryExpressionCore(property, oldParent, position, newParent);
    		MatchedQueryExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region OmittedArraySizeExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOmittedArraySizeExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOmittedArraySizeExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOmittedArraySizeExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOmittedArraySizeExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOmittedArraySizeExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOmittedArraySizeExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOmittedArraySizeExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOmittedArraySizeExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOmittedArraySizeExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOmittedArraySizeExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOmittedArraySizeExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOmittedArraySizeExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOmittedArraySizeExpressionCore(property, position, parent);
    		InsertedOmittedArraySizeExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOmittedArraySizeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOmittedArraySizeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOmittedArraySizeExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedOmittedArraySizeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOmittedArraySizeExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOmittedArraySizeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOmittedArraySizeExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedOmittedArraySizeExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOmittedArraySizeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOmittedArraySizeExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOmittedArraySizeExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOmittedArraySizeExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOmittedArraySizeExpressionCore(property, parent);
    		DeletedOmittedArraySizeExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOmittedArraySizeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOmittedArraySizeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOmittedArraySizeExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOmittedArraySizeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOmittedArraySizeExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOmittedArraySizeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOmittedArraySizeExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedOmittedArraySizeExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOmittedArraySizeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOmittedArraySizeExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOmittedArraySizeExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOmittedArraySizeExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOmittedArraySizeExpressionCore(oldElement, newElement);
    		UpdatedOmittedArraySizeExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOmittedArraySizeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOmittedArraySizeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOmittedArraySizeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOmittedArraySizeExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOmittedArraySizeExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOmittedArraySizeExpressionCore(property, oldParent, position, newParent);
    		MovedOmittedArraySizeExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOmittedArraySizeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOmittedArraySizeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOmittedArraySizeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOmittedArraySizeExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOmittedArraySizeExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOmittedArraySizeExpressionCore(property, oldParent, position, newParent);
    		MatchedOmittedArraySizeExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InterpolatedStringExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterpolatedStringExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolatedStringExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterpolatedStringExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterpolatedStringExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterpolatedStringExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterpolatedStringExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolatedStringExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterpolatedStringExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterpolatedStringExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterpolatedStringExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StringStartToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StringEndToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterpolatedStringExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterpolatedStringExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterpolatedStringExpressionCore(property, position, parent);
    		InsertedInterpolatedStringExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterpolatedStringExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolatedStringExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterpolatedStringExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterpolatedStringExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterpolatedStringExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterpolatedStringExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolatedStringExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedInterpolatedStringExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterpolatedStringExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterpolatedStringExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StringStartToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StringEndToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterpolatedStringExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterpolatedStringExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterpolatedStringExpressionCore(property, parent);
    		DeletedInterpolatedStringExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterpolatedStringExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolatedStringExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterpolatedStringExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterpolatedStringExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterpolatedStringExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterpolatedStringExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolatedStringExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterpolatedStringExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterpolatedStringExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterpolatedStringExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "StringStartToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "StringEndToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterpolatedStringExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterpolatedStringExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterpolatedStringExpressionCore(oldElement, newElement);
    		UpdatedInterpolatedStringExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterpolatedStringExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterpolatedStringExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterpolatedStringExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterpolatedStringExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StringStartToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StringEndToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterpolatedStringExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterpolatedStringExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterpolatedStringExpressionCore(property, oldParent, position, newParent);
    		MovedInterpolatedStringExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterpolatedStringExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolatedStringExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterpolatedStringExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "StringStartToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "StringEndToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterpolatedStringExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterpolatedStringExpressionCore(property, oldParent, position, newParent);
    		MatchedInterpolatedStringExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IsPatternExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIsPatternExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIsPatternExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIsPatternExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIsPatternExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIsPatternExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIsPatternExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIsPatternExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIsPatternExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIsPatternExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIsPatternExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIsPatternExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIsPatternExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIsPatternExpressionCore(property, position, parent);
    		InsertedIsPatternExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIsPatternExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIsPatternExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIsPatternExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedIsPatternExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIsPatternExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIsPatternExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIsPatternExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedIsPatternExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIsPatternExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIsPatternExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIsPatternExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIsPatternExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIsPatternExpressionCore(property, parent);
    		DeletedIsPatternExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIsPatternExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIsPatternExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIsPatternExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIsPatternExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIsPatternExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIsPatternExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIsPatternExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedIsPatternExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIsPatternExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIsPatternExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "IsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIsPatternExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIsPatternExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIsPatternExpressionCore(oldElement, newElement);
    		UpdatedIsPatternExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIsPatternExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIsPatternExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIsPatternExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIsPatternExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIsPatternExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIsPatternExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIsPatternExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIsPatternExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIsPatternExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIsPatternExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIsPatternExpressionCore(property, oldParent, position, newParent);
    		MovedIsPatternExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIsPatternExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIsPatternExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIsPatternExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIsPatternExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIsPatternExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIsPatternExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIsPatternExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIsPatternExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIsPatternExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIsPatternExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIsPatternExpressionCore(property, oldParent, position, newParent);
    		MatchedIsPatternExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ThrowExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedThrowExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThrowExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedThrowExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedThrowExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedThrowExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedThrowExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThrowExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedThrowExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedThrowExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedThrowExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedThrowExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedThrowExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedThrowExpressionCore(property, position, parent);
    		InsertedThrowExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedThrowExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThrowExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedThrowExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedThrowExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedThrowExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedThrowExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThrowExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedThrowExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedThrowExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedThrowExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedThrowExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedThrowExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedThrowExpressionCore(property, parent);
    		DeletedThrowExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedThrowExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThrowExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedThrowExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedThrowExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedThrowExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedThrowExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThrowExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedThrowExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedThrowExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedThrowExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedThrowExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedThrowExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedThrowExpressionCore(oldElement, newElement);
    		UpdatedThrowExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedThrowExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThrowExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedThrowExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedThrowExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedThrowExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedThrowExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThrowExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedThrowExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedThrowExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedThrowExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedThrowExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedThrowExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedThrowExpressionCore(property, oldParent, position, newParent);
    		MovedThrowExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThrowExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThrowExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedThrowExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThrowExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThrowExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedThrowExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThrowExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThrowExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedThrowExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedThrowExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedThrowExpressionCore(property, oldParent, position, newParent);
    		MatchedThrowExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PredefinedType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPredefinedType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPredefinedType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPredefinedTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPredefinedType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPredefinedTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPredefinedTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPredefinedTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPredefinedTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPredefinedType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPredefinedTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPredefinedType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPredefinedTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPredefinedTypeCore(property, position, parent);
    		InsertedPredefinedTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPredefinedType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPredefinedType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPredefinedTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedPredefinedType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPredefinedTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPredefinedTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPredefinedTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedPredefinedTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPredefinedType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPredefinedTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPredefinedType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPredefinedTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPredefinedTypeCore(property, parent);
    		DeletedPredefinedTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPredefinedType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPredefinedType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPredefinedTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPredefinedType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPredefinedTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPredefinedTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPredefinedTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedPredefinedTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPredefinedType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPredefinedTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPredefinedType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPredefinedTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPredefinedTypeCore(oldElement, newElement);
    		UpdatedPredefinedTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPredefinedType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPredefinedType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPredefinedTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPredefinedType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPredefinedTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPredefinedTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPredefinedTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPredefinedTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPredefinedType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPredefinedTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPredefinedType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPredefinedTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPredefinedTypeCore(property, oldParent, position, newParent);
    		MovedPredefinedTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPredefinedType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPredefinedType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPredefinedTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPredefinedType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPredefinedTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPredefinedTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPredefinedTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPredefinedTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPredefinedType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPredefinedTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPredefinedType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPredefinedTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPredefinedTypeCore(property, oldParent, position, newParent);
    		MatchedPredefinedTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ArrayType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArrayType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArrayTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArrayType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArrayTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArrayTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArrayTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArrayTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArrayType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArrayTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArrayType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArrayTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArrayTypeCore(property, position, parent);
    		InsertedArrayTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArrayType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArrayTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedArrayType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArrayTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArrayTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArrayTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedArrayTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArrayType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArrayTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArrayType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArrayTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArrayTypeCore(property, parent);
    		DeletedArrayTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArrayType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArrayTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArrayType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArrayTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArrayTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArrayTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedArrayTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArrayType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArrayTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArrayType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArrayTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArrayTypeCore(oldElement, newElement);
    		UpdatedArrayTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArrayType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArrayTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArrayType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArrayTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArrayTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArrayTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArrayTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArrayType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArrayTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArrayType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArrayTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArrayTypeCore(property, oldParent, position, newParent);
    		MovedArrayTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArrayType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArrayTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArrayType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArrayTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArrayTypeCore(property, oldParent, position, newParent);
    		MatchedArrayTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region PointerType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedPointerType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPointerType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedPointerTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedPointerType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedPointerTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedPointerTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedPointerTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedPointerTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedPointerType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedPointerTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsteriskToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedPointerType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedPointerTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedPointerTypeCore(property, position, parent);
    		InsertedPointerTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedPointerType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPointerType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedPointerTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedPointerType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedPointerTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedPointerTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedPointerTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedPointerTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedPointerType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedPointerTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsteriskToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedPointerType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedPointerTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedPointerTypeCore(property, parent);
    		DeletedPointerTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedPointerType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPointerType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedPointerTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedPointerType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedPointerTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedPointerTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedPointerTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedPointerTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedPointerType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedPointerTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AsteriskToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedPointerType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedPointerTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedPointerTypeCore(oldElement, newElement);
    		UpdatedPointerTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedPointerType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPointerType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedPointerTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedPointerType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedPointerTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedPointerTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedPointerTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedPointerTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedPointerType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedPointerTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsteriskToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedPointerType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedPointerTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedPointerTypeCore(property, oldParent, position, newParent);
    		MovedPointerTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPointerType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPointerType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPointerTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedPointerType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPointerTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPointerTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPointerTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedPointerTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPointerType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPointerTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsteriskToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedPointerType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedPointerTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedPointerTypeCore(property, oldParent, position, newParent);
    		MatchedPointerTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region NullableType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedNullableType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNullableType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedNullableTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedNullableType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedNullableTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedNullableTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedNullableTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedNullableTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedNullableType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedNullableTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedNullableType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedNullableTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedNullableTypeCore(property, position, parent);
    		InsertedNullableTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedNullableType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNullableType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedNullableTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedNullableType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedNullableTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedNullableTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedNullableTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedNullableTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedNullableType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedNullableTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedNullableType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedNullableTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedNullableTypeCore(property, parent);
    		DeletedNullableTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedNullableType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNullableType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedNullableTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedNullableType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedNullableTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedNullableTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedNullableTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedNullableTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedNullableType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedNullableTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedNullableType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedNullableTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedNullableTypeCore(oldElement, newElement);
    		UpdatedNullableTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedNullableType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNullableType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedNullableTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedNullableType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedNullableTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedNullableTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedNullableTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedNullableTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedNullableType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedNullableTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedNullableType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedNullableTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedNullableTypeCore(property, oldParent, position, newParent);
    		MovedNullableTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNullableType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNullableType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNullableTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedNullableType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNullableTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNullableTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNullableTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedNullableTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNullableType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNullableTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "QuestionToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedNullableType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedNullableTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedNullableTypeCore(property, oldParent, position, newParent);
    		MatchedNullableTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TupleType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTupleType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTupleTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTupleType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTupleTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTupleTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTupleTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTupleTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTupleType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTupleTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTupleType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTupleTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTupleTypeCore(property, position, parent);
    		InsertedTupleTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTupleType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTupleTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedTupleType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTupleTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTupleTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTupleTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedTupleTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTupleType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTupleTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTupleType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTupleTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTupleTypeCore(property, parent);
    		DeletedTupleTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTupleType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTupleTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTupleType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTupleTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTupleTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTupleTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedTupleTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTupleType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTupleTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTupleType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTupleTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTupleTypeCore(oldElement, newElement);
    		UpdatedTupleTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTupleType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTupleTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTupleType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTupleTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTupleTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTupleTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTupleTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTupleType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTupleTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTupleType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTupleTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTupleTypeCore(property, oldParent, position, newParent);
    		MovedTupleTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTupleType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTupleTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTupleType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTupleTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTupleTypeCore(property, oldParent, position, newParent);
    		MatchedTupleTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region OmittedTypeArgument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOmittedTypeArgument(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOmittedTypeArgument(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOmittedTypeArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOmittedTypeArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOmittedTypeArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOmittedTypeArgumentCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOmittedTypeArgumentCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOmittedTypeArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOmittedTypeArgument(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOmittedTypeArgumentCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOmittedTypeArgument(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOmittedTypeArgumentBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOmittedTypeArgumentCore(property, position, parent);
    		InsertedOmittedTypeArgumentAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOmittedTypeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOmittedTypeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOmittedTypeArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedOmittedTypeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOmittedTypeArgumentBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOmittedTypeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOmittedTypeArgumentCore(XElement, XElement)"/>.</param>
        partial void DeletedOmittedTypeArgumentAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOmittedTypeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOmittedTypeArgumentCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOmittedTypeArgument(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOmittedTypeArgumentBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOmittedTypeArgumentCore(property, parent);
    		DeletedOmittedTypeArgumentAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOmittedTypeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOmittedTypeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOmittedTypeArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOmittedTypeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOmittedTypeArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOmittedTypeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOmittedTypeArgumentCore(XElement, XElement)"/>.</param>
        partial void UpdatedOmittedTypeArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOmittedTypeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOmittedTypeArgumentCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OmittedTypeArgumentToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOmittedTypeArgument(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOmittedTypeArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOmittedTypeArgumentCore(oldElement, newElement);
    		UpdatedOmittedTypeArgumentAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOmittedTypeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOmittedTypeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOmittedTypeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOmittedTypeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOmittedTypeArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOmittedTypeArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOmittedTypeArgumentCore(property, oldParent, position, newParent);
    		MovedOmittedTypeArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOmittedTypeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOmittedTypeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOmittedTypeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOmittedTypeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOmittedTypeArgument(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOmittedTypeArgumentBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOmittedTypeArgumentCore(property, oldParent, position, newParent);
    		MatchedOmittedTypeArgumentAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region RefType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedRefType(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefType(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedRefTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedRefType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedRefTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedRefTypeCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedRefTypeCore(XElement, int, XElement)"/>.</param>
        partial void InsertedRefTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedRefType(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedRefTypeCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedRefType(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedRefTypeBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedRefTypeCore(property, position, parent);
    		InsertedRefTypeAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedRefType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedRefTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedRefType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedRefTypeBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedRefTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedRefTypeCore(XElement, XElement)"/>.</param>
        partial void DeletedRefTypeAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedRefType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedRefTypeCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedRefType(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedRefTypeBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedRefTypeCore(property, parent);
    		DeletedRefTypeAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedRefType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedRefTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedRefType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedRefTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedRefTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedRefTypeCore(XElement, XElement)"/>.</param>
        partial void UpdatedRefTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedRefType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedRefTypeCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ReadOnlyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedRefType(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedRefTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedRefTypeCore(oldElement, newElement);
    		UpdatedRefTypeAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedRefType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedRefTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedRefType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedRefTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedRefTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedRefTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedRefTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedRefType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedRefTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedRefType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedRefTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedRefTypeCore(property, oldParent, position, newParent);
    		MovedRefTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefType(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefType(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedRefType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefTypeCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedRefTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefType(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "RefKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedRefType(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedRefTypeBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedRefTypeCore(property, oldParent, position, newParent);
    		MatchedRefTypeAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region QualifiedName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedQualifiedName(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQualifiedName(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedQualifiedNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedQualifiedName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedQualifiedNameBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedQualifiedNameCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedQualifiedNameCore(XElement, int, XElement)"/>.</param>
        partial void InsertedQualifiedNameAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedQualifiedName(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedQualifiedNameCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedQualifiedName(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedQualifiedNameBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedQualifiedNameCore(property, position, parent);
    		InsertedQualifiedNameAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedQualifiedNameBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void DeletedQualifiedNameAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedQualifiedNameCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedQualifiedName(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedQualifiedNameBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedQualifiedNameCore(property, parent);
    		DeletedQualifiedNameAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedQualifiedNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void UpdatedQualifiedNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedQualifiedNameCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedQualifiedName(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedQualifiedNameBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedQualifiedNameCore(oldElement, newElement);
    		UpdatedQualifiedNameAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedQualifiedName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQualifiedName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedQualifiedNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedQualifiedNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedQualifiedNameCore(property, oldParent, position, newParent);
    		MovedQualifiedNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQualifiedName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQualifiedNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DotToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedQualifiedNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedQualifiedNameCore(property, oldParent, position, newParent);
    		MatchedQualifiedNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AliasQualifiedName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAliasQualifiedName(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAliasQualifiedName(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAliasQualifiedNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAliasQualifiedName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAliasQualifiedNameBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAliasQualifiedNameCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAliasQualifiedNameCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAliasQualifiedNameAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAliasQualifiedName(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAliasQualifiedNameCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAliasQualifiedName(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAliasQualifiedNameBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAliasQualifiedNameCore(property, position, parent);
    		InsertedAliasQualifiedNameAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAliasQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAliasQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAliasQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedAliasQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAliasQualifiedNameBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAliasQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAliasQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void DeletedAliasQualifiedNameAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAliasQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAliasQualifiedNameCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAliasQualifiedName(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAliasQualifiedNameBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAliasQualifiedNameCore(property, parent);
    		DeletedAliasQualifiedNameAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAliasQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAliasQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAliasQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAliasQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAliasQualifiedNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAliasQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAliasQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void UpdatedAliasQualifiedNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAliasQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAliasQualifiedNameCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAliasQualifiedName(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAliasQualifiedNameBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAliasQualifiedNameCore(oldElement, newElement);
    		UpdatedAliasQualifiedNameAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAliasQualifiedName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAliasQualifiedName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAliasQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAliasQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAliasQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAliasQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAliasQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAliasQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAliasQualifiedNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAliasQualifiedNameCore(property, oldParent, position, newParent);
    		MovedAliasQualifiedNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAliasQualifiedName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAliasQualifiedName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAliasQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAliasQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAliasQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAliasQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAliasQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAliasQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAliasQualifiedNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAliasQualifiedNameCore(property, oldParent, position, newParent);
    		MatchedAliasQualifiedNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IdentifierName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIdentifierName(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIdentifierName(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIdentifierNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIdentifierName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIdentifierNameBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIdentifierNameCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIdentifierNameCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIdentifierNameAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIdentifierName(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIdentifierNameCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIdentifierName(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIdentifierNameBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIdentifierNameCore(property, position, parent);
    		InsertedIdentifierNameAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIdentifierName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIdentifierName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIdentifierNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedIdentifierName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIdentifierNameBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIdentifierNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIdentifierNameCore(XElement, XElement)"/>.</param>
        partial void DeletedIdentifierNameAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIdentifierName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIdentifierNameCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIdentifierName(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIdentifierNameBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIdentifierNameCore(property, parent);
    		DeletedIdentifierNameAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIdentifierName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIdentifierName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIdentifierNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIdentifierName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIdentifierNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIdentifierNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIdentifierNameCore(XElement, XElement)"/>.</param>
        partial void UpdatedIdentifierNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIdentifierName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIdentifierNameCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIdentifierName(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIdentifierNameBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIdentifierNameCore(oldElement, newElement);
    		UpdatedIdentifierNameAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIdentifierName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIdentifierName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIdentifierNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIdentifierName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIdentifierNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIdentifierNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIdentifierNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIdentifierNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIdentifierName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIdentifierNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIdentifierName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIdentifierNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIdentifierNameCore(property, oldParent, position, newParent);
    		MovedIdentifierNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIdentifierName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIdentifierName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIdentifierNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIdentifierName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIdentifierNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIdentifierNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIdentifierNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIdentifierNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIdentifierName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIdentifierNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIdentifierName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIdentifierNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIdentifierNameCore(property, oldParent, position, newParent);
    		MatchedIdentifierNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region GenericName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedGenericName(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGenericName(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedGenericNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedGenericName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedGenericNameBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedGenericNameCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGenericNameCore(XElement, int, XElement)"/>.</param>
        partial void InsertedGenericNameAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedGenericName(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedGenericNameCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedGenericName(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedGenericNameBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedGenericNameCore(property, position, parent);
    		InsertedGenericNameAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedGenericName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGenericName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedGenericNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedGenericName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedGenericNameBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedGenericNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGenericNameCore(XElement, XElement)"/>.</param>
        partial void DeletedGenericNameAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedGenericName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedGenericNameCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedGenericName(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedGenericNameBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedGenericNameCore(property, parent);
    		DeletedGenericNameAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedGenericName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGenericName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedGenericNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedGenericName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedGenericNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedGenericNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGenericNameCore(XElement, XElement)"/>.</param>
        partial void UpdatedGenericNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedGenericName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedGenericNameCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedGenericName(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedGenericNameBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedGenericNameCore(oldElement, newElement);
    		UpdatedGenericNameAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedGenericName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGenericName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedGenericNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedGenericName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedGenericNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedGenericNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGenericNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedGenericNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedGenericName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedGenericNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedGenericName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedGenericNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedGenericNameCore(property, oldParent, position, newParent);
    		MovedGenericNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGenericName(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGenericName(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGenericNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedGenericName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGenericNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGenericNameCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGenericNameCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedGenericNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGenericName(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGenericNameCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedGenericName(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedGenericNameBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedGenericNameCore(property, oldParent, position, newParent);
    		MatchedGenericNameAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ThisExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedThisExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThisExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedThisExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedThisExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedThisExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedThisExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThisExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedThisExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedThisExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedThisExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedThisExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedThisExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedThisExpressionCore(property, position, parent);
    		InsertedThisExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedThisExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThisExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedThisExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedThisExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedThisExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedThisExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThisExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedThisExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedThisExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedThisExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedThisExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedThisExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedThisExpressionCore(property, parent);
    		DeletedThisExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedThisExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThisExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedThisExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedThisExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedThisExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedThisExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThisExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedThisExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedThisExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedThisExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedThisExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedThisExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedThisExpressionCore(oldElement, newElement);
    		UpdatedThisExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedThisExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThisExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedThisExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedThisExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedThisExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedThisExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThisExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedThisExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedThisExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedThisExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedThisExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedThisExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedThisExpressionCore(property, oldParent, position, newParent);
    		MovedThisExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThisExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThisExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThisExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedThisExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThisExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThisExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThisExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedThisExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThisExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThisExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedThisExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedThisExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedThisExpressionCore(property, oldParent, position, newParent);
    		MatchedThisExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BaseExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBaseExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBaseExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBaseExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBaseExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBaseExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBaseExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBaseExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBaseExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBaseExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBaseExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBaseExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBaseExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBaseExpressionCore(property, position, parent);
    		InsertedBaseExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBaseExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBaseExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBaseExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedBaseExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBaseExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBaseExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBaseExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedBaseExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBaseExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBaseExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBaseExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBaseExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBaseExpressionCore(property, parent);
    		DeletedBaseExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBaseExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBaseExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBaseExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBaseExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBaseExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBaseExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBaseExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedBaseExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBaseExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBaseExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBaseExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBaseExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBaseExpressionCore(oldElement, newElement);
    		UpdatedBaseExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBaseExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBaseExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBaseExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBaseExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBaseExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBaseExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBaseExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBaseExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBaseExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBaseExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBaseExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBaseExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBaseExpressionCore(property, oldParent, position, newParent);
    		MovedBaseExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBaseExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBaseExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBaseExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBaseExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBaseExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBaseExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBaseExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBaseExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Token")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBaseExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBaseExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBaseExpressionCore(property, oldParent, position, newParent);
    		MatchedBaseExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region AnonymousMethodExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedAnonymousMethodExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousMethodExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedAnonymousMethodExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedAnonymousMethodExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedAnonymousMethodExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedAnonymousMethodExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedAnonymousMethodExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedAnonymousMethodExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedAnonymousMethodExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedAnonymousMethodExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedAnonymousMethodExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedAnonymousMethodExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedAnonymousMethodExpressionCore(property, position, parent);
    		InsertedAnonymousMethodExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedAnonymousMethodExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousMethodExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedAnonymousMethodExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedAnonymousMethodExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedAnonymousMethodExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedAnonymousMethodExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedAnonymousMethodExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedAnonymousMethodExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedAnonymousMethodExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedAnonymousMethodExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedAnonymousMethodExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedAnonymousMethodExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedAnonymousMethodExpressionCore(property, parent);
    		DeletedAnonymousMethodExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedAnonymousMethodExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousMethodExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedAnonymousMethodExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedAnonymousMethodExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedAnonymousMethodExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedAnonymousMethodExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedAnonymousMethodExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedAnonymousMethodExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedAnonymousMethodExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedAnonymousMethodExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedAnonymousMethodExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedAnonymousMethodExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedAnonymousMethodExpressionCore(oldElement, newElement);
    		UpdatedAnonymousMethodExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedAnonymousMethodExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedAnonymousMethodExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedAnonymousMethodExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedAnonymousMethodExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedAnonymousMethodExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedAnonymousMethodExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedAnonymousMethodExpressionCore(property, oldParent, position, newParent);
    		MovedAnonymousMethodExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedAnonymousMethodExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousMethodExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedAnonymousMethodExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousMethodExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "DelegateKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousMethodExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedAnonymousMethodExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedAnonymousMethodExpressionCore(property, oldParent, position, newParent);
    		MatchedAnonymousMethodExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SimpleLambdaExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSimpleLambdaExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSimpleLambdaExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSimpleLambdaExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSimpleLambdaExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSimpleLambdaExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSimpleLambdaExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSimpleLambdaExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSimpleLambdaExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSimpleLambdaExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSimpleLambdaExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSimpleLambdaExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSimpleLambdaExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSimpleLambdaExpressionCore(property, position, parent);
    		InsertedSimpleLambdaExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSimpleLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSimpleLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSimpleLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedSimpleLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSimpleLambdaExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSimpleLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSimpleLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedSimpleLambdaExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSimpleLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSimpleLambdaExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSimpleLambdaExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSimpleLambdaExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSimpleLambdaExpressionCore(property, parent);
    		DeletedSimpleLambdaExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSimpleLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSimpleLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSimpleLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSimpleLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSimpleLambdaExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSimpleLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSimpleLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedSimpleLambdaExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSimpleLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSimpleLambdaExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSimpleLambdaExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSimpleLambdaExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSimpleLambdaExpressionCore(oldElement, newElement);
    		UpdatedSimpleLambdaExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSimpleLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSimpleLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSimpleLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSimpleLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSimpleLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSimpleLambdaExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSimpleLambdaExpressionCore(property, oldParent, position, newParent);
    		MovedSimpleLambdaExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSimpleLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSimpleLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSimpleLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSimpleLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSimpleLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSimpleLambdaExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSimpleLambdaExpressionCore(property, oldParent, position, newParent);
    		MatchedSimpleLambdaExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ParenthesizedLambdaExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedParenthesizedLambdaExpression(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedLambdaExpression(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedParenthesizedLambdaExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedParenthesizedLambdaExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedParenthesizedLambdaExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedParenthesizedLambdaExpressionCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedLambdaExpressionCore(XElement, int, XElement)"/>.</param>
        partial void InsertedParenthesizedLambdaExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedParenthesizedLambdaExpression(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedParenthesizedLambdaExpressionCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedParenthesizedLambdaExpression(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedParenthesizedLambdaExpressionBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedParenthesizedLambdaExpressionCore(property, position, parent);
    		InsertedParenthesizedLambdaExpressionAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedParenthesizedLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedParenthesizedLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedParenthesizedLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedParenthesizedLambdaExpressionBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void DeletedParenthesizedLambdaExpressionAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedParenthesizedLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedParenthesizedLambdaExpressionCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedParenthesizedLambdaExpression(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedParenthesizedLambdaExpressionBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedParenthesizedLambdaExpressionCore(property, parent);
    		DeletedParenthesizedLambdaExpressionAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedParenthesizedLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedParenthesizedLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedParenthesizedLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedParenthesizedLambdaExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void UpdatedParenthesizedLambdaExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedParenthesizedLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedParenthesizedLambdaExpressionCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedParenthesizedLambdaExpression(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedParenthesizedLambdaExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedParenthesizedLambdaExpressionCore(oldElement, newElement);
    		UpdatedParenthesizedLambdaExpressionAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedParenthesizedLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedParenthesizedLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedParenthesizedLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedParenthesizedLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedParenthesizedLambdaExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedParenthesizedLambdaExpressionCore(property, oldParent, position, newParent);
    		MovedParenthesizedLambdaExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedParenthesizedLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "AsyncKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ArrowToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedParenthesizedLambdaExpressionBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedParenthesizedLambdaExpressionCore(property, oldParent, position, newParent);
    		MatchedParenthesizedLambdaExpressionAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedArgumentList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArgumentList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedArgumentListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedArgumentListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedArgumentList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedArgumentListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedArgumentList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedArgumentListCore(property, position, parent);
    		InsertedArgumentListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedArgumentListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedArgumentListCore(XElement, XElement)"/>.</param>
        partial void DeletedArgumentListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedArgumentListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedArgumentList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedArgumentListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedArgumentListCore(property, parent);
    		DeletedArgumentListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedArgumentListCore(XElement, XElement)"/>.</param>
        partial void UpdatedArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedArgumentListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedArgumentList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedArgumentListCore(oldElement, newElement);
    		UpdatedArgumentListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedArgumentListCore(property, oldParent, position, newParent);
    		MovedArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedArgumentListCore(property, oldParent, position, newParent);
    		MatchedArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BracketedArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBracketedArgumentList(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBracketedArgumentList(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBracketedArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBracketedArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBracketedArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBracketedArgumentListCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBracketedArgumentListCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBracketedArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBracketedArgumentList(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBracketedArgumentListCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBracketedArgumentList(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBracketedArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBracketedArgumentListCore(property, position, parent);
    		InsertedBracketedArgumentListAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBracketedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBracketedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBracketedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedBracketedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBracketedArgumentListBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBracketedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBracketedArgumentListCore(XElement, XElement)"/>.</param>
        partial void DeletedBracketedArgumentListAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBracketedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBracketedArgumentListCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBracketedArgumentList(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBracketedArgumentListBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBracketedArgumentListCore(property, parent);
    		DeletedBracketedArgumentListAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBracketedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBracketedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBracketedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBracketedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBracketedArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBracketedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBracketedArgumentListCore(XElement, XElement)"/>.</param>
        partial void UpdatedBracketedArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBracketedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBracketedArgumentListCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBracketedArgumentList(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBracketedArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBracketedArgumentListCore(oldElement, newElement);
    		UpdatedBracketedArgumentListAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBracketedArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBracketedArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBracketedArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBracketedArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBracketedArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBracketedArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBracketedArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBracketedArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBracketedArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBracketedArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBracketedArgumentListCore(property, oldParent, position, newParent);
    		MovedBracketedArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBracketedArgumentList(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedArgumentList(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBracketedArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBracketedArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBracketedArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBracketedArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBracketedArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBracketedArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBracketToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBracketedArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBracketedArgumentListBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBracketedArgumentListCore(property, oldParent, position, newParent);
    		MatchedBracketedArgumentListAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region FromClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedFromClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedFromClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedFromClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedFromClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedFromClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedFromClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedFromClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FromKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedFromClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedFromClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedFromClauseCore(property, position, parent);
    		InsertedFromClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedFromClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedFromClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedFromClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedFromClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedFromClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedFromClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedFromClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FromKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedFromClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedFromClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedFromClauseCore(property, parent);
    		DeletedFromClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedFromClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedFromClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedFromClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedFromClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "FromKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedFromClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedFromClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedFromClauseCore(oldElement, newElement);
    		UpdatedFromClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedFromClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedFromClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedFromClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedFromClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedFromClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedFromClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedFromClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FromKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedFromClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedFromClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedFromClauseCore(property, oldParent, position, newParent);
    		MovedFromClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFromClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFromClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFromClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedFromClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFromClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFromClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFromClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedFromClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFromClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFromClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FromKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedFromClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedFromClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedFromClauseCore(property, oldParent, position, newParent);
    		MatchedFromClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LetClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLetClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLetClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLetClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLetClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLetClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLetClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLetClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLetClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLetClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLetClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LetKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLetClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLetClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLetClauseCore(property, position, parent);
    		InsertedLetClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLetClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLetClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLetClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedLetClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLetClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLetClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLetClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedLetClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLetClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLetClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LetKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLetClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLetClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLetClauseCore(property, parent);
    		DeletedLetClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLetClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLetClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLetClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLetClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLetClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLetClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLetClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedLetClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLetClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLetClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LetKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLetClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLetClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLetClauseCore(oldElement, newElement);
    		UpdatedLetClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLetClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLetClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLetClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLetClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLetClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLetClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLetClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLetClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLetClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLetClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LetKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLetClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLetClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLetClauseCore(property, oldParent, position, newParent);
    		MovedLetClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLetClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLetClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLetClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLetClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLetClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLetClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLetClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLetClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLetClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLetClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LetKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLetClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLetClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLetClauseCore(property, oldParent, position, newParent);
    		MatchedLetClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region JoinClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedJoinClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedJoinClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedJoinClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedJoinClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedJoinClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedJoinClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedJoinClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedJoinClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedJoinClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedJoinClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "JoinKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedJoinClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedJoinClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedJoinClauseCore(property, position, parent);
    		InsertedJoinClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedJoinClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedJoinClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedJoinClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedJoinClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedJoinClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedJoinClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedJoinClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedJoinClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedJoinClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedJoinClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "JoinKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedJoinClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedJoinClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedJoinClauseCore(property, parent);
    		DeletedJoinClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedJoinClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedJoinClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedJoinClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedJoinClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedJoinClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedJoinClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedJoinClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedJoinClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedJoinClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedJoinClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "JoinKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "EqualsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedJoinClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedJoinClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedJoinClauseCore(oldElement, newElement);
    		UpdatedJoinClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedJoinClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedJoinClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedJoinClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedJoinClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedJoinClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedJoinClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedJoinClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedJoinClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedJoinClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedJoinClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "JoinKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedJoinClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedJoinClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedJoinClauseCore(property, oldParent, position, newParent);
    		MovedJoinClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedJoinClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedJoinClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedJoinClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedJoinClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedJoinClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedJoinClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedJoinClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedJoinClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "JoinKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "EqualsKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedJoinClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedJoinClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedJoinClauseCore(property, oldParent, position, newParent);
    		MatchedJoinClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region WhereClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedWhereClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhereClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedWhereClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedWhereClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedWhereClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedWhereClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhereClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedWhereClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedWhereClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedWhereClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedWhereClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedWhereClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedWhereClauseCore(property, position, parent);
    		InsertedWhereClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedWhereClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhereClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedWhereClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedWhereClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedWhereClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedWhereClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhereClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedWhereClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedWhereClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedWhereClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedWhereClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedWhereClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedWhereClauseCore(property, parent);
    		DeletedWhereClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedWhereClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhereClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedWhereClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedWhereClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedWhereClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedWhereClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhereClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedWhereClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedWhereClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedWhereClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedWhereClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedWhereClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedWhereClauseCore(oldElement, newElement);
    		UpdatedWhereClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedWhereClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhereClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedWhereClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedWhereClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedWhereClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedWhereClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhereClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedWhereClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedWhereClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedWhereClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedWhereClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedWhereClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedWhereClauseCore(property, oldParent, position, newParent);
    		MovedWhereClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhereClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhereClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhereClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedWhereClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhereClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhereClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhereClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedWhereClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhereClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhereClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhereKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedWhereClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedWhereClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedWhereClauseCore(property, oldParent, position, newParent);
    		MatchedWhereClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region OrderByClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedOrderByClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOrderByClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedOrderByClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedOrderByClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedOrderByClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedOrderByClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedOrderByClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedOrderByClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedOrderByClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedOrderByClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OrderByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedOrderByClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedOrderByClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedOrderByClauseCore(property, position, parent);
    		InsertedOrderByClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedOrderByClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOrderByClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedOrderByClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedOrderByClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedOrderByClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedOrderByClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedOrderByClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedOrderByClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedOrderByClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedOrderByClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OrderByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedOrderByClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedOrderByClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedOrderByClauseCore(property, parent);
    		DeletedOrderByClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedOrderByClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOrderByClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedOrderByClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedOrderByClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedOrderByClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedOrderByClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedOrderByClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedOrderByClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedOrderByClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedOrderByClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OrderByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedOrderByClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedOrderByClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedOrderByClauseCore(oldElement, newElement);
    		UpdatedOrderByClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedOrderByClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOrderByClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedOrderByClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedOrderByClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedOrderByClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedOrderByClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedOrderByClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedOrderByClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedOrderByClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedOrderByClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OrderByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedOrderByClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedOrderByClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedOrderByClauseCore(property, oldParent, position, newParent);
    		MovedOrderByClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOrderByClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderByClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOrderByClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedOrderByClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOrderByClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOrderByClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderByClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedOrderByClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOrderByClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOrderByClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OrderByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedOrderByClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedOrderByClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedOrderByClauseCore(property, oldParent, position, newParent);
    		MatchedOrderByClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SelectClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSelectClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSelectClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSelectClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSelectClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSelectClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSelectClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSelectClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSelectClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSelectClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSelectClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SelectKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSelectClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSelectClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSelectClauseCore(property, position, parent);
    		InsertedSelectClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSelectClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSelectClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSelectClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedSelectClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSelectClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSelectClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSelectClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedSelectClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSelectClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSelectClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SelectKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSelectClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSelectClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSelectClauseCore(property, parent);
    		DeletedSelectClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSelectClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSelectClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSelectClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSelectClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSelectClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSelectClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSelectClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedSelectClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSelectClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSelectClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SelectKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSelectClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSelectClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSelectClauseCore(oldElement, newElement);
    		UpdatedSelectClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSelectClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSelectClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSelectClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSelectClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSelectClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSelectClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSelectClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSelectClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSelectClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSelectClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SelectKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSelectClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSelectClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSelectClauseCore(property, oldParent, position, newParent);
    		MovedSelectClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSelectClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSelectClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSelectClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSelectClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSelectClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSelectClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSelectClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSelectClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSelectClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSelectClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SelectKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSelectClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSelectClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSelectClauseCore(property, oldParent, position, newParent);
    		MatchedSelectClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region GroupClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedGroupClause(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGroupClause(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedGroupClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedGroupClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedGroupClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedGroupClauseCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGroupClauseCore(XElement, int, XElement)"/>.</param>
        partial void InsertedGroupClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedGroupClause(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedGroupClauseCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GroupKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedGroupClause(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedGroupClauseBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedGroupClauseCore(property, position, parent);
    		InsertedGroupClauseAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedGroupClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGroupClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedGroupClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedGroupClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedGroupClauseBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedGroupClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGroupClauseCore(XElement, XElement)"/>.</param>
        partial void DeletedGroupClauseAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedGroupClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedGroupClauseCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GroupKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedGroupClause(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedGroupClauseBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedGroupClauseCore(property, parent);
    		DeletedGroupClauseAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedGroupClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGroupClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedGroupClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedGroupClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedGroupClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedGroupClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGroupClauseCore(XElement, XElement)"/>.</param>
        partial void UpdatedGroupClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedGroupClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedGroupClauseCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "GroupKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedGroupClause(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedGroupClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedGroupClauseCore(oldElement, newElement);
    		UpdatedGroupClauseAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedGroupClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGroupClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedGroupClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedGroupClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedGroupClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedGroupClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGroupClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedGroupClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedGroupClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedGroupClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GroupKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedGroupClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedGroupClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedGroupClauseCore(property, oldParent, position, newParent);
    		MovedGroupClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGroupClause(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGroupClause(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGroupClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedGroupClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGroupClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGroupClauseCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGroupClauseCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedGroupClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGroupClause(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGroupClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GroupKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ByKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedGroupClause(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedGroupClauseBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedGroupClauseCore(property, oldParent, position, newParent);
    		MatchedGroupClauseAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DeclarationPattern
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDeclarationPattern(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDeclarationPattern(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDeclarationPatternCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDeclarationPattern(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDeclarationPatternBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDeclarationPatternCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDeclarationPatternCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDeclarationPatternAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDeclarationPattern(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDeclarationPatternCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDeclarationPattern(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDeclarationPatternBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDeclarationPatternCore(property, position, parent);
    		InsertedDeclarationPatternAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDeclarationPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDeclarationPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDeclarationPatternCore(XElement, XElement)"/> is not executed and <see cref="DeletedDeclarationPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDeclarationPatternBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDeclarationPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDeclarationPatternCore(XElement, XElement)"/>.</param>
        partial void DeletedDeclarationPatternAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDeclarationPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDeclarationPatternCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDeclarationPattern(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDeclarationPatternBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDeclarationPatternCore(property, parent);
    		DeletedDeclarationPatternAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDeclarationPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDeclarationPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDeclarationPatternCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDeclarationPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDeclarationPatternBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDeclarationPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDeclarationPatternCore(XElement, XElement)"/>.</param>
        partial void UpdatedDeclarationPatternAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDeclarationPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDeclarationPatternCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDeclarationPattern(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDeclarationPatternBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDeclarationPatternCore(oldElement, newElement);
    		UpdatedDeclarationPatternAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDeclarationPattern(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDeclarationPattern(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDeclarationPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDeclarationPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDeclarationPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDeclarationPatternCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDeclarationPatternCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDeclarationPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDeclarationPattern(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDeclarationPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDeclarationPattern(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDeclarationPatternBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDeclarationPatternCore(property, oldParent, position, newParent);
    		MovedDeclarationPatternAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDeclarationPattern(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationPattern(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDeclarationPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDeclarationPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDeclarationPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDeclarationPatternCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationPatternCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDeclarationPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDeclarationPattern(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDeclarationPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDeclarationPattern(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDeclarationPatternBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDeclarationPatternCore(property, oldParent, position, newParent);
    		MatchedDeclarationPatternAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ConstantPattern
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedConstantPattern(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstantPattern(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedConstantPatternCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedConstantPattern(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedConstantPatternBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedConstantPatternCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedConstantPatternCore(XElement, int, XElement)"/>.</param>
        partial void InsertedConstantPatternAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedConstantPattern(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedConstantPatternCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedConstantPattern(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedConstantPatternBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedConstantPatternCore(property, position, parent);
    		InsertedConstantPatternAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedConstantPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstantPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedConstantPatternCore(XElement, XElement)"/> is not executed and <see cref="DeletedConstantPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedConstantPatternBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedConstantPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedConstantPatternCore(XElement, XElement)"/>.</param>
        partial void DeletedConstantPatternAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedConstantPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedConstantPatternCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedConstantPattern(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedConstantPatternBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedConstantPatternCore(property, parent);
    		DeletedConstantPatternAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedConstantPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstantPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedConstantPatternCore(XElement, XElement)"/> is not executed and <see cref="UpdatedConstantPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedConstantPatternBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedConstantPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedConstantPatternCore(XElement, XElement)"/>.</param>
        partial void UpdatedConstantPatternAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedConstantPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedConstantPatternCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedConstantPattern(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedConstantPatternBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedConstantPatternCore(oldElement, newElement);
    		UpdatedConstantPatternAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedConstantPattern(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstantPattern(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedConstantPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedConstantPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedConstantPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedConstantPatternCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedConstantPatternCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedConstantPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedConstantPattern(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedConstantPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedConstantPattern(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedConstantPatternBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedConstantPatternCore(property, oldParent, position, newParent);
    		MovedConstantPatternAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstantPattern(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstantPattern(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstantPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedConstantPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstantPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstantPatternCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstantPatternCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedConstantPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstantPattern(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstantPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedConstantPattern(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedConstantPatternBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedConstantPatternCore(property, oldParent, position, newParent);
    		MatchedConstantPatternAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region InterpolatedStringText
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterpolatedStringText(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolatedStringText(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterpolatedStringTextCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterpolatedStringText(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterpolatedStringTextBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterpolatedStringTextCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolatedStringTextCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterpolatedStringTextAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterpolatedStringText(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterpolatedStringTextCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterpolatedStringText(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterpolatedStringTextBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterpolatedStringTextCore(property, position, parent);
    		InsertedInterpolatedStringTextAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterpolatedStringText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolatedStringText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterpolatedStringTextCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterpolatedStringText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterpolatedStringTextBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterpolatedStringTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolatedStringTextCore(XElement, XElement)"/>.</param>
        partial void DeletedInterpolatedStringTextAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterpolatedStringText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterpolatedStringTextCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterpolatedStringText(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterpolatedStringTextBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterpolatedStringTextCore(property, parent);
    		DeletedInterpolatedStringTextAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterpolatedStringText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolatedStringText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterpolatedStringTextCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterpolatedStringText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterpolatedStringTextBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterpolatedStringTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolatedStringTextCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterpolatedStringTextAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterpolatedStringText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterpolatedStringTextCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterpolatedStringText(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterpolatedStringTextBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterpolatedStringTextCore(oldElement, newElement);
    		UpdatedInterpolatedStringTextAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterpolatedStringText(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolatedStringText(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterpolatedStringText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterpolatedStringTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterpolatedStringTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterpolatedStringText(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterpolatedStringTextCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterpolatedStringText(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterpolatedStringTextBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterpolatedStringTextCore(property, oldParent, position, newParent);
    		MovedInterpolatedStringTextAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolatedStringText(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringText(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterpolatedStringText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolatedStringTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterpolatedStringTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolatedStringText(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringTextCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringText(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterpolatedStringTextBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterpolatedStringTextCore(property, oldParent, position, newParent);
    		MatchedInterpolatedStringTextAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Interpolation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedInterpolation(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolation(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedInterpolationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedInterpolation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedInterpolationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedInterpolationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedInterpolationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedInterpolationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedInterpolation(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedInterpolationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedInterpolation(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedInterpolationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedInterpolationCore(property, position, parent);
    		InsertedInterpolationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedInterpolation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedInterpolationCore(XElement, XElement)"/> is not executed and <see cref="DeletedInterpolation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedInterpolationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedInterpolationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedInterpolationCore(XElement, XElement)"/>.</param>
        partial void DeletedInterpolationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedInterpolation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedInterpolationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedInterpolation(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedInterpolationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedInterpolationCore(property, parent);
    		DeletedInterpolationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedInterpolation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedInterpolationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedInterpolation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedInterpolationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedInterpolationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedInterpolationCore(XElement, XElement)"/>.</param>
        partial void UpdatedInterpolationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedInterpolation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedInterpolationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedInterpolation(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedInterpolationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedInterpolationCore(oldElement, newElement);
    		UpdatedInterpolationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedInterpolation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedInterpolationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedInterpolation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedInterpolationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedInterpolationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedInterpolationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedInterpolationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedInterpolation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedInterpolationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedInterpolation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedInterpolationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedInterpolationCore(property, oldParent, position, newParent);
    		MovedInterpolationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedInterpolation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedInterpolationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedInterpolationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedInterpolationCore(property, oldParent, position, newParent);
    		MatchedInterpolationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region Block
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBlock(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBlock(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBlockCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBlock(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBlockBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBlockCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBlockCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBlockAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBlock(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBlockCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBlock(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBlockBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBlockCore(property, position, parent);
    		InsertedBlockAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBlock(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBlock(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBlockCore(XElement, XElement)"/> is not executed and <see cref="DeletedBlock(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBlockBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBlockCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBlockCore(XElement, XElement)"/>.</param>
        partial void DeletedBlockAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBlock(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBlockCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBlock(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBlockBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBlockCore(property, parent);
    		DeletedBlockAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBlock(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBlock(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBlockCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBlock(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBlockBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBlockCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBlockCore(XElement, XElement)"/>.</param>
        partial void UpdatedBlockAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBlock(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBlockCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBlock(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBlockBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBlockCore(oldElement, newElement);
    		UpdatedBlockAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBlock(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBlock(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBlockCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBlock(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBlockBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBlockCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBlockCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBlockAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBlock(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBlockCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBlock(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBlockBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBlockCore(property, oldParent, position, newParent);
    		MovedBlockAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBlock(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBlock(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBlockCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBlock(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBlockBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBlockCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBlockCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBlockAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBlock(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBlockCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBlock(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBlockBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBlockCore(property, oldParent, position, newParent);
    		MatchedBlockAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LocalFunctionStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLocalFunctionStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLocalFunctionStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLocalFunctionStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLocalFunctionStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLocalFunctionStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLocalFunctionStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLocalFunctionStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLocalFunctionStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLocalFunctionStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLocalFunctionStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLocalFunctionStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLocalFunctionStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLocalFunctionStatementCore(property, position, parent);
    		InsertedLocalFunctionStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLocalFunctionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLocalFunctionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLocalFunctionStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedLocalFunctionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLocalFunctionStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLocalFunctionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLocalFunctionStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedLocalFunctionStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLocalFunctionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLocalFunctionStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLocalFunctionStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLocalFunctionStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLocalFunctionStatementCore(property, parent);
    		DeletedLocalFunctionStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLocalFunctionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLocalFunctionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLocalFunctionStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLocalFunctionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLocalFunctionStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLocalFunctionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLocalFunctionStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedLocalFunctionStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLocalFunctionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLocalFunctionStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLocalFunctionStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLocalFunctionStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLocalFunctionStatementCore(oldElement, newElement);
    		UpdatedLocalFunctionStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLocalFunctionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLocalFunctionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLocalFunctionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLocalFunctionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLocalFunctionStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLocalFunctionStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLocalFunctionStatementCore(property, oldParent, position, newParent);
    		MovedLocalFunctionStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLocalFunctionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLocalFunctionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLocalFunctionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLocalFunctionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLocalFunctionStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLocalFunctionStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLocalFunctionStatementCore(property, oldParent, position, newParent);
    		MatchedLocalFunctionStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LocalDeclarationStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLocalDeclarationStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLocalDeclarationStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLocalDeclarationStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLocalDeclarationStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLocalDeclarationStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLocalDeclarationStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLocalDeclarationStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLocalDeclarationStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLocalDeclarationStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLocalDeclarationStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLocalDeclarationStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLocalDeclarationStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLocalDeclarationStatementCore(property, position, parent);
    		InsertedLocalDeclarationStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLocalDeclarationStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLocalDeclarationStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLocalDeclarationStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedLocalDeclarationStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLocalDeclarationStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLocalDeclarationStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLocalDeclarationStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedLocalDeclarationStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLocalDeclarationStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLocalDeclarationStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLocalDeclarationStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLocalDeclarationStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLocalDeclarationStatementCore(property, parent);
    		DeletedLocalDeclarationStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLocalDeclarationStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLocalDeclarationStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLocalDeclarationStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLocalDeclarationStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLocalDeclarationStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLocalDeclarationStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLocalDeclarationStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedLocalDeclarationStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLocalDeclarationStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLocalDeclarationStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLocalDeclarationStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLocalDeclarationStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLocalDeclarationStatementCore(oldElement, newElement);
    		UpdatedLocalDeclarationStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLocalDeclarationStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLocalDeclarationStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLocalDeclarationStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLocalDeclarationStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLocalDeclarationStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLocalDeclarationStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLocalDeclarationStatementCore(property, oldParent, position, newParent);
    		MovedLocalDeclarationStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLocalDeclarationStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLocalDeclarationStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLocalDeclarationStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLocalDeclarationStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLocalDeclarationStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLocalDeclarationStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLocalDeclarationStatementCore(property, oldParent, position, newParent);
    		MatchedLocalDeclarationStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ExpressionStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedExpressionStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExpressionStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedExpressionStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedExpressionStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedExpressionStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedExpressionStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedExpressionStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedExpressionStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedExpressionStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedExpressionStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedExpressionStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedExpressionStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedExpressionStatementCore(property, position, parent);
    		InsertedExpressionStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedExpressionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExpressionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedExpressionStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedExpressionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedExpressionStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedExpressionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedExpressionStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedExpressionStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedExpressionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedExpressionStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedExpressionStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedExpressionStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedExpressionStatementCore(property, parent);
    		DeletedExpressionStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedExpressionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExpressionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedExpressionStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedExpressionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedExpressionStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedExpressionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedExpressionStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedExpressionStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedExpressionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedExpressionStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedExpressionStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedExpressionStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedExpressionStatementCore(oldElement, newElement);
    		UpdatedExpressionStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedExpressionStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExpressionStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedExpressionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedExpressionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedExpressionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedExpressionStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedExpressionStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedExpressionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedExpressionStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedExpressionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedExpressionStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedExpressionStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedExpressionStatementCore(property, oldParent, position, newParent);
    		MovedExpressionStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExpressionStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExpressionStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExpressionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedExpressionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExpressionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExpressionStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExpressionStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedExpressionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExpressionStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExpressionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedExpressionStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedExpressionStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedExpressionStatementCore(property, oldParent, position, newParent);
    		MatchedExpressionStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region EmptyStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedEmptyStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEmptyStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedEmptyStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedEmptyStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedEmptyStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedEmptyStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedEmptyStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedEmptyStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedEmptyStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedEmptyStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedEmptyStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedEmptyStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedEmptyStatementCore(property, position, parent);
    		InsertedEmptyStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedEmptyStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEmptyStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedEmptyStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedEmptyStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedEmptyStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedEmptyStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedEmptyStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedEmptyStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedEmptyStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedEmptyStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedEmptyStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedEmptyStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedEmptyStatementCore(property, parent);
    		DeletedEmptyStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedEmptyStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEmptyStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedEmptyStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedEmptyStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedEmptyStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedEmptyStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedEmptyStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedEmptyStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedEmptyStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedEmptyStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedEmptyStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedEmptyStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedEmptyStatementCore(oldElement, newElement);
    		UpdatedEmptyStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedEmptyStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEmptyStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedEmptyStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedEmptyStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedEmptyStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedEmptyStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedEmptyStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedEmptyStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedEmptyStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedEmptyStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedEmptyStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedEmptyStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedEmptyStatementCore(property, oldParent, position, newParent);
    		MovedEmptyStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEmptyStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEmptyStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEmptyStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedEmptyStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEmptyStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEmptyStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEmptyStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedEmptyStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEmptyStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEmptyStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedEmptyStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedEmptyStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedEmptyStatementCore(property, oldParent, position, newParent);
    		MatchedEmptyStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LabeledStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLabeledStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLabeledStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLabeledStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLabeledStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLabeledStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLabeledStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLabeledStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLabeledStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLabeledStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLabeledStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLabeledStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLabeledStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLabeledStatementCore(property, position, parent);
    		InsertedLabeledStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLabeledStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLabeledStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLabeledStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedLabeledStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLabeledStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLabeledStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLabeledStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedLabeledStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLabeledStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLabeledStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLabeledStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLabeledStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLabeledStatementCore(property, parent);
    		DeletedLabeledStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLabeledStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLabeledStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLabeledStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLabeledStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLabeledStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLabeledStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLabeledStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedLabeledStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLabeledStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLabeledStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLabeledStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLabeledStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLabeledStatementCore(oldElement, newElement);
    		UpdatedLabeledStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLabeledStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLabeledStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLabeledStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLabeledStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLabeledStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLabeledStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLabeledStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLabeledStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLabeledStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLabeledStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLabeledStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLabeledStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLabeledStatementCore(property, oldParent, position, newParent);
    		MovedLabeledStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLabeledStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLabeledStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLabeledStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLabeledStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLabeledStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLabeledStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLabeledStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLabeledStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLabeledStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLabeledStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLabeledStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLabeledStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLabeledStatementCore(property, oldParent, position, newParent);
    		MatchedLabeledStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region GotoStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedGotoStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGotoStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedGotoStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedGotoStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedGotoStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedGotoStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedGotoStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedGotoStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedGotoStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedGotoStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GotoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedGotoStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedGotoStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedGotoStatementCore(property, position, parent);
    		InsertedGotoStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedGotoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGotoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedGotoStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedGotoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedGotoStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedGotoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedGotoStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedGotoStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedGotoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedGotoStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GotoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedGotoStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedGotoStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedGotoStatementCore(property, parent);
    		DeletedGotoStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedGotoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGotoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedGotoStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedGotoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedGotoStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedGotoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedGotoStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedGotoStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedGotoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedGotoStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "GotoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CaseOrDefaultKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedGotoStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedGotoStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedGotoStatementCore(oldElement, newElement);
    		UpdatedGotoStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedGotoStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGotoStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedGotoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedGotoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedGotoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedGotoStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedGotoStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedGotoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedGotoStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedGotoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GotoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedGotoStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedGotoStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedGotoStatementCore(property, oldParent, position, newParent);
    		MovedGotoStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGotoStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGotoStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGotoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedGotoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGotoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGotoStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGotoStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedGotoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGotoStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGotoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "GotoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedGotoStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedGotoStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedGotoStatementCore(property, oldParent, position, newParent);
    		MatchedGotoStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region BreakStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedBreakStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBreakStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedBreakStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedBreakStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedBreakStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedBreakStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedBreakStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedBreakStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedBreakStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedBreakStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "BreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedBreakStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedBreakStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedBreakStatementCore(property, position, parent);
    		InsertedBreakStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedBreakStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBreakStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedBreakStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedBreakStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedBreakStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedBreakStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedBreakStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedBreakStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedBreakStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedBreakStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "BreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedBreakStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedBreakStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedBreakStatementCore(property, parent);
    		DeletedBreakStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedBreakStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBreakStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedBreakStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedBreakStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedBreakStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedBreakStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedBreakStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedBreakStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedBreakStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedBreakStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "BreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedBreakStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedBreakStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedBreakStatementCore(oldElement, newElement);
    		UpdatedBreakStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedBreakStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBreakStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedBreakStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedBreakStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedBreakStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedBreakStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedBreakStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedBreakStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedBreakStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedBreakStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "BreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedBreakStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedBreakStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedBreakStatementCore(property, oldParent, position, newParent);
    		MovedBreakStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBreakStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBreakStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBreakStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedBreakStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBreakStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBreakStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBreakStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedBreakStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBreakStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBreakStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "BreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedBreakStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedBreakStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedBreakStatementCore(property, oldParent, position, newParent);
    		MatchedBreakStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ContinueStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedContinueStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedContinueStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedContinueStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedContinueStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedContinueStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedContinueStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedContinueStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedContinueStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedContinueStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedContinueStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ContinueKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedContinueStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedContinueStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedContinueStatementCore(property, position, parent);
    		InsertedContinueStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedContinueStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedContinueStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedContinueStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedContinueStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedContinueStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedContinueStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedContinueStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedContinueStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedContinueStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedContinueStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ContinueKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedContinueStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedContinueStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedContinueStatementCore(property, parent);
    		DeletedContinueStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedContinueStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedContinueStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedContinueStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedContinueStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedContinueStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedContinueStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedContinueStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedContinueStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedContinueStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedContinueStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ContinueKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedContinueStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedContinueStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedContinueStatementCore(oldElement, newElement);
    		UpdatedContinueStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedContinueStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedContinueStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedContinueStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedContinueStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedContinueStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedContinueStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedContinueStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedContinueStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedContinueStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedContinueStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ContinueKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedContinueStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedContinueStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedContinueStatementCore(property, oldParent, position, newParent);
    		MovedContinueStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedContinueStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedContinueStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedContinueStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedContinueStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedContinueStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedContinueStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedContinueStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedContinueStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedContinueStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedContinueStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ContinueKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedContinueStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedContinueStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedContinueStatementCore(property, oldParent, position, newParent);
    		MatchedContinueStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ReturnStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedReturnStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedReturnStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedReturnStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedReturnStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedReturnStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedReturnStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedReturnStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedReturnStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedReturnStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedReturnStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ReturnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedReturnStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedReturnStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedReturnStatementCore(property, position, parent);
    		InsertedReturnStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedReturnStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedReturnStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedReturnStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedReturnStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedReturnStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedReturnStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedReturnStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedReturnStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedReturnStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedReturnStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ReturnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedReturnStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedReturnStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedReturnStatementCore(property, parent);
    		DeletedReturnStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedReturnStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedReturnStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedReturnStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedReturnStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedReturnStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedReturnStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedReturnStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedReturnStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedReturnStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedReturnStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ReturnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedReturnStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedReturnStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedReturnStatementCore(oldElement, newElement);
    		UpdatedReturnStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedReturnStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedReturnStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedReturnStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedReturnStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedReturnStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedReturnStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedReturnStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedReturnStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedReturnStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedReturnStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ReturnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedReturnStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedReturnStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedReturnStatementCore(property, oldParent, position, newParent);
    		MovedReturnStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedReturnStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReturnStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedReturnStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedReturnStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedReturnStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedReturnStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReturnStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedReturnStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedReturnStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedReturnStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ReturnKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedReturnStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedReturnStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedReturnStatementCore(property, oldParent, position, newParent);
    		MatchedReturnStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ThrowStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedThrowStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThrowStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedThrowStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedThrowStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedThrowStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedThrowStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedThrowStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedThrowStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedThrowStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedThrowStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedThrowStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedThrowStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedThrowStatementCore(property, position, parent);
    		InsertedThrowStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedThrowStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThrowStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedThrowStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedThrowStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedThrowStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedThrowStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedThrowStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedThrowStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedThrowStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedThrowStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedThrowStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedThrowStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedThrowStatementCore(property, parent);
    		DeletedThrowStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedThrowStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThrowStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedThrowStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedThrowStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedThrowStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedThrowStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedThrowStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedThrowStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedThrowStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedThrowStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedThrowStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedThrowStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedThrowStatementCore(oldElement, newElement);
    		UpdatedThrowStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedThrowStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThrowStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedThrowStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedThrowStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedThrowStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedThrowStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedThrowStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedThrowStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedThrowStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedThrowStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedThrowStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedThrowStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedThrowStatementCore(property, oldParent, position, newParent);
    		MovedThrowStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThrowStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThrowStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedThrowStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThrowStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThrowStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedThrowStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThrowStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThrowStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ThrowKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedThrowStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedThrowStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedThrowStatementCore(property, oldParent, position, newParent);
    		MatchedThrowStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region YieldStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedYieldStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedYieldStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedYieldStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedYieldStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedYieldStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedYieldStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedYieldStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedYieldStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedYieldStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedYieldStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "YieldKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedYieldStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedYieldStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedYieldStatementCore(property, position, parent);
    		InsertedYieldStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedYieldStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedYieldStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedYieldStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedYieldStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedYieldStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedYieldStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedYieldStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedYieldStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedYieldStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedYieldStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "YieldKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedYieldStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedYieldStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedYieldStatementCore(property, parent);
    		DeletedYieldStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedYieldStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedYieldStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedYieldStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedYieldStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedYieldStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedYieldStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedYieldStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedYieldStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedYieldStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedYieldStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "YieldKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ReturnOrBreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedYieldStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedYieldStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedYieldStatementCore(oldElement, newElement);
    		UpdatedYieldStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedYieldStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedYieldStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedYieldStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedYieldStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedYieldStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedYieldStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedYieldStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedYieldStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedYieldStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedYieldStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "YieldKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedYieldStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedYieldStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedYieldStatementCore(property, oldParent, position, newParent);
    		MovedYieldStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedYieldStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedYieldStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedYieldStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedYieldStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedYieldStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedYieldStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedYieldStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedYieldStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedYieldStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedYieldStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "YieldKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedYieldStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedYieldStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedYieldStatementCore(property, oldParent, position, newParent);
    		MatchedYieldStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region WhileStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedWhileStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhileStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedWhileStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedWhileStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedWhileStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedWhileStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedWhileStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedWhileStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedWhileStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedWhileStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedWhileStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedWhileStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedWhileStatementCore(property, position, parent);
    		InsertedWhileStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedWhileStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhileStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedWhileStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedWhileStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedWhileStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedWhileStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedWhileStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedWhileStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedWhileStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedWhileStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedWhileStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedWhileStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedWhileStatementCore(property, parent);
    		DeletedWhileStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedWhileStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhileStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedWhileStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedWhileStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedWhileStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedWhileStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedWhileStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedWhileStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedWhileStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedWhileStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedWhileStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedWhileStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedWhileStatementCore(oldElement, newElement);
    		UpdatedWhileStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedWhileStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhileStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedWhileStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedWhileStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedWhileStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedWhileStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedWhileStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedWhileStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedWhileStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedWhileStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedWhileStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedWhileStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedWhileStatementCore(property, oldParent, position, newParent);
    		MovedWhileStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhileStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhileStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhileStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedWhileStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhileStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhileStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhileStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedWhileStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhileStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhileStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedWhileStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedWhileStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedWhileStatementCore(property, oldParent, position, newParent);
    		MatchedWhileStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DoStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDoStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDoStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDoStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDoStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDoStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDoStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDoStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDoStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDoStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDoStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDoStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDoStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDoStatementCore(property, position, parent);
    		InsertedDoStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDoStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedDoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDoStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDoStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedDoStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDoStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDoStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDoStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDoStatementCore(property, parent);
    		DeletedDoStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDoStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDoStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDoStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedDoStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDoStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "DoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDoStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDoStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDoStatementCore(oldElement, newElement);
    		UpdatedDoStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDoStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDoStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDoStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDoStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDoStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDoStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDoStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDoStatementCore(property, oldParent, position, newParent);
    		MovedDoStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDoStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDoStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDoStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDoStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDoStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "DoKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "WhileKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDoStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDoStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDoStatementCore(property, oldParent, position, newParent);
    		MatchedDoStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ForStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedForStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedForStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedForStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedForStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedForStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedForStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedForStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedForStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedForStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedForStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedForStatementCore(property, position, parent);
    		InsertedForStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedForStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedForStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedForStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedForStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedForStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedForStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedForStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedForStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedForStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedForStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedForStatementCore(property, parent);
    		DeletedForStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedForStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedForStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedForStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedForStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedForStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedForStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedForStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedForStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ForKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "FirstSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "SecondSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedForStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedForStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedForStatementCore(oldElement, newElement);
    		UpdatedForStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedForStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedForStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedForStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedForStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedForStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedForStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedForStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedForStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedForStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedForStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedForStatementCore(property, oldParent, position, newParent);
    		MovedForStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedForStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedForStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedForStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedForStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedForStatementCore(property, oldParent, position, newParent);
    		MatchedForStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region UsingStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedUsingStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUsingStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedUsingStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedUsingStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedUsingStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedUsingStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUsingStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedUsingStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedUsingStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedUsingStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedUsingStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedUsingStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedUsingStatementCore(property, position, parent);
    		InsertedUsingStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedUsingStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUsingStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedUsingStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedUsingStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedUsingStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedUsingStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUsingStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedUsingStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedUsingStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedUsingStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedUsingStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedUsingStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedUsingStatementCore(property, parent);
    		DeletedUsingStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedUsingStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUsingStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedUsingStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedUsingStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedUsingStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedUsingStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUsingStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedUsingStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedUsingStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedUsingStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedUsingStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedUsingStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedUsingStatementCore(oldElement, newElement);
    		UpdatedUsingStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedUsingStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUsingStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedUsingStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedUsingStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedUsingStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedUsingStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUsingStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedUsingStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedUsingStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedUsingStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedUsingStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedUsingStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedUsingStatementCore(property, oldParent, position, newParent);
    		MovedUsingStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUsingStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUsingStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedUsingStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUsingStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUsingStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedUsingStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUsingStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUsingStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UsingKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedUsingStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedUsingStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedUsingStatementCore(property, oldParent, position, newParent);
    		MatchedUsingStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region FixedStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedFixedStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFixedStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedFixedStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFixedStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedFixedStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedFixedStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFixedStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedFixedStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedFixedStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedFixedStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FixedKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedFixedStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedFixedStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedFixedStatementCore(property, position, parent);
    		InsertedFixedStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedFixedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFixedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedFixedStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFixedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedFixedStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedFixedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFixedStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedFixedStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedFixedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedFixedStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FixedKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedFixedStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedFixedStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedFixedStatementCore(property, parent);
    		DeletedFixedStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedFixedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFixedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedFixedStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFixedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedFixedStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedFixedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFixedStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedFixedStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedFixedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedFixedStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "FixedKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedFixedStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedFixedStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedFixedStatementCore(oldElement, newElement);
    		UpdatedFixedStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedFixedStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFixedStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedFixedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFixedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedFixedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedFixedStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedFixedStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedFixedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedFixedStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedFixedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FixedKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedFixedStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedFixedStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedFixedStatementCore(property, oldParent, position, newParent);
    		MovedFixedStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFixedStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFixedStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFixedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedFixedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFixedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFixedStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFixedStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedFixedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFixedStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFixedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "FixedKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedFixedStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedFixedStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedFixedStatementCore(property, oldParent, position, newParent);
    		MatchedFixedStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CheckedStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCheckedStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCheckedStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCheckedStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCheckedStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCheckedStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCheckedStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCheckedStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCheckedStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCheckedStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCheckedStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCheckedStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCheckedStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCheckedStatementCore(property, position, parent);
    		InsertedCheckedStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCheckedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCheckedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCheckedStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedCheckedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCheckedStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCheckedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCheckedStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedCheckedStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCheckedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCheckedStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCheckedStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCheckedStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCheckedStatementCore(property, parent);
    		DeletedCheckedStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCheckedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCheckedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCheckedStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCheckedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCheckedStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCheckedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCheckedStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedCheckedStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCheckedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCheckedStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCheckedStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCheckedStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCheckedStatementCore(oldElement, newElement);
    		UpdatedCheckedStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCheckedStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCheckedStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCheckedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCheckedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCheckedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCheckedStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCheckedStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCheckedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCheckedStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCheckedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCheckedStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCheckedStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCheckedStatementCore(property, oldParent, position, newParent);
    		MovedCheckedStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCheckedStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCheckedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCheckedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCheckedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCheckedStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCheckedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCheckedStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCheckedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCheckedStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCheckedStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCheckedStatementCore(property, oldParent, position, newParent);
    		MatchedCheckedStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region UnsafeStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedUnsafeStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUnsafeStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedUnsafeStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedUnsafeStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedUnsafeStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedUnsafeStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedUnsafeStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedUnsafeStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedUnsafeStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedUnsafeStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedUnsafeStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedUnsafeStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedUnsafeStatementCore(property, position, parent);
    		InsertedUnsafeStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedUnsafeStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUnsafeStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedUnsafeStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedUnsafeStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedUnsafeStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedUnsafeStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedUnsafeStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedUnsafeStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedUnsafeStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedUnsafeStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedUnsafeStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedUnsafeStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedUnsafeStatementCore(property, parent);
    		DeletedUnsafeStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedUnsafeStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUnsafeStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedUnsafeStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedUnsafeStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedUnsafeStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedUnsafeStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedUnsafeStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedUnsafeStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedUnsafeStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedUnsafeStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "UnsafeKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedUnsafeStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedUnsafeStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedUnsafeStatementCore(oldElement, newElement);
    		UpdatedUnsafeStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedUnsafeStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUnsafeStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedUnsafeStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedUnsafeStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedUnsafeStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedUnsafeStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedUnsafeStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedUnsafeStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedUnsafeStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedUnsafeStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedUnsafeStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedUnsafeStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedUnsafeStatementCore(property, oldParent, position, newParent);
    		MovedUnsafeStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUnsafeStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUnsafeStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUnsafeStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedUnsafeStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUnsafeStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUnsafeStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUnsafeStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedUnsafeStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUnsafeStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUnsafeStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedUnsafeStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedUnsafeStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedUnsafeStatementCore(property, oldParent, position, newParent);
    		MatchedUnsafeStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region LockStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedLockStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLockStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedLockStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedLockStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedLockStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedLockStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedLockStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedLockStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedLockStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedLockStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LockKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedLockStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedLockStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedLockStatementCore(property, position, parent);
    		InsertedLockStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedLockStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLockStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedLockStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedLockStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedLockStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedLockStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedLockStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedLockStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedLockStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedLockStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LockKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedLockStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedLockStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedLockStatementCore(property, parent);
    		DeletedLockStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedLockStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLockStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedLockStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedLockStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedLockStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedLockStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedLockStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedLockStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedLockStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedLockStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "LockKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedLockStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedLockStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedLockStatementCore(oldElement, newElement);
    		UpdatedLockStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedLockStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLockStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedLockStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedLockStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedLockStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedLockStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedLockStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedLockStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedLockStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedLockStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LockKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedLockStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedLockStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedLockStatementCore(property, oldParent, position, newParent);
    		MovedLockStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLockStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLockStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLockStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedLockStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLockStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLockStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLockStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedLockStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLockStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLockStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "LockKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedLockStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedLockStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedLockStatementCore(property, oldParent, position, newParent);
    		MatchedLockStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region IfStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedIfStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIfStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedIfStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedIfStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedIfStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedIfStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedIfStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedIfStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedIfStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedIfStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedIfStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedIfStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedIfStatementCore(property, position, parent);
    		InsertedIfStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedIfStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIfStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedIfStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedIfStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedIfStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedIfStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedIfStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedIfStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedIfStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedIfStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedIfStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedIfStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedIfStatementCore(property, parent);
    		DeletedIfStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedIfStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIfStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedIfStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedIfStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedIfStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedIfStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedIfStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedIfStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedIfStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedIfStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedIfStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedIfStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedIfStatementCore(oldElement, newElement);
    		UpdatedIfStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedIfStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIfStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedIfStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedIfStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedIfStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedIfStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedIfStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedIfStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedIfStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedIfStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedIfStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedIfStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedIfStatementCore(property, oldParent, position, newParent);
    		MovedIfStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIfStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIfStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedIfStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIfStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIfStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedIfStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIfStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIfStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "IfKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedIfStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedIfStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedIfStatementCore(property, oldParent, position, newParent);
    		MatchedIfStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SwitchStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSwitchStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSwitchStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSwitchStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSwitchStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSwitchStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSwitchStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSwitchStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSwitchStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSwitchStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSwitchStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SwitchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSwitchStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSwitchStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSwitchStatementCore(property, position, parent);
    		InsertedSwitchStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSwitchStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSwitchStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSwitchStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedSwitchStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSwitchStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSwitchStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSwitchStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedSwitchStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSwitchStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSwitchStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SwitchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSwitchStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSwitchStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSwitchStatementCore(property, parent);
    		DeletedSwitchStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSwitchStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSwitchStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSwitchStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSwitchStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSwitchStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSwitchStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSwitchStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedSwitchStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSwitchStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSwitchStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "SwitchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSwitchStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSwitchStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSwitchStatementCore(oldElement, newElement);
    		UpdatedSwitchStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSwitchStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSwitchStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSwitchStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSwitchStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSwitchStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSwitchStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSwitchStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSwitchStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSwitchStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSwitchStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SwitchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSwitchStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSwitchStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSwitchStatementCore(property, oldParent, position, newParent);
    		MovedSwitchStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSwitchStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSwitchStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSwitchStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSwitchStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSwitchStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSwitchStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSwitchStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSwitchStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "SwitchKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseBraceToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSwitchStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSwitchStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSwitchStatementCore(property, oldParent, position, newParent);
    		MatchedSwitchStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region TryStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedTryStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTryStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedTryStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedTryStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedTryStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedTryStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedTryStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedTryStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedTryStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedTryStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TryKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedTryStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedTryStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedTryStatementCore(property, position, parent);
    		InsertedTryStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedTryStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTryStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedTryStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedTryStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedTryStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedTryStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedTryStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedTryStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedTryStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedTryStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TryKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedTryStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedTryStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedTryStatementCore(property, parent);
    		DeletedTryStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedTryStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTryStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedTryStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedTryStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedTryStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedTryStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedTryStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedTryStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedTryStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedTryStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "TryKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedTryStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedTryStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedTryStatementCore(oldElement, newElement);
    		UpdatedTryStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedTryStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTryStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedTryStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedTryStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedTryStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedTryStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedTryStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedTryStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedTryStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedTryStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TryKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedTryStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedTryStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedTryStatementCore(property, oldParent, position, newParent);
    		MovedTryStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTryStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTryStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTryStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedTryStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTryStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTryStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTryStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedTryStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTryStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTryStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "TryKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedTryStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedTryStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedTryStatementCore(property, oldParent, position, newParent);
    		MatchedTryStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ForEachStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedForEachStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForEachStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedForEachStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedForEachStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedForEachStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedForEachStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForEachStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedForEachStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedForEachStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedForEachStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedForEachStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedForEachStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedForEachStatementCore(property, position, parent);
    		InsertedForEachStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedForEachStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForEachStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedForEachStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedForEachStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedForEachStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedForEachStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForEachStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedForEachStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedForEachStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedForEachStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedForEachStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedForEachStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedForEachStatementCore(property, parent);
    		DeletedForEachStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedForEachStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForEachStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedForEachStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedForEachStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedForEachStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedForEachStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForEachStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedForEachStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedForEachStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedForEachStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedForEachStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedForEachStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedForEachStatementCore(oldElement, newElement);
    		UpdatedForEachStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedForEachStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForEachStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedForEachStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedForEachStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedForEachStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedForEachStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForEachStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedForEachStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedForEachStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedForEachStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedForEachStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedForEachStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedForEachStatementCore(property, oldParent, position, newParent);
    		MovedForEachStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForEachStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForEachStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedForEachStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForEachStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForEachStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedForEachStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForEachStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForEachStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedForEachStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedForEachStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedForEachStatementCore(property, oldParent, position, newParent);
    		MatchedForEachStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ForEachVariableStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedForEachVariableStatement(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForEachVariableStatement(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedForEachVariableStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedForEachVariableStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedForEachVariableStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedForEachVariableStatementCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedForEachVariableStatementCore(XElement, int, XElement)"/>.</param>
        partial void InsertedForEachVariableStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedForEachVariableStatement(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedForEachVariableStatementCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedForEachVariableStatement(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedForEachVariableStatementBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedForEachVariableStatementCore(property, position, parent);
    		InsertedForEachVariableStatementAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedForEachVariableStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForEachVariableStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedForEachVariableStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedForEachVariableStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedForEachVariableStatementBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedForEachVariableStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedForEachVariableStatementCore(XElement, XElement)"/>.</param>
        partial void DeletedForEachVariableStatementAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedForEachVariableStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedForEachVariableStatementCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedForEachVariableStatement(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedForEachVariableStatementBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedForEachVariableStatementCore(property, parent);
    		DeletedForEachVariableStatementAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedForEachVariableStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForEachVariableStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedForEachVariableStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedForEachVariableStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedForEachVariableStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedForEachVariableStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedForEachVariableStatementCore(XElement, XElement)"/>.</param>
        partial void UpdatedForEachVariableStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedForEachVariableStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedForEachVariableStatementCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedForEachVariableStatement(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedForEachVariableStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedForEachVariableStatementCore(oldElement, newElement);
    		UpdatedForEachVariableStatementAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedForEachVariableStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForEachVariableStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedForEachVariableStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedForEachVariableStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedForEachVariableStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedForEachVariableStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedForEachVariableStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedForEachVariableStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedForEachVariableStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedForEachVariableStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedForEachVariableStatementCore(property, oldParent, position, newParent);
    		MovedForEachVariableStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForEachVariableStatement(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachVariableStatement(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForEachVariableStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedForEachVariableStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForEachVariableStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedForEachVariableStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForEachVariableStatement(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForEachVariableStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "ForEachKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "InKeyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedForEachVariableStatement(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedForEachVariableStatementBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedForEachVariableStatementCore(property, oldParent, position, newParent);
    		MatchedForEachVariableStatementAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region SingleVariableDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedSingleVariableDesignation(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSingleVariableDesignation(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedSingleVariableDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedSingleVariableDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedSingleVariableDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedSingleVariableDesignationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedSingleVariableDesignationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedSingleVariableDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedSingleVariableDesignation(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedSingleVariableDesignationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedSingleVariableDesignation(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedSingleVariableDesignationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedSingleVariableDesignationCore(property, position, parent);
    		InsertedSingleVariableDesignationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedSingleVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSingleVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedSingleVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedSingleVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedSingleVariableDesignationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedSingleVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedSingleVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void DeletedSingleVariableDesignationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedSingleVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedSingleVariableDesignationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedSingleVariableDesignation(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedSingleVariableDesignationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedSingleVariableDesignationCore(property, parent);
    		DeletedSingleVariableDesignationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedSingleVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSingleVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedSingleVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedSingleVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedSingleVariableDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedSingleVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedSingleVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void UpdatedSingleVariableDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedSingleVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedSingleVariableDesignationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedSingleVariableDesignation(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedSingleVariableDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedSingleVariableDesignationCore(oldElement, newElement);
    		UpdatedSingleVariableDesignationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedSingleVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedSingleVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedSingleVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedSingleVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedSingleVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedSingleVariableDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedSingleVariableDesignationCore(property, oldParent, position, newParent);
    		MovedSingleVariableDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedSingleVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSingleVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedSingleVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSingleVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedSingleVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedSingleVariableDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedSingleVariableDesignationCore(property, oldParent, position, newParent);
    		MatchedSingleVariableDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DiscardDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDiscardDesignation(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDiscardDesignation(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDiscardDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDiscardDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDiscardDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDiscardDesignationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDiscardDesignationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDiscardDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDiscardDesignation(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDiscardDesignationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnderscoreToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDiscardDesignation(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDiscardDesignationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDiscardDesignationCore(property, position, parent);
    		InsertedDiscardDesignationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDiscardDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDiscardDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDiscardDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedDiscardDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDiscardDesignationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDiscardDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDiscardDesignationCore(XElement, XElement)"/>.</param>
        partial void DeletedDiscardDesignationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDiscardDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDiscardDesignationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnderscoreToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDiscardDesignation(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDiscardDesignationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDiscardDesignationCore(property, parent);
    		DeletedDiscardDesignationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDiscardDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDiscardDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDiscardDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDiscardDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDiscardDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDiscardDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDiscardDesignationCore(XElement, XElement)"/>.</param>
        partial void UpdatedDiscardDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDiscardDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDiscardDesignationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "UnderscoreToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDiscardDesignation(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDiscardDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDiscardDesignationCore(oldElement, newElement);
    		UpdatedDiscardDesignationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDiscardDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDiscardDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDiscardDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDiscardDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDiscardDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDiscardDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDiscardDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDiscardDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDiscardDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDiscardDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnderscoreToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDiscardDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDiscardDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDiscardDesignationCore(property, oldParent, position, newParent);
    		MovedDiscardDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDiscardDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDiscardDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDiscardDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDiscardDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDiscardDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDiscardDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDiscardDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDiscardDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDiscardDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDiscardDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "UnderscoreToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDiscardDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDiscardDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDiscardDesignationCore(property, oldParent, position, newParent);
    		MatchedDiscardDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region ParenthesizedVariableDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedParenthesizedVariableDesignation(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedVariableDesignation(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedParenthesizedVariableDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedParenthesizedVariableDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedParenthesizedVariableDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedParenthesizedVariableDesignationCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedParenthesizedVariableDesignationCore(XElement, int, XElement)"/>.</param>
        partial void InsertedParenthesizedVariableDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedParenthesizedVariableDesignation(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedParenthesizedVariableDesignationCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedParenthesizedVariableDesignation(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedParenthesizedVariableDesignationBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedParenthesizedVariableDesignationCore(property, position, parent);
    		InsertedParenthesizedVariableDesignationAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedParenthesizedVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedParenthesizedVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedParenthesizedVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedParenthesizedVariableDesignationBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedParenthesizedVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedParenthesizedVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void DeletedParenthesizedVariableDesignationAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedParenthesizedVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedParenthesizedVariableDesignationCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedParenthesizedVariableDesignation(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedParenthesizedVariableDesignationBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedParenthesizedVariableDesignationCore(property, parent);
    		DeletedParenthesizedVariableDesignationAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedParenthesizedVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedParenthesizedVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedParenthesizedVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedParenthesizedVariableDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedParenthesizedVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedParenthesizedVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void UpdatedParenthesizedVariableDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedParenthesizedVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedParenthesizedVariableDesignationCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedParenthesizedVariableDesignation(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedParenthesizedVariableDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedParenthesizedVariableDesignationCore(oldElement, newElement);
    		UpdatedParenthesizedVariableDesignationAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedParenthesizedVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedParenthesizedVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedParenthesizedVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedParenthesizedVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedParenthesizedVariableDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedParenthesizedVariableDesignationCore(property, oldParent, position, newParent);
    		MovedParenthesizedVariableDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedParenthesizedVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "OpenParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "CloseParenToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedParenthesizedVariableDesignationBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedParenthesizedVariableDesignationCore(property, oldParent, position, newParent);
    		MatchedParenthesizedVariableDesignationAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CasePatternSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCasePatternSwitchLabel(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCasePatternSwitchLabel(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCasePatternSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCasePatternSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCasePatternSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCasePatternSwitchLabelCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCasePatternSwitchLabelCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCasePatternSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCasePatternSwitchLabel(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCasePatternSwitchLabelCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCasePatternSwitchLabel(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCasePatternSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCasePatternSwitchLabelCore(property, position, parent);
    		InsertedCasePatternSwitchLabelAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCasePatternSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCasePatternSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCasePatternSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedCasePatternSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCasePatternSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCasePatternSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCasePatternSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void DeletedCasePatternSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCasePatternSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCasePatternSwitchLabelCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCasePatternSwitchLabel(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCasePatternSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCasePatternSwitchLabelCore(property, parent);
    		DeletedCasePatternSwitchLabelAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCasePatternSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCasePatternSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCasePatternSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCasePatternSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCasePatternSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCasePatternSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCasePatternSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void UpdatedCasePatternSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCasePatternSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCasePatternSwitchLabelCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCasePatternSwitchLabel(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCasePatternSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCasePatternSwitchLabelCore(oldElement, newElement);
    		UpdatedCasePatternSwitchLabelAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCasePatternSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCasePatternSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCasePatternSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCasePatternSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCasePatternSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCasePatternSwitchLabelCore(property, oldParent, position, newParent);
    		MovedCasePatternSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCasePatternSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCasePatternSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCasePatternSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCasePatternSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCasePatternSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCasePatternSwitchLabelCore(property, oldParent, position, newParent);
    		MatchedCasePatternSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region CaseSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedCaseSwitchLabel(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCaseSwitchLabel(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedCaseSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedCaseSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedCaseSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedCaseSwitchLabelCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCaseSwitchLabelCore(XElement, int, XElement)"/>.</param>
        partial void InsertedCaseSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedCaseSwitchLabel(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedCaseSwitchLabelCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedCaseSwitchLabel(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedCaseSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedCaseSwitchLabelCore(property, position, parent);
    		InsertedCaseSwitchLabelAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedCaseSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCaseSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedCaseSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedCaseSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedCaseSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedCaseSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCaseSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void DeletedCaseSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedCaseSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedCaseSwitchLabelCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedCaseSwitchLabel(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedCaseSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedCaseSwitchLabelCore(property, parent);
    		DeletedCaseSwitchLabelAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedCaseSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCaseSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedCaseSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedCaseSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedCaseSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedCaseSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCaseSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void UpdatedCaseSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedCaseSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedCaseSwitchLabelCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedCaseSwitchLabel(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedCaseSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedCaseSwitchLabelCore(oldElement, newElement);
    		UpdatedCaseSwitchLabelAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedCaseSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedCaseSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedCaseSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedCaseSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedCaseSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedCaseSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedCaseSwitchLabelCore(property, oldParent, position, newParent);
    		MovedCaseSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedCaseSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCaseSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedCaseSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCaseSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedCaseSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedCaseSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedCaseSwitchLabelCore(property, oldParent, position, newParent);
    		MatchedCaseSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    	#region DefaultSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="InsertedDefaultSwitchLabel(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefaultSwitchLabel(XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="InsertedDefaultSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedDefaultSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void InsertedDefaultSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="InsertedDefaultSwitchLabelCore(XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="InsertedDefaultSwitchLabelCore(XElement, int, XElement)"/>.</param>
        partial void InsertedDefaultSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    	/// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="InsertedDefaultSwitchLabel(XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> InsertedDefaultSwitchLabelCore(XElement property, int position, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes an insert action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where insert the property element in.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> InsertedDefaultSwitchLabel(XElement property, int position, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		InsertedDefaultSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.InsertedDefaultSwitchLabelCore(property, position, parent);
    		InsertedDefaultSwitchLabelAfter(property, position, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="DeletedDefaultSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefaultSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="DeletedDefaultSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedDefaultSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void DeletedDefaultSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="DeletedDefaultSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="DeletedDefaultSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void DeletedDefaultSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="DeletedDefaultSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> DeletedDefaultSwitchLabelCore(XElement property, XElement parent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a delete action.
        /// </summary>
        /// <param name="property">deleted element.</param>
        /// <param name="parent">parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> DeletedDefaultSwitchLabel(XElement property, XElement parent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		DeletedDefaultSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.DeletedDefaultSwitchLabelCore(property, parent);
    		DeletedDefaultSwitchLabelAfter(property, parent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UpdatedDefaultSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefaultSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UpdatedDefaultSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedDefaultSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UpdatedDefaultSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UpdatedDefaultSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedDefaultSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void UpdatedDefaultSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="UpdatedDefaultSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UpdatedDefaultSwitchLabelCore(XElement oldElement, XElement newElement)
        {
    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
    		XElement firstAction = null, secondAction = null;
    		if(oldElement.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(oldElement.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
         /// <summary>
        /// Analyzes an update action.
        /// </summary>
        /// <param name="oldElement">original element.</param>
        /// <param name="newElement">modified element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> UpdatedDefaultSwitchLabel(XElement oldElement, XElement newElement)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		UpdatedDefaultSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.UpdatedDefaultSwitchLabelCore(oldElement, newElement);
    		UpdatedDefaultSwitchLabelAfter(oldElement, newElement, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MovedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MovedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedDefaultSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MovedDefaultSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MovedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MovedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MovedDefaultSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MovedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MovedDefaultSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MovedDefaultSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MovedDefaultSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MovedDefaultSwitchLabelCore(property, oldParent, position, newParent);
    		MovedDefaultSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MatchedDefaultSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefaultSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
        
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
        partial void MatchedDefaultSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    	 /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefaultSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
        {
    		if(property == null)
    			throw new ArgumentNullException(nameof(property));
    
    		XElement firstAction = null, secondAction = null;
    		if(property.Attribute("part")?.Value == "Keyword")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		if(property.Attribute("part")?.Value == "ColonToken")
    		{
    			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
    			{
    				yield return imprecision;
    			}
    		}
    		
    		yield break;
        }	
    	
        /// <summary>
        /// Analyzes a move action.
        /// </summary>
        /// <param name="property">property element.</param>
        /// <param name="position">position where the property would move.</param>
        /// <param name="oldParent">original parent element.</param>
        /// <param name="newParent">modified parent element.</param>
        /// <returns>the imprecisions supposedly detected.</returns>
        public virtual IEnumerable<XElement> MatchedDefaultSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
    	{
    		IEnumerable<XElement> result = null;
    		var ignoreCore = false;
    		MatchedDefaultSwitchLabelBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
    		if(ignoreCore) 
    			return result;
    		
    		result = this.MatchedDefaultSwitchLabelCore(property, oldParent, position, newParent);
    		MatchedDefaultSwitchLabelAfter(property, oldParent, position, newParent, ref result);
    		return result;
    	}
    
    	#endregion
    
    }
}
// Generated helper templates
// Generated items
