
//using Microsoft.CodeAnalysis.CSharp;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Xml.Linq;

//namespace Jawilliam.CDF.CSharp.Diagnostic
//{
//    public partial class IrrationalityBasedDiagnostic
//    {
//    	#region Deleted(XElement, XElement)'s Visit
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="Deleted(XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="Deleted(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedCore(XElement, XElement)"/> is not executed and <see cref="Deleted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
    
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedCore(XElement, XElement)"/>.</param>
//        partial void DeletedAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
        
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="Deleted(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedCore(XElement property, XElement parent)
//    	{
//    		if(parent == null)
//    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
//    		switch(parent.Name.LocalName)
//    		{
//    			case "AttributeArgument": return this.DeletedFromAttributeArgument(property, parent);
//    			case "NameEquals": return this.DeletedFromNameEquals(property, parent);
//    			case "TypeParameterList": return this.DeletedFromTypeParameterList(property, parent);
//    			case "TypeParameter": return this.DeletedFromTypeParameter(property, parent);
//    			case "BaseList": return this.DeletedFromBaseList(property, parent);
//    			case "TypeParameterConstraintClause": return this.DeletedFromTypeParameterConstraintClause(property, parent);
//    			case "ExplicitInterfaceSpecifier": return this.DeletedFromExplicitInterfaceSpecifier(property, parent);
//    			case "ConstructorInitializer": return this.DeletedFromConstructorInitializer(property, parent);
//    			case "ArrowExpressionClause": return this.DeletedFromArrowExpressionClause(property, parent);
//    			case "AccessorList": return this.DeletedFromAccessorList(property, parent);
//    			case "AccessorDeclaration": return this.DeletedFromAccessorDeclaration(property, parent);
//    			case "Parameter": return this.DeletedFromParameter(property, parent);
//    			case "CrefParameter": return this.DeletedFromCrefParameter(property, parent);
//    			case "XmlElementStartTag": return this.DeletedFromXmlElementStartTag(property, parent);
//    			case "XmlElementEndTag": return this.DeletedFromXmlElementEndTag(property, parent);
//    			case "XmlName": return this.DeletedFromXmlName(property, parent);
//    			case "XmlPrefix": return this.DeletedFromXmlPrefix(property, parent);
//    			case "TypeArgumentList": return this.DeletedFromTypeArgumentList(property, parent);
//    			case "ArrayRankSpecifier": return this.DeletedFromArrayRankSpecifier(property, parent);
//    			case "TupleElement": return this.DeletedFromTupleElement(property, parent);
//    			case "Argument": return this.DeletedFromArgument(property, parent);
//    			case "NameColon": return this.DeletedFromNameColon(property, parent);
//    			case "AnonymousObjectMemberDeclarator": return this.DeletedFromAnonymousObjectMemberDeclarator(property, parent);
//    			case "QueryBody": return this.DeletedFromQueryBody(property, parent);
//    			case "JoinIntoClause": return this.DeletedFromJoinIntoClause(property, parent);
//    			case "Ordering": return this.DeletedFromOrdering(property, parent);
//    			case "QueryContinuation": return this.DeletedFromQueryContinuation(property, parent);
//    			case "WhenClause": return this.DeletedFromWhenClause(property, parent);
//    			case "InterpolationAlignmentClause": return this.DeletedFromInterpolationAlignmentClause(property, parent);
//    			case "InterpolationFormatClause": return this.DeletedFromInterpolationFormatClause(property, parent);
//    			case "VariableDeclaration": return this.DeletedFromVariableDeclaration(property, parent);
//    			case "VariableDeclarator": return this.DeletedFromVariableDeclarator(property, parent);
//    			case "EqualsValueClause": return this.DeletedFromEqualsValueClause(property, parent);
//    			case "ElseClause": return this.DeletedFromElseClause(property, parent);
//    			case "SwitchSection": return this.DeletedFromSwitchSection(property, parent);
//    			case "CatchClause": return this.DeletedFromCatchClause(property, parent);
//    			case "CatchDeclaration": return this.DeletedFromCatchDeclaration(property, parent);
//    			case "CatchFilterClause": return this.DeletedFromCatchFilterClause(property, parent);
//    			case "FinallyClause": return this.DeletedFromFinallyClause(property, parent);
//    			case "CompilationUnit": return this.DeletedFromCompilationUnit(property, parent);
//    			case "ExternAliasDirective": return this.DeletedFromExternAliasDirective(property, parent);
//    			case "UsingDirective": return this.DeletedFromUsingDirective(property, parent);
//    			case "AttributeList": return this.DeletedFromAttributeList(property, parent);
//    			case "AttributeTargetSpecifier": return this.DeletedFromAttributeTargetSpecifier(property, parent);
//    			case "Attribute": return this.DeletedFromAttribute(property, parent);
//    			case "AttributeArgumentList": return this.DeletedFromAttributeArgumentList(property, parent);
//    			case "DelegateDeclaration": return this.DeletedFromDelegateDeclaration(property, parent);
//    			case "EnumMemberDeclaration": return this.DeletedFromEnumMemberDeclaration(property, parent);
//    			case "IncompleteMember": return this.DeletedFromIncompleteMember(property, parent);
//    			case "GlobalStatement": return this.DeletedFromGlobalStatement(property, parent);
//    			case "NamespaceDeclaration": return this.DeletedFromNamespaceDeclaration(property, parent);
//    			case "EnumDeclaration": return this.DeletedFromEnumDeclaration(property, parent);
//    			case "ClassDeclaration": return this.DeletedFromClassDeclaration(property, parent);
//    			case "StructDeclaration": return this.DeletedFromStructDeclaration(property, parent);
//    			case "InterfaceDeclaration": return this.DeletedFromInterfaceDeclaration(property, parent);
//    			case "FieldDeclaration": return this.DeletedFromFieldDeclaration(property, parent);
//    			case "EventFieldDeclaration": return this.DeletedFromEventFieldDeclaration(property, parent);
//    			case "MethodDeclaration": return this.DeletedFromMethodDeclaration(property, parent);
//    			case "OperatorDeclaration": return this.DeletedFromOperatorDeclaration(property, parent);
//    			case "ConversionOperatorDeclaration": return this.DeletedFromConversionOperatorDeclaration(property, parent);
//    			case "ConstructorDeclaration": return this.DeletedFromConstructorDeclaration(property, parent);
//    			case "DestructorDeclaration": return this.DeletedFromDestructorDeclaration(property, parent);
//    			case "PropertyDeclaration": return this.DeletedFromPropertyDeclaration(property, parent);
//    			case "EventDeclaration": return this.DeletedFromEventDeclaration(property, parent);
//    			case "IndexerDeclaration": return this.DeletedFromIndexerDeclaration(property, parent);
//    			case "SimpleBaseType": return this.DeletedFromSimpleBaseType(property, parent);
//    			case "ConstructorConstraint": return this.DeletedFromConstructorConstraint(property, parent);
//    			case "ClassOrStructConstraint": return this.DeletedFromClassOrStructConstraint(property, parent);
//    			case "TypeConstraint": return this.DeletedFromTypeConstraint(property, parent);
//    			case "ParameterList": return this.DeletedFromParameterList(property, parent);
//    			case "BracketedParameterList": return this.DeletedFromBracketedParameterList(property, parent);
//    			case "SkippedTokensTrivia": return this.DeletedFromSkippedTokensTrivia(property, parent);
//    			case "DocumentationCommentTrivia": return this.DeletedFromDocumentationCommentTrivia(property, parent);
//    			case "EndIfDirectiveTrivia": return this.DeletedFromEndIfDirectiveTrivia(property, parent);
//    			case "RegionDirectiveTrivia": return this.DeletedFromRegionDirectiveTrivia(property, parent);
//    			case "EndRegionDirectiveTrivia": return this.DeletedFromEndRegionDirectiveTrivia(property, parent);
//    			case "ErrorDirectiveTrivia": return this.DeletedFromErrorDirectiveTrivia(property, parent);
//    			case "WarningDirectiveTrivia": return this.DeletedFromWarningDirectiveTrivia(property, parent);
//    			case "BadDirectiveTrivia": return this.DeletedFromBadDirectiveTrivia(property, parent);
//    			case "DefineDirectiveTrivia": return this.DeletedFromDefineDirectiveTrivia(property, parent);
//    			case "UndefDirectiveTrivia": return this.DeletedFromUndefDirectiveTrivia(property, parent);
//    			case "LineDirectiveTrivia": return this.DeletedFromLineDirectiveTrivia(property, parent);
//    			case "PragmaWarningDirectiveTrivia": return this.DeletedFromPragmaWarningDirectiveTrivia(property, parent);
//    			case "PragmaChecksumDirectiveTrivia": return this.DeletedFromPragmaChecksumDirectiveTrivia(property, parent);
//    			case "ReferenceDirectiveTrivia": return this.DeletedFromReferenceDirectiveTrivia(property, parent);
//    			case "LoadDirectiveTrivia": return this.DeletedFromLoadDirectiveTrivia(property, parent);
//    			case "ShebangDirectiveTrivia": return this.DeletedFromShebangDirectiveTrivia(property, parent);
//    			case "ElseDirectiveTrivia": return this.DeletedFromElseDirectiveTrivia(property, parent);
//    			case "IfDirectiveTrivia": return this.DeletedFromIfDirectiveTrivia(property, parent);
//    			case "ElifDirectiveTrivia": return this.DeletedFromElifDirectiveTrivia(property, parent);
//    			case "TypeCref": return this.DeletedFromTypeCref(property, parent);
//    			case "QualifiedCref": return this.DeletedFromQualifiedCref(property, parent);
//    			case "NameMemberCref": return this.DeletedFromNameMemberCref(property, parent);
//    			case "IndexerMemberCref": return this.DeletedFromIndexerMemberCref(property, parent);
//    			case "OperatorMemberCref": return this.DeletedFromOperatorMemberCref(property, parent);
//    			case "ConversionOperatorMemberCref": return this.DeletedFromConversionOperatorMemberCref(property, parent);
//    			case "CrefParameterList": return this.DeletedFromCrefParameterList(property, parent);
//    			case "CrefBracketedParameterList": return this.DeletedFromCrefBracketedParameterList(property, parent);
//    			case "XmlElement": return this.DeletedFromXmlElement(property, parent);
//    			case "XmlEmptyElement": return this.DeletedFromXmlEmptyElement(property, parent);
//    			case "XmlText": return this.DeletedFromXmlText(property, parent);
//    			case "XmlCDataSection": return this.DeletedFromXmlCDataSection(property, parent);
//    			case "XmlProcessingInstruction": return this.DeletedFromXmlProcessingInstruction(property, parent);
//    			case "XmlComment": return this.DeletedFromXmlComment(property, parent);
//    			case "XmlTextAttribute": return this.DeletedFromXmlTextAttribute(property, parent);
//    			case "XmlCrefAttribute": return this.DeletedFromXmlCrefAttribute(property, parent);
//    			case "XmlNameAttribute": return this.DeletedFromXmlNameAttribute(property, parent);
//    			case "ParenthesizedExpression": return this.DeletedFromParenthesizedExpression(property, parent);
//    			case "TupleExpression": return this.DeletedFromTupleExpression(property, parent);
//    			case "PrefixUnaryExpression": return this.DeletedFromPrefixUnaryExpression(property, parent);
//    			case "AwaitExpression": return this.DeletedFromAwaitExpression(property, parent);
//    			case "PostfixUnaryExpression": return this.DeletedFromPostfixUnaryExpression(property, parent);
//    			case "MemberAccessExpression": return this.DeletedFromMemberAccessExpression(property, parent);
//    			case "ConditionalAccessExpression": return this.DeletedFromConditionalAccessExpression(property, parent);
//    			case "MemberBindingExpression": return this.DeletedFromMemberBindingExpression(property, parent);
//    			case "ElementBindingExpression": return this.DeletedFromElementBindingExpression(property, parent);
//    			case "ImplicitElementAccess": return this.DeletedFromImplicitElementAccess(property, parent);
//    			case "BinaryExpression": return this.DeletedFromBinaryExpression(property, parent);
//    			case "AssignmentExpression": return this.DeletedFromAssignmentExpression(property, parent);
//    			case "ConditionalExpression": return this.DeletedFromConditionalExpression(property, parent);
//    			case "LiteralExpression": return this.DeletedFromLiteralExpression(property, parent);
//    			case "MakeRefExpression": return this.DeletedFromMakeRefExpression(property, parent);
//    			case "RefTypeExpression": return this.DeletedFromRefTypeExpression(property, parent);
//    			case "RefValueExpression": return this.DeletedFromRefValueExpression(property, parent);
//    			case "CheckedExpression": return this.DeletedFromCheckedExpression(property, parent);
//    			case "DefaultExpression": return this.DeletedFromDefaultExpression(property, parent);
//    			case "TypeOfExpression": return this.DeletedFromTypeOfExpression(property, parent);
//    			case "SizeOfExpression": return this.DeletedFromSizeOfExpression(property, parent);
//    			case "InvocationExpression": return this.DeletedFromInvocationExpression(property, parent);
//    			case "ElementAccessExpression": return this.DeletedFromElementAccessExpression(property, parent);
//    			case "DeclarationExpression": return this.DeletedFromDeclarationExpression(property, parent);
//    			case "CastExpression": return this.DeletedFromCastExpression(property, parent);
//    			case "RefExpression": return this.DeletedFromRefExpression(property, parent);
//    			case "InitializerExpression": return this.DeletedFromInitializerExpression(property, parent);
//    			case "ObjectCreationExpression": return this.DeletedFromObjectCreationExpression(property, parent);
//    			case "AnonymousObjectCreationExpression": return this.DeletedFromAnonymousObjectCreationExpression(property, parent);
//    			case "ArrayCreationExpression": return this.DeletedFromArrayCreationExpression(property, parent);
//    			case "ImplicitArrayCreationExpression": return this.DeletedFromImplicitArrayCreationExpression(property, parent);
//    			case "StackAllocArrayCreationExpression": return this.DeletedFromStackAllocArrayCreationExpression(property, parent);
//    			case "QueryExpression": return this.DeletedFromQueryExpression(property, parent);
//    			case "OmittedArraySizeExpression": return this.DeletedFromOmittedArraySizeExpression(property, parent);
//    			case "InterpolatedStringExpression": return this.DeletedFromInterpolatedStringExpression(property, parent);
//    			case "IsPatternExpression": return this.DeletedFromIsPatternExpression(property, parent);
//    			case "ThrowExpression": return this.DeletedFromThrowExpression(property, parent);
//    			case "PredefinedType": return this.DeletedFromPredefinedType(property, parent);
//    			case "ArrayType": return this.DeletedFromArrayType(property, parent);
//    			case "PointerType": return this.DeletedFromPointerType(property, parent);
//    			case "NullableType": return this.DeletedFromNullableType(property, parent);
//    			case "TupleType": return this.DeletedFromTupleType(property, parent);
//    			case "OmittedTypeArgument": return this.DeletedFromOmittedTypeArgument(property, parent);
//    			case "RefType": return this.DeletedFromRefType(property, parent);
//    			case "QualifiedName": return this.DeletedFromQualifiedName(property, parent);
//    			case "AliasQualifiedName": return this.DeletedFromAliasQualifiedName(property, parent);
//    			case "IdentifierName": return this.DeletedFromIdentifierName(property, parent);
//    			case "GenericName": return this.DeletedFromGenericName(property, parent);
//    			case "ThisExpression": return this.DeletedFromThisExpression(property, parent);
//    			case "BaseExpression": return this.DeletedFromBaseExpression(property, parent);
//    			case "AnonymousMethodExpression": return this.DeletedFromAnonymousMethodExpression(property, parent);
//    			case "SimpleLambdaExpression": return this.DeletedFromSimpleLambdaExpression(property, parent);
//    			case "ParenthesizedLambdaExpression": return this.DeletedFromParenthesizedLambdaExpression(property, parent);
//    			case "ArgumentList": return this.DeletedFromArgumentList(property, parent);
//    			case "BracketedArgumentList": return this.DeletedFromBracketedArgumentList(property, parent);
//    			case "FromClause": return this.DeletedFromFromClause(property, parent);
//    			case "LetClause": return this.DeletedFromLetClause(property, parent);
//    			case "JoinClause": return this.DeletedFromJoinClause(property, parent);
//    			case "WhereClause": return this.DeletedFromWhereClause(property, parent);
//    			case "OrderByClause": return this.DeletedFromOrderByClause(property, parent);
//    			case "SelectClause": return this.DeletedFromSelectClause(property, parent);
//    			case "GroupClause": return this.DeletedFromGroupClause(property, parent);
//    			case "DeclarationPattern": return this.DeletedFromDeclarationPattern(property, parent);
//    			case "ConstantPattern": return this.DeletedFromConstantPattern(property, parent);
//    			case "InterpolatedStringText": return this.DeletedFromInterpolatedStringText(property, parent);
//    			case "Interpolation": return this.DeletedFromInterpolation(property, parent);
//    			case "Block": return this.DeletedFromBlock(property, parent);
//    			case "LocalFunctionStatement": return this.DeletedFromLocalFunctionStatement(property, parent);
//    			case "LocalDeclarationStatement": return this.DeletedFromLocalDeclarationStatement(property, parent);
//    			case "ExpressionStatement": return this.DeletedFromExpressionStatement(property, parent);
//    			case "EmptyStatement": return this.DeletedFromEmptyStatement(property, parent);
//    			case "LabeledStatement": return this.DeletedFromLabeledStatement(property, parent);
//    			case "GotoStatement": return this.DeletedFromGotoStatement(property, parent);
//    			case "BreakStatement": return this.DeletedFromBreakStatement(property, parent);
//    			case "ContinueStatement": return this.DeletedFromContinueStatement(property, parent);
//    			case "ReturnStatement": return this.DeletedFromReturnStatement(property, parent);
//    			case "ThrowStatement": return this.DeletedFromThrowStatement(property, parent);
//    			case "YieldStatement": return this.DeletedFromYieldStatement(property, parent);
//    			case "WhileStatement": return this.DeletedFromWhileStatement(property, parent);
//    			case "DoStatement": return this.DeletedFromDoStatement(property, parent);
//    			case "ForStatement": return this.DeletedFromForStatement(property, parent);
//    			case "UsingStatement": return this.DeletedFromUsingStatement(property, parent);
//    			case "FixedStatement": return this.DeletedFromFixedStatement(property, parent);
//    			case "CheckedStatement": return this.DeletedFromCheckedStatement(property, parent);
//    			case "UnsafeStatement": return this.DeletedFromUnsafeStatement(property, parent);
//    			case "LockStatement": return this.DeletedFromLockStatement(property, parent);
//    			case "IfStatement": return this.DeletedFromIfStatement(property, parent);
//    			case "SwitchStatement": return this.DeletedFromSwitchStatement(property, parent);
//    			case "TryStatement": return this.DeletedFromTryStatement(property, parent);
//    			case "ForEachStatement": return this.DeletedFromForEachStatement(property, parent);
//    			case "ForEachVariableStatement": return this.DeletedFromForEachVariableStatement(property, parent);
//    			case "SingleVariableDesignation": return this.DeletedFromSingleVariableDesignation(property, parent);
//    			case "DiscardDesignation": return this.DeletedFromDiscardDesignation(property, parent);
//    			case "ParenthesizedVariableDesignation": return this.DeletedFromParenthesizedVariableDesignation(property, parent);
//    			case "CasePatternSwitchLabel": return this.DeletedFromCasePatternSwitchLabel(property, parent);
//    			case "CaseSwitchLabel": return this.DeletedFromCaseSwitchLabel(property, parent);
//    			case "DefaultSwitchLabel": return this.DeletedFromDefaultSwitchLabel(property, parent);
//                case "SingleLineCommentTrivia": return this.DeletedFromSingleLineCommentTrivia(property, parent);
//                case "MultiLineCommentTrivia": return this.DeletedFromMultiLineCommentTrivia(property, parent);
//    			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
//    		}
//    	}		
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> Deleted(XElement property, XElement parent)
//        {
//            IEnumerable<Imprecision> result = new Imprecision[0];
//        	var ignoreCore = false;
//        	DeletedBefore(property, parent, ref result, ref ignoreCore);
//        	if(ignoreCore) 
//        		return result;
        	
//        	result = this.DeletedCore(property, parent);
//        	DeletedAfter(property, parent, ref result);
//        	return result;
//        }
    
//    	#endregion
    
//    	#region Inserted(XElement, XElement)'s Visit
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="Inserted(XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="Inserted(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedCore(XElement, XElement)"/> is not executed and <see cref="Inserted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
    
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedCore(XElement, XElement)"/>.</param>
//        partial void InsertedAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
        
//        /// <summary>
//        /// Analyzes a insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="Inserted(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedCore(XElement property, int position, XElement parent)
//    	{
//    		if(parent == null)
//    			throw new InvalidOperationException("The parent of a modified element cannot be null.");
    
//    		switch(parent.Name.LocalName)
//    		{
//    			case "AttributeArgument": return this.InsertedFromAttributeArgument(property, position, parent);
//    			case "NameEquals": return this.InsertedFromNameEquals(property, position, parent);
//    			case "TypeParameterList": return this.InsertedFromTypeParameterList(property, position, parent);
//    			case "TypeParameter": return this.InsertedFromTypeParameter(property, position, parent);
//    			case "BaseList": return this.InsertedFromBaseList(property, position, parent);
//    			case "TypeParameterConstraintClause": return this.InsertedFromTypeParameterConstraintClause(property, position, parent);
//    			case "ExplicitInterfaceSpecifier": return this.InsertedFromExplicitInterfaceSpecifier(property, position, parent);
//    			case "ConstructorInitializer": return this.InsertedFromConstructorInitializer(property, position, parent);
//    			case "ArrowExpressionClause": return this.InsertedFromArrowExpressionClause(property, position, parent);
//    			case "AccessorList": return this.InsertedFromAccessorList(property, position, parent);
//    			case "AccessorDeclaration": return this.InsertedFromAccessorDeclaration(property, position, parent);
//    			case "Parameter": return this.InsertedFromParameter(property, position, parent);
//    			case "CrefParameter": return this.InsertedFromCrefParameter(property, position, parent);
//    			case "XmlElementStartTag": return this.InsertedFromXmlElementStartTag(property, position, parent);
//    			case "XmlElementEndTag": return this.InsertedFromXmlElementEndTag(property, position, parent);
//    			case "XmlName": return this.InsertedFromXmlName(property, position, parent);
//    			case "XmlPrefix": return this.InsertedFromXmlPrefix(property, position, parent);
//    			case "TypeArgumentList": return this.InsertedFromTypeArgumentList(property, position, parent);
//    			case "ArrayRankSpecifier": return this.InsertedFromArrayRankSpecifier(property, position, parent);
//    			case "TupleElement": return this.InsertedFromTupleElement(property, position, parent);
//    			case "Argument": return this.InsertedFromArgument(property, position, parent);
//    			case "NameColon": return this.InsertedFromNameColon(property, position, parent);
//    			case "AnonymousObjectMemberDeclarator": return this.InsertedFromAnonymousObjectMemberDeclarator(property, position, parent);
//    			case "QueryBody": return this.InsertedFromQueryBody(property, position, parent);
//    			case "JoinIntoClause": return this.InsertedFromJoinIntoClause(property, position, parent);
//    			case "Ordering": return this.InsertedFromOrdering(property, position, parent);
//    			case "QueryContinuation": return this.InsertedFromQueryContinuation(property, position, parent);
//    			case "WhenClause": return this.InsertedFromWhenClause(property, position, parent);
//    			case "InterpolationAlignmentClause": return this.InsertedFromInterpolationAlignmentClause(property, position, parent);
//    			case "InterpolationFormatClause": return this.InsertedFromInterpolationFormatClause(property, position, parent);
//    			case "VariableDeclaration": return this.InsertedFromVariableDeclaration(property, position, parent);
//    			case "VariableDeclarator": return this.InsertedFromVariableDeclarator(property, position, parent);
//    			case "EqualsValueClause": return this.InsertedFromEqualsValueClause(property, position, parent);
//    			case "ElseClause": return this.InsertedFromElseClause(property, position, parent);
//    			case "SwitchSection": return this.InsertedFromSwitchSection(property, position, parent);
//    			case "CatchClause": return this.InsertedFromCatchClause(property, position, parent);
//    			case "CatchDeclaration": return this.InsertedFromCatchDeclaration(property, position, parent);
//    			case "CatchFilterClause": return this.InsertedFromCatchFilterClause(property, position, parent);
//    			case "FinallyClause": return this.InsertedFromFinallyClause(property, position, parent);
//    			case "CompilationUnit": return this.InsertedFromCompilationUnit(property, position, parent);
//    			case "ExternAliasDirective": return this.InsertedFromExternAliasDirective(property, position, parent);
//    			case "UsingDirective": return this.InsertedFromUsingDirective(property, position, parent);
//    			case "AttributeList": return this.InsertedFromAttributeList(property, position, parent);
//    			case "AttributeTargetSpecifier": return this.InsertedFromAttributeTargetSpecifier(property, position, parent);
//    			case "Attribute": return this.InsertedFromAttribute(property, position, parent);
//    			case "AttributeArgumentList": return this.InsertedFromAttributeArgumentList(property, position, parent);
//    			case "DelegateDeclaration": return this.InsertedFromDelegateDeclaration(property, position, parent);
//    			case "EnumMemberDeclaration": return this.InsertedFromEnumMemberDeclaration(property, position, parent);
//    			case "IncompleteMember": return this.InsertedFromIncompleteMember(property, position, parent);
//    			case "GlobalStatement": return this.InsertedFromGlobalStatement(property, position, parent);
//    			case "NamespaceDeclaration": return this.InsertedFromNamespaceDeclaration(property, position, parent);
//    			case "EnumDeclaration": return this.InsertedFromEnumDeclaration(property, position, parent);
//    			case "ClassDeclaration": return this.InsertedFromClassDeclaration(property, position, parent);
//    			case "StructDeclaration": return this.InsertedFromStructDeclaration(property, position, parent);
//    			case "InterfaceDeclaration": return this.InsertedFromInterfaceDeclaration(property, position, parent);
//    			case "FieldDeclaration": return this.InsertedFromFieldDeclaration(property, position, parent);
//    			case "EventFieldDeclaration": return this.InsertedFromEventFieldDeclaration(property, position, parent);
//    			case "MethodDeclaration": return this.InsertedFromMethodDeclaration(property, position, parent);
//    			case "OperatorDeclaration": return this.InsertedFromOperatorDeclaration(property, position, parent);
//    			case "ConversionOperatorDeclaration": return this.InsertedFromConversionOperatorDeclaration(property, position, parent);
//    			case "ConstructorDeclaration": return this.InsertedFromConstructorDeclaration(property, position, parent);
//    			case "DestructorDeclaration": return this.InsertedFromDestructorDeclaration(property, position, parent);
//    			case "PropertyDeclaration": return this.InsertedFromPropertyDeclaration(property, position, parent);
//    			case "EventDeclaration": return this.InsertedFromEventDeclaration(property, position, parent);
//    			case "IndexerDeclaration": return this.InsertedFromIndexerDeclaration(property, position, parent);
//    			case "SimpleBaseType": return this.InsertedFromSimpleBaseType(property, position, parent);
//    			case "ConstructorConstraint": return this.InsertedFromConstructorConstraint(property, position, parent);
//    			case "ClassOrStructConstraint": return this.InsertedFromClassOrStructConstraint(property, position, parent);
//    			case "TypeConstraint": return this.InsertedFromTypeConstraint(property, position, parent);
//    			case "ParameterList": return this.InsertedFromParameterList(property, position, parent);
//    			case "BracketedParameterList": return this.InsertedFromBracketedParameterList(property, position, parent);
//    			case "SkippedTokensTrivia": return this.InsertedFromSkippedTokensTrivia(property, position, parent);
//    			case "DocumentationCommentTrivia": return this.InsertedFromDocumentationCommentTrivia(property, position, parent);
//    			case "EndIfDirectiveTrivia": return this.InsertedFromEndIfDirectiveTrivia(property, position, parent);
//    			case "RegionDirectiveTrivia": return this.InsertedFromRegionDirectiveTrivia(property, position, parent);
//    			case "EndRegionDirectiveTrivia": return this.InsertedFromEndRegionDirectiveTrivia(property, position, parent);
//    			case "ErrorDirectiveTrivia": return this.InsertedFromErrorDirectiveTrivia(property, position, parent);
//    			case "WarningDirectiveTrivia": return this.InsertedFromWarningDirectiveTrivia(property, position, parent);
//    			case "BadDirectiveTrivia": return this.InsertedFromBadDirectiveTrivia(property, position, parent);
//    			case "DefineDirectiveTrivia": return this.InsertedFromDefineDirectiveTrivia(property, position, parent);
//    			case "UndefDirectiveTrivia": return this.InsertedFromUndefDirectiveTrivia(property, position, parent);
//    			case "LineDirectiveTrivia": return this.InsertedFromLineDirectiveTrivia(property, position, parent);
//    			case "PragmaWarningDirectiveTrivia": return this.InsertedFromPragmaWarningDirectiveTrivia(property, position, parent);
//    			case "PragmaChecksumDirectiveTrivia": return this.InsertedFromPragmaChecksumDirectiveTrivia(property, position, parent);
//    			case "ReferenceDirectiveTrivia": return this.InsertedFromReferenceDirectiveTrivia(property, position, parent);
//    			case "LoadDirectiveTrivia": return this.InsertedFromLoadDirectiveTrivia(property, position, parent);
//    			case "ShebangDirectiveTrivia": return this.InsertedFromShebangDirectiveTrivia(property, position, parent);
//    			case "ElseDirectiveTrivia": return this.InsertedFromElseDirectiveTrivia(property, position, parent);
//    			case "IfDirectiveTrivia": return this.InsertedFromIfDirectiveTrivia(property, position, parent);
//    			case "ElifDirectiveTrivia": return this.InsertedFromElifDirectiveTrivia(property, position, parent);
//    			case "TypeCref": return this.InsertedFromTypeCref(property, position, parent);
//    			case "QualifiedCref": return this.InsertedFromQualifiedCref(property, position, parent);
//    			case "NameMemberCref": return this.InsertedFromNameMemberCref(property, position, parent);
//    			case "IndexerMemberCref": return this.InsertedFromIndexerMemberCref(property, position, parent);
//    			case "OperatorMemberCref": return this.InsertedFromOperatorMemberCref(property, position, parent);
//    			case "ConversionOperatorMemberCref": return this.InsertedFromConversionOperatorMemberCref(property, position, parent);
//    			case "CrefParameterList": return this.InsertedFromCrefParameterList(property, position, parent);
//    			case "CrefBracketedParameterList": return this.InsertedFromCrefBracketedParameterList(property, position, parent);
//    			case "XmlElement": return this.InsertedFromXmlElement(property, position, parent);
//    			case "XmlEmptyElement": return this.InsertedFromXmlEmptyElement(property, position, parent);
//    			case "XmlText": return this.InsertedFromXmlText(property, position, parent);
//    			case "XmlCDataSection": return this.InsertedFromXmlCDataSection(property, position, parent);
//    			case "XmlProcessingInstruction": return this.InsertedFromXmlProcessingInstruction(property, position, parent);
//    			case "XmlComment": return this.InsertedFromXmlComment(property, position, parent);
//    			case "XmlTextAttribute": return this.InsertedFromXmlTextAttribute(property, position, parent);
//    			case "XmlCrefAttribute": return this.InsertedFromXmlCrefAttribute(property, position, parent);
//    			case "XmlNameAttribute": return this.InsertedFromXmlNameAttribute(property, position, parent);
//    			case "ParenthesizedExpression": return this.InsertedFromParenthesizedExpression(property, position, parent);
//    			case "TupleExpression": return this.InsertedFromTupleExpression(property, position, parent);
//    			case "PrefixUnaryExpression": return this.InsertedFromPrefixUnaryExpression(property, position, parent);
//    			case "AwaitExpression": return this.InsertedFromAwaitExpression(property, position, parent);
//    			case "PostfixUnaryExpression": return this.InsertedFromPostfixUnaryExpression(property, position, parent);
//    			case "MemberAccessExpression": return this.InsertedFromMemberAccessExpression(property, position, parent);
//    			case "ConditionalAccessExpression": return this.InsertedFromConditionalAccessExpression(property, position, parent);
//    			case "MemberBindingExpression": return this.InsertedFromMemberBindingExpression(property, position, parent);
//    			case "ElementBindingExpression": return this.InsertedFromElementBindingExpression(property, position, parent);
//    			case "ImplicitElementAccess": return this.InsertedFromImplicitElementAccess(property, position, parent);
//    			case "BinaryExpression": return this.InsertedFromBinaryExpression(property, position, parent);
//    			case "AssignmentExpression": return this.InsertedFromAssignmentExpression(property, position, parent);
//    			case "ConditionalExpression": return this.InsertedFromConditionalExpression(property, position, parent);
//    			case "LiteralExpression": return this.InsertedFromLiteralExpression(property, position, parent);
//    			case "MakeRefExpression": return this.InsertedFromMakeRefExpression(property, position, parent);
//    			case "RefTypeExpression": return this.InsertedFromRefTypeExpression(property, position, parent);
//    			case "RefValueExpression": return this.InsertedFromRefValueExpression(property, position, parent);
//    			case "CheckedExpression": return this.InsertedFromCheckedExpression(property, position, parent);
//    			case "DefaultExpression": return this.InsertedFromDefaultExpression(property, position, parent);
//    			case "TypeOfExpression": return this.InsertedFromTypeOfExpression(property, position, parent);
//    			case "SizeOfExpression": return this.InsertedFromSizeOfExpression(property, position, parent);
//    			case "InvocationExpression": return this.InsertedFromInvocationExpression(property, position, parent);
//    			case "ElementAccessExpression": return this.InsertedFromElementAccessExpression(property, position, parent);
//    			case "DeclarationExpression": return this.InsertedFromDeclarationExpression(property, position, parent);
//    			case "CastExpression": return this.InsertedFromCastExpression(property, position, parent);
//    			case "RefExpression": return this.InsertedFromRefExpression(property, position, parent);
//    			case "InitializerExpression": return this.InsertedFromInitializerExpression(property, position, parent);
//    			case "ObjectCreationExpression": return this.InsertedFromObjectCreationExpression(property, position, parent);
//    			case "AnonymousObjectCreationExpression": return this.InsertedFromAnonymousObjectCreationExpression(property, position, parent);
//    			case "ArrayCreationExpression": return this.InsertedFromArrayCreationExpression(property, position, parent);
//    			case "ImplicitArrayCreationExpression": return this.InsertedFromImplicitArrayCreationExpression(property, position, parent);
//    			case "StackAllocArrayCreationExpression": return this.InsertedFromStackAllocArrayCreationExpression(property, position, parent);
//    			case "QueryExpression": return this.InsertedFromQueryExpression(property, position, parent);
//    			case "OmittedArraySizeExpression": return this.InsertedFromOmittedArraySizeExpression(property, position, parent);
//    			case "InterpolatedStringExpression": return this.InsertedFromInterpolatedStringExpression(property, position, parent);
//    			case "IsPatternExpression": return this.InsertedFromIsPatternExpression(property, position, parent);
//    			case "ThrowExpression": return this.InsertedFromThrowExpression(property, position, parent);
//    			case "PredefinedType": return this.InsertedFromPredefinedType(property, position, parent);
//    			case "ArrayType": return this.InsertedFromArrayType(property, position, parent);
//    			case "PointerType": return this.InsertedFromPointerType(property, position, parent);
//    			case "NullableType": return this.InsertedFromNullableType(property, position, parent);
//    			case "TupleType": return this.InsertedFromTupleType(property, position, parent);
//    			case "OmittedTypeArgument": return this.InsertedFromOmittedTypeArgument(property, position, parent);
//    			case "RefType": return this.InsertedFromRefType(property, position, parent);
//    			case "QualifiedName": return this.InsertedFromQualifiedName(property, position, parent);
//    			case "AliasQualifiedName": return this.InsertedFromAliasQualifiedName(property, position, parent);
//    			case "IdentifierName": return this.InsertedFromIdentifierName(property, position, parent);
//    			case "GenericName": return this.InsertedFromGenericName(property, position, parent);
//    			case "ThisExpression": return this.InsertedFromThisExpression(property, position, parent);
//    			case "BaseExpression": return this.InsertedFromBaseExpression(property, position, parent);
//    			case "AnonymousMethodExpression": return this.InsertedFromAnonymousMethodExpression(property, position, parent);
//    			case "SimpleLambdaExpression": return this.InsertedFromSimpleLambdaExpression(property, position, parent);
//    			case "ParenthesizedLambdaExpression": return this.InsertedFromParenthesizedLambdaExpression(property, position, parent);
//    			case "ArgumentList": return this.InsertedFromArgumentList(property, position, parent);
//    			case "BracketedArgumentList": return this.InsertedFromBracketedArgumentList(property, position, parent);
//    			case "FromClause": return this.InsertedFromFromClause(property, position, parent);
//    			case "LetClause": return this.InsertedFromLetClause(property, position, parent);
//    			case "JoinClause": return this.InsertedFromJoinClause(property, position, parent);
//    			case "WhereClause": return this.InsertedFromWhereClause(property, position, parent);
//    			case "OrderByClause": return this.InsertedFromOrderByClause(property, position, parent);
//    			case "SelectClause": return this.InsertedFromSelectClause(property, position, parent);
//    			case "GroupClause": return this.InsertedFromGroupClause(property, position, parent);
//    			case "DeclarationPattern": return this.InsertedFromDeclarationPattern(property, position, parent);
//    			case "ConstantPattern": return this.InsertedFromConstantPattern(property, position, parent);
//    			case "InterpolatedStringText": return this.InsertedFromInterpolatedStringText(property, position, parent);
//    			case "Interpolation": return this.InsertedFromInterpolation(property, position, parent);
//    			case "Block": return this.InsertedFromBlock(property, position, parent);
//    			case "LocalFunctionStatement": return this.InsertedFromLocalFunctionStatement(property, position, parent);
//    			case "LocalDeclarationStatement": return this.InsertedFromLocalDeclarationStatement(property, position, parent);
//    			case "ExpressionStatement": return this.InsertedFromExpressionStatement(property, position, parent);
//    			case "EmptyStatement": return this.InsertedFromEmptyStatement(property, position, parent);
//    			case "LabeledStatement": return this.InsertedFromLabeledStatement(property, position, parent);
//    			case "GotoStatement": return this.InsertedFromGotoStatement(property, position, parent);
//    			case "BreakStatement": return this.InsertedFromBreakStatement(property, position, parent);
//    			case "ContinueStatement": return this.InsertedFromContinueStatement(property, position, parent);
//    			case "ReturnStatement": return this.InsertedFromReturnStatement(property, position, parent);
//    			case "ThrowStatement": return this.InsertedFromThrowStatement(property, position, parent);
//    			case "YieldStatement": return this.InsertedFromYieldStatement(property, position, parent);
//    			case "WhileStatement": return this.InsertedFromWhileStatement(property, position, parent);
//    			case "DoStatement": return this.InsertedFromDoStatement(property, position, parent);
//    			case "ForStatement": return this.InsertedFromForStatement(property, position, parent);
//    			case "UsingStatement": return this.InsertedFromUsingStatement(property, position, parent);
//    			case "FixedStatement": return this.InsertedFromFixedStatement(property, position, parent);
//    			case "CheckedStatement": return this.InsertedFromCheckedStatement(property, position, parent);
//    			case "UnsafeStatement": return this.InsertedFromUnsafeStatement(property, position, parent);
//    			case "LockStatement": return this.InsertedFromLockStatement(property, position, parent);
//    			case "IfStatement": return this.InsertedFromIfStatement(property, position, parent);
//    			case "SwitchStatement": return this.InsertedFromSwitchStatement(property, position, parent);
//    			case "TryStatement": return this.InsertedFromTryStatement(property, position, parent);
//    			case "ForEachStatement": return this.InsertedFromForEachStatement(property, position, parent);
//    			case "ForEachVariableStatement": return this.InsertedFromForEachVariableStatement(property, position, parent);
//    			case "SingleVariableDesignation": return this.InsertedFromSingleVariableDesignation(property, position, parent);
//    			case "DiscardDesignation": return this.InsertedFromDiscardDesignation(property, position, parent);
//    			case "ParenthesizedVariableDesignation": return this.InsertedFromParenthesizedVariableDesignation(property, position, parent);
//    			case "CasePatternSwitchLabel": return this.InsertedFromCasePatternSwitchLabel(property, position, parent);
//    			case "CaseSwitchLabel": return this.InsertedFromCaseSwitchLabel(property, position, parent);
//    			case "DefaultSwitchLabel": return this.InsertedFromDefaultSwitchLabel(property, position, parent);
//                case "SingleLineCommentTrivia": return this.InsertedFromSingleLineCommentTrivia(property, position, parent);
//                case "MultiLineCommentTrivia": return this.InsertedFromMultiLineCommentTrivia(property, position, parent);
//    			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
//    		}
//    	}		
    	
//        /// <summary>
//        /// Analyzes a insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> Inserted(XElement property, int position, XElement parent)
//        {
//            IEnumerable<Imprecision> result = new Imprecision[0];
//        	var ignoreCore = false;
//        	InsertedBefore(property, position, parent, ref result, ref ignoreCore);
//        	if(ignoreCore) 
//        		return result;
        	
//        	result = this.InsertedCore(property, position, parent);
//        	InsertedAfter(property, position, parent, ref result);
//        	return result;
//        }
    
//    	#endregion
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAttributeArgument(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeArgument(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAttributeArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAttributeArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAttributeArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAttributeArgumentCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeArgumentCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAttributeArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAttributeArgument(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeArgumentCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeArgument(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAttributeArgumentBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAttributeArgumentCore(property, position, parent);
//    		InsertedFromAttributeArgumentAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAttributeArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAttributeArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAttributeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAttributeArgumentBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAttributeArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeArgumentCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAttributeArgumentAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAttributeArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeArgumentCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeArgument(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAttributeArgumentBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAttributeArgumentCore(property, parent);
//    		DeletedFromAttributeArgumentAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAttributeArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAttributeArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAttributeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAttributeArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAttributeArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeArgumentCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAttributeArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAttributeArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeArgumentCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeArgument(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAttributeArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAttributeArgumentCore(oldElement, newElement);
//    		UpdatedFromAttributeArgumentAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAttributeArgument(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeArgument(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAttributeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAttributeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAttributeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAttributeArgumentCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAttributeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAttributeArgument(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeArgument(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAttributeArgumentBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAttributeArgumentCore(property, oldPArent, position, newParent);
//    		MovedFromAttributeArgumentAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromNameEquals(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameEquals(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromNameEqualsCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromNameEquals(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromNameEqualsBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromNameEqualsCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameEqualsCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromNameEqualsAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromNameEquals(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromNameEqualsCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromNameEquals(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromNameEqualsBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromNameEqualsCore(property, position, parent);
//    		InsertedFromNameEqualsAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromNameEquals(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameEquals(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromNameEqualsCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromNameEquals(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromNameEqualsBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromNameEqualsCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameEqualsCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromNameEqualsAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromNameEquals(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromNameEqualsCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromNameEquals(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromNameEqualsBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromNameEqualsCore(property, parent);
//    		DeletedFromNameEqualsAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromNameEquals(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameEquals(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromNameEqualsCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromNameEquals(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromNameEqualsBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromNameEqualsCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameEqualsCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromNameEqualsAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromNameEquals(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameEqualsCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameEquals(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromNameEqualsBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromNameEqualsCore(oldElement, newElement);
//    		UpdatedFromNameEqualsAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromNameEquals(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameEquals(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromNameEqualsCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromNameEquals(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromNameEqualsBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromNameEqualsCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameEqualsCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromNameEqualsAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromNameEquals(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromNameEqualsCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromNameEquals(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromNameEqualsBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromNameEqualsCore(property, oldPArent, position, newParent);
//    		MovedFromNameEqualsAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeParameterList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameterList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeParameterListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameterListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeParameterList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameterListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameterList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeParameterListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeParameterListCore(property, position, parent);
//    		InsertedFromTypeParameterListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeParameterListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameterListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeParameterListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameterListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameterList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeParameterListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeParameterListCore(property, parent);
//    		DeletedFromTypeParameterListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameterListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameterListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameterList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeParameterListCore(oldElement, newElement);
//    		UpdatedFromTypeParameterListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeParameterList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameterList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeParameterListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameterListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeParameterList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameterList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeParameterListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeParameterListCore(property, oldPArent, position, newParent);
//    		MovedFromTypeParameterListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeParameter(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameter(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeParameterCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameterCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeParameter(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameterCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "VarianceKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameter(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeParameterBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeParameterCore(property, position, parent);
//    		InsertedFromTypeParameterAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeParameterBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameterCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeParameterAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameterCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "VarianceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameter(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeParameterBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeParameterCore(property, parent);
//    		DeletedFromTypeParameterAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameterCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameterCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "VarianceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameter(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeParameterCore(oldElement, newElement);
//    		UpdatedFromTypeParameterAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeParameter(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameter(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeParameterCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameterCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeParameter(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "VarianceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameter(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeParameterBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeParameterCore(property, oldPArent, position, newParent);
//    		MovedFromTypeParameterAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBaseList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBaseList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBaseListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBaseList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBaseListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBaseListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBaseListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBaseListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBaseList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBaseListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBaseList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBaseListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBaseListCore(property, position, parent);
//    		InsertedFromBaseListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBaseList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBaseList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBaseListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBaseList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBaseListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBaseListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBaseListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBaseListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBaseList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBaseListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBaseList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBaseListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBaseListCore(property, parent);
//    		DeletedFromBaseListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBaseList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBaseList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBaseListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBaseList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBaseListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBaseListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBaseListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBaseListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBaseList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBaseListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBaseList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBaseListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBaseListCore(oldElement, newElement);
//    		UpdatedFromBaseListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBaseList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBaseList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBaseListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBaseList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBaseListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBaseListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBaseListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBaseListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBaseList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBaseListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBaseList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBaseListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBaseListCore(property, oldPArent, position, newParent);
//    		MovedFromBaseListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeParameterConstraintClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameterConstraintClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeParameterConstraintClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeParameterConstraintClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeParameterConstraintClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeParameterConstraintClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeParameterConstraintClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeParameterConstraintClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeParameterConstraintClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameterConstraintClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeParameterConstraintClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeParameterConstraintClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeParameterConstraintClauseCore(property, position, parent);
//    		InsertedFromTypeParameterConstraintClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeParameterConstraintClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameterConstraintClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeParameterConstraintClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeParameterConstraintClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeParameterConstraintClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeParameterConstraintClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeParameterConstraintClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeParameterConstraintClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeParameterConstraintClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameterConstraintClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeParameterConstraintClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeParameterConstraintClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeParameterConstraintClauseCore(property, parent);
//    		DeletedFromTypeParameterConstraintClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeParameterConstraintClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameterConstraintClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeParameterConstraintClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeParameterConstraintClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeParameterConstraintClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeParameterConstraintClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeParameterConstraintClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeParameterConstraintClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeParameterConstraintClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameterConstraintClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeParameterConstraintClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeParameterConstraintClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeParameterConstraintClauseCore(oldElement, newElement);
//    		UpdatedFromTypeParameterConstraintClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeParameterConstraintClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeParameterConstraintClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeParameterConstraintClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeParameterConstraintClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeParameterConstraintClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameterConstraintClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeParameterConstraintClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeParameterConstraintClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeParameterConstraintClauseCore(property, oldPArent, position, newParent);
//    		MovedFromTypeParameterConstraintClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromExplicitInterfaceSpecifier(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExplicitInterfaceSpecifier(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromExplicitInterfaceSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromExplicitInterfaceSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromExplicitInterfaceSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromExplicitInterfaceSpecifierCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExplicitInterfaceSpecifierCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromExplicitInterfaceSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromExplicitInterfaceSpecifier(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromExplicitInterfaceSpecifierCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromExplicitInterfaceSpecifier(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromExplicitInterfaceSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromExplicitInterfaceSpecifierCore(property, position, parent);
//    		InsertedFromExplicitInterfaceSpecifierAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromExplicitInterfaceSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromExplicitInterfaceSpecifierBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromExplicitInterfaceSpecifierAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromExplicitInterfaceSpecifierCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromExplicitInterfaceSpecifier(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromExplicitInterfaceSpecifierBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromExplicitInterfaceSpecifierCore(property, parent);
//    		DeletedFromExplicitInterfaceSpecifierAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromExplicitInterfaceSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromExplicitInterfaceSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExplicitInterfaceSpecifierCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromExplicitInterfaceSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromExplicitInterfaceSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromExplicitInterfaceSpecifierCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromExplicitInterfaceSpecifier(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromExplicitInterfaceSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromExplicitInterfaceSpecifierCore(oldElement, newElement);
//    		UpdatedFromExplicitInterfaceSpecifierAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromExplicitInterfaceSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExplicitInterfaceSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromExplicitInterfaceSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromExplicitInterfaceSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromExplicitInterfaceSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromExplicitInterfaceSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromExplicitInterfaceSpecifierBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromExplicitInterfaceSpecifierCore(property, oldPArent, position, newParent);
//    		MovedFromExplicitInterfaceSpecifierAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConstructorInitializer(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorInitializer(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConstructorInitializerCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConstructorInitializer(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConstructorInitializerBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConstructorInitializerCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorInitializerCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConstructorInitializerAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConstructorInitializer(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorInitializerCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorInitializer(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConstructorInitializerBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConstructorInitializerCore(property, position, parent);
//    		InsertedFromConstructorInitializerAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConstructorInitializer(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorInitializer(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConstructorInitializerCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConstructorInitializer(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConstructorInitializerBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConstructorInitializerCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorInitializerCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConstructorInitializerAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConstructorInitializer(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorInitializerCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorInitializer(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConstructorInitializerBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConstructorInitializerCore(property, parent);
//    		DeletedFromConstructorInitializerAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConstructorInitializer(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorInitializer(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConstructorInitializerCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConstructorInitializer(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConstructorInitializerBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConstructorInitializerCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorInitializerCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConstructorInitializerAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConstructorInitializer(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorInitializerCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorInitializer(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConstructorInitializerBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConstructorInitializerCore(oldElement, newElement);
//    		UpdatedFromConstructorInitializerAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConstructorInitializer(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorInitializer(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConstructorInitializerCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConstructorInitializer(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConstructorInitializerBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConstructorInitializerCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorInitializerCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConstructorInitializerAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConstructorInitializer(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorInitializerCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ThisOrBaseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorInitializer(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConstructorInitializerBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConstructorInitializerCore(property, oldPArent, position, newParent);
//    		MovedFromConstructorInitializerAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArrowExpressionClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrowExpressionClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArrowExpressionClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArrowExpressionClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArrowExpressionClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArrowExpressionClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrowExpressionClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArrowExpressionClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArrowExpressionClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArrowExpressionClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArrowExpressionClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArrowExpressionClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArrowExpressionClauseCore(property, position, parent);
//    		InsertedFromArrowExpressionClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArrowExpressionClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrowExpressionClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArrowExpressionClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArrowExpressionClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArrowExpressionClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArrowExpressionClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrowExpressionClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArrowExpressionClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArrowExpressionClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArrowExpressionClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArrowExpressionClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArrowExpressionClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArrowExpressionClauseCore(property, parent);
//    		DeletedFromArrowExpressionClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArrowExpressionClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrowExpressionClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArrowExpressionClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArrowExpressionClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArrowExpressionClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArrowExpressionClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrowExpressionClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArrowExpressionClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArrowExpressionClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrowExpressionClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrowExpressionClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArrowExpressionClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArrowExpressionClauseCore(oldElement, newElement);
//    		UpdatedFromArrowExpressionClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArrowExpressionClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrowExpressionClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArrowExpressionClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArrowExpressionClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArrowExpressionClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrowExpressionClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArrowExpressionClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArrowExpressionClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArrowExpressionClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArrowExpressionClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArrowExpressionClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArrowExpressionClauseCore(property, oldPArent, position, newParent);
//    		MovedFromArrowExpressionClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAccessorList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAccessorList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAccessorListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAccessorList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAccessorListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAccessorListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAccessorListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAccessorListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAccessorList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAccessorListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAccessorList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAccessorListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAccessorListCore(property, position, parent);
//    		InsertedFromAccessorListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAccessorList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAccessorList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAccessorListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAccessorList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAccessorListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAccessorListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAccessorListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAccessorListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAccessorList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAccessorListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAccessorList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAccessorListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAccessorListCore(property, parent);
//    		DeletedFromAccessorListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAccessorList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAccessorList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAccessorListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAccessorList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAccessorListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAccessorListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAccessorListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAccessorListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAccessorList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAccessorListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAccessorList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAccessorListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAccessorListCore(oldElement, newElement);
//    		UpdatedFromAccessorListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAccessorList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAccessorList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAccessorListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAccessorList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAccessorListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAccessorListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAccessorListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAccessorListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAccessorList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAccessorListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAccessorList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAccessorListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAccessorListCore(property, oldPArent, position, newParent);
//    		MovedFromAccessorListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAccessorDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAccessorDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAccessorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAccessorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAccessorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAccessorDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAccessorDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAccessorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAccessorDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAccessorDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAccessorDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAccessorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAccessorDeclarationCore(property, position, parent);
//    		InsertedFromAccessorDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAccessorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAccessorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAccessorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAccessorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAccessorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAccessorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAccessorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAccessorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAccessorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAccessorDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAccessorDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAccessorDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAccessorDeclarationCore(property, parent);
//    		DeletedFromAccessorDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAccessorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAccessorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAccessorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAccessorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAccessorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAccessorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAccessorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAccessorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAccessorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAccessorDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAccessorDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAccessorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAccessorDeclarationCore(oldElement, newElement);
//    		UpdatedFromAccessorDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAccessorDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAccessorDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAccessorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAccessorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAccessorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAccessorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAccessorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAccessorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAccessorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAccessorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAccessorDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAccessorDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromAccessorDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromParameter(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParameter(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromParameterCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParameterCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromParameter(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromParameterCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromParameter(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromParameterBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromParameterCore(property, position, parent);
//    		InsertedFromParameterAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromParameterBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParameterCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromParameterAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromParameterCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromParameter(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromParameterBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromParameterCore(property, parent);
//    		DeletedFromParameterAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParameterCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromParameterCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromParameter(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromParameterCore(oldElement, newElement);
//    		UpdatedFromParameterAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromParameter(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParameter(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromParameterCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParameterCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromParameter(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromParameter(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromParameterBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromParameterCore(property, oldPArent, position, newParent);
//    		MovedFromParameterAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCrefParameter(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefParameter(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCrefParameterCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCrefParameter(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCrefParameterBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCrefParameterCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefParameterCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCrefParameterAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCrefParameter(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefParameterCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefParameter(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCrefParameterBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCrefParameterCore(property, position, parent);
//    		InsertedFromCrefParameterAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCrefParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCrefParameterCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCrefParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCrefParameterBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCrefParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefParameterCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCrefParameterAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCrefParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefParameterCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefParameter(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCrefParameterBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCrefParameterCore(property, parent);
//    		DeletedFromCrefParameterAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCrefParameter(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefParameter(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCrefParameterCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCrefParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCrefParameterBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCrefParameterCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefParameterCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCrefParameterAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCrefParameter(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefParameterCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefParameter(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCrefParameterBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCrefParameterCore(oldElement, newElement);
//    		UpdatedFromCrefParameterAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCrefParameter(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefParameter(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCrefParameterCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCrefParameter(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCrefParameterBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCrefParameterCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefParameterCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCrefParameterAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCrefParameter(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCrefParameterCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCrefParameter(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCrefParameterBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCrefParameterCore(property, oldPArent, position, newParent);
//    		MovedFromCrefParameterAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlElementStartTag(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElementStartTag(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlElementStartTagCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlElementStartTag(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlElementStartTagBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlElementStartTagCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElementStartTagCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlElementStartTagAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlElementStartTag(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElementStartTagCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElementStartTag(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlElementStartTagBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlElementStartTagCore(property, position, parent);
//    		InsertedFromXmlElementStartTagAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlElementStartTag(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElementStartTag(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlElementStartTagCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlElementStartTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlElementStartTagBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlElementStartTagCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElementStartTagCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlElementStartTagAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlElementStartTag(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElementStartTagCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElementStartTag(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlElementStartTagBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlElementStartTagCore(property, parent);
//    		DeletedFromXmlElementStartTagAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlElementStartTag(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElementStartTag(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlElementStartTagCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlElementStartTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlElementStartTagBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlElementStartTagCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElementStartTagCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlElementStartTagAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlElementStartTag(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElementStartTagCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElementStartTag(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlElementStartTagBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlElementStartTagCore(oldElement, newElement);
//    		UpdatedFromXmlElementStartTagAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlElementStartTag(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElementStartTag(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlElementStartTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlElementStartTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlElementStartTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElementStartTagCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlElementStartTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlElementStartTag(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElementStartTagCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElementStartTag(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlElementStartTagBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlElementStartTagCore(property, oldPArent, position, newParent);
//    		MovedFromXmlElementStartTagAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlElementEndTag(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElementEndTag(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlElementEndTagCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlElementEndTag(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlElementEndTagBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlElementEndTagCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElementEndTagCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlElementEndTagAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlElementEndTag(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElementEndTagCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElementEndTag(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlElementEndTagBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlElementEndTagCore(property, position, parent);
//    		InsertedFromXmlElementEndTagAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlElementEndTag(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElementEndTag(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlElementEndTagCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlElementEndTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlElementEndTagBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlElementEndTagCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElementEndTagCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlElementEndTagAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlElementEndTag(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElementEndTagCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElementEndTag(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlElementEndTagBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlElementEndTagCore(property, parent);
//    		DeletedFromXmlElementEndTagAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlElementEndTag(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElementEndTag(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlElementEndTagCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlElementEndTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlElementEndTagBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlElementEndTagCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElementEndTagCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlElementEndTagAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlElementEndTag(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElementEndTagCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElementEndTag(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlElementEndTagBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlElementEndTagCore(oldElement, newElement);
//    		UpdatedFromXmlElementEndTagAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlElementEndTag(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElementEndTag(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlElementEndTagCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlElementEndTag(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlElementEndTagBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElementEndTagCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlElementEndTagAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlElementEndTag(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElementEndTagCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanSlashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElementEndTag(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlElementEndTagBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlElementEndTagCore(property, oldPArent, position, newParent);
//    		MovedFromXmlElementEndTagAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlName(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlName(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlNameBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlNameCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlNameCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlNameAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlName(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlNameCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlName(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlNameBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlNameCore(property, position, parent);
//    		InsertedFromXmlNameAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlNameBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlNameCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlNameAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlNameCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlName(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlNameBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlNameCore(property, parent);
//    		DeletedFromXmlNameAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlNameCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlNameCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlName(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlNameBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlNameCore(oldElement, newElement);
//    		UpdatedFromXmlNameAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlName(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlName(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlNameCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlNameCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlName(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlNameCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlName(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlNameBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlNameCore(property, oldPArent, position, newParent);
//    		MovedFromXmlNameAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlPrefix(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlPrefix(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlPrefixCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlPrefix(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlPrefixBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlPrefixCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlPrefixCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlPrefixAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlPrefix(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlPrefixCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlPrefix(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlPrefixBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlPrefixCore(property, position, parent);
//    		InsertedFromXmlPrefixAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlPrefix(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlPrefix(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlPrefixCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlPrefix(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlPrefixBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlPrefixCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlPrefixCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlPrefixAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlPrefix(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlPrefixCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlPrefix(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlPrefixBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlPrefixCore(property, parent);
//    		DeletedFromXmlPrefixAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlPrefix(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlPrefix(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlPrefixCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlPrefix(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlPrefixBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlPrefixCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlPrefixCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlPrefixAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlPrefix(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlPrefixCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlPrefix(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlPrefixBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlPrefixCore(oldElement, newElement);
//    		UpdatedFromXmlPrefixAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlPrefix(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlPrefix(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlPrefixCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlPrefix(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlPrefixBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlPrefixCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlPrefixCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlPrefixAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlPrefix(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlPrefixCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlPrefix(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlPrefixBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlPrefixCore(property, oldPArent, position, newParent);
//    		MovedFromXmlPrefixAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeArgumentList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeArgumentList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeArgumentListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeArgumentListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeArgumentList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeArgumentListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeArgumentList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeArgumentListCore(property, position, parent);
//    		InsertedFromTypeArgumentListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeArgumentListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeArgumentListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeArgumentListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeArgumentListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeArgumentList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeArgumentListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeArgumentListCore(property, parent);
//    		DeletedFromTypeArgumentListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeArgumentListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeArgumentListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeArgumentList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeArgumentListCore(oldElement, newElement);
//    		UpdatedFromTypeArgumentListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeArgumentList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeArgumentList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeArgumentListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "GreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeArgumentListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeArgumentListCore(property, oldPArent, position, newParent);
//    		MovedFromTypeArgumentListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArrayRankSpecifier(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayRankSpecifier(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArrayRankSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArrayRankSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArrayRankSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArrayRankSpecifierCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayRankSpecifierCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArrayRankSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArrayRankSpecifier(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayRankSpecifierCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayRankSpecifier(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArrayRankSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArrayRankSpecifierCore(property, position, parent);
//    		InsertedFromArrayRankSpecifierAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArrayRankSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayRankSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArrayRankSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArrayRankSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArrayRankSpecifierBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArrayRankSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayRankSpecifierCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArrayRankSpecifierAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArrayRankSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayRankSpecifierCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayRankSpecifier(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArrayRankSpecifierBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArrayRankSpecifierCore(property, parent);
//    		DeletedFromArrayRankSpecifierAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArrayRankSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayRankSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArrayRankSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArrayRankSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArrayRankSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArrayRankSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayRankSpecifierCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArrayRankSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArrayRankSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayRankSpecifierCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayRankSpecifier(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArrayRankSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArrayRankSpecifierCore(oldElement, newElement);
//    		UpdatedFromArrayRankSpecifierAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArrayRankSpecifier(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArrayRankSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArrayRankSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArrayRankSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayRankSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArrayRankSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArrayRankSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArrayRankSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArrayRankSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArrayRankSpecifierBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArrayRankSpecifierCore(property, oldPArent, position, newParent);
//    		MovedFromArrayRankSpecifierAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTupleElement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleElement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTupleElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTupleElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTupleElementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTupleElementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleElementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTupleElementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTupleElement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleElementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleElement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTupleElementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTupleElementCore(property, position, parent);
//    		InsertedFromTupleElementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTupleElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTupleElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTupleElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTupleElementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTupleElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleElementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTupleElementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTupleElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleElementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleElement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTupleElementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTupleElementCore(property, parent);
//    		DeletedFromTupleElementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTupleElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTupleElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTupleElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTupleElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTupleElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleElementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTupleElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTupleElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleElementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleElement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTupleElementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTupleElementCore(oldElement, newElement);
//    		UpdatedFromTupleElementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTupleElement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleElement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTupleElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTupleElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTupleElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTupleElementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleElementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTupleElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTupleElement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTupleElementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTupleElement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTupleElementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTupleElementCore(property, oldPArent, position, newParent);
//    		MovedFromTupleElementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArgument(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArgument(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArgumentCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArgumentCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArgument(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArgumentCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArgument(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArgumentBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArgumentCore(property, position, parent);
//    		InsertedFromArgumentAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArgumentBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArgumentCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArgumentAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArgumentCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArgument(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArgumentBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArgumentCore(property, parent);
//    		DeletedFromArgumentAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArgumentCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArgumentCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArgument(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArgumentCore(oldElement, newElement);
//    		UpdatedFromArgumentAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArgument(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArgument(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArgumentCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArgumentCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArgument(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKindKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArgument(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArgumentBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArgumentCore(property, oldPArent, position, newParent);
//    		MovedFromArgumentAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromNameColon(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameColon(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromNameColonCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromNameColon(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromNameColonBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromNameColonCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameColonCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromNameColonAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromNameColon(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromNameColonCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromNameColon(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromNameColonBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromNameColonCore(property, position, parent);
//    		InsertedFromNameColonAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromNameColon(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameColon(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromNameColonCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromNameColon(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromNameColonBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromNameColonCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameColonCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromNameColonAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromNameColon(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromNameColonCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromNameColon(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromNameColonBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromNameColonCore(property, parent);
//    		DeletedFromNameColonAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromNameColon(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameColon(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromNameColonCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromNameColon(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromNameColonBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromNameColonCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameColonCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromNameColonAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromNameColon(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameColonCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameColon(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromNameColonBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromNameColonCore(oldElement, newElement);
//    		UpdatedFromNameColonAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromNameColon(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameColon(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromNameColonCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromNameColon(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromNameColonBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromNameColonCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameColonCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromNameColonAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromNameColon(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromNameColonCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromNameColon(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromNameColonBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromNameColonCore(property, oldPArent, position, newParent);
//    		MovedFromNameColonAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAnonymousObjectMemberDeclarator(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAnonymousObjectMemberDeclaratorBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousObjectMemberDeclaratorCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAnonymousObjectMemberDeclaratorAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAnonymousObjectMemberDeclarator(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousObjectMemberDeclaratorCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousObjectMemberDeclarator(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAnonymousObjectMemberDeclaratorBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAnonymousObjectMemberDeclaratorCore(property, position, parent);
//    		InsertedFromAnonymousObjectMemberDeclaratorAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAnonymousObjectMemberDeclaratorBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAnonymousObjectMemberDeclaratorAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousObjectMemberDeclaratorCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousObjectMemberDeclarator(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAnonymousObjectMemberDeclaratorBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAnonymousObjectMemberDeclaratorCore(property, parent);
//    		DeletedFromAnonymousObjectMemberDeclaratorAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAnonymousObjectMemberDeclaratorBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAnonymousObjectMemberDeclaratorAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousObjectMemberDeclaratorCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousObjectMemberDeclarator(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAnonymousObjectMemberDeclaratorBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAnonymousObjectMemberDeclaratorCore(oldElement, newElement);
//    		UpdatedFromAnonymousObjectMemberDeclaratorAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAnonymousObjectMemberDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousObjectMemberDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAnonymousObjectMemberDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAnonymousObjectMemberDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousObjectMemberDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousObjectMemberDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAnonymousObjectMemberDeclaratorBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAnonymousObjectMemberDeclaratorCore(property, oldPArent, position, newParent);
//    		MovedFromAnonymousObjectMemberDeclaratorAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromQueryBody(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryBody(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromQueryBodyCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromQueryBody(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromQueryBodyBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromQueryBodyCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryBodyCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromQueryBodyAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromQueryBody(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryBodyCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryBody(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromQueryBodyBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromQueryBodyCore(property, position, parent);
//    		InsertedFromQueryBodyAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromQueryBody(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryBody(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromQueryBodyCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromQueryBody(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromQueryBodyBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromQueryBodyCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryBodyCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromQueryBodyAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromQueryBody(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryBodyCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryBody(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromQueryBodyBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromQueryBodyCore(property, parent);
//    		DeletedFromQueryBodyAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromQueryBody(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryBody(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromQueryBodyCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromQueryBody(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromQueryBodyBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromQueryBodyCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryBodyCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromQueryBodyAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromQueryBody(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryBodyCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryBody(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromQueryBodyBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromQueryBodyCore(oldElement, newElement);
//    		UpdatedFromQueryBodyAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromQueryBody(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryBody(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromQueryBodyCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromQueryBody(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromQueryBodyBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromQueryBodyCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryBodyCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromQueryBodyAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromQueryBody(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromQueryBodyCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromQueryBody(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromQueryBodyBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromQueryBodyCore(property, oldPArent, position, newParent);
//    		MovedFromQueryBodyAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromJoinIntoClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromJoinIntoClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromJoinIntoClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromJoinIntoClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromJoinIntoClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromJoinIntoClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromJoinIntoClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromJoinIntoClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromJoinIntoClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromJoinIntoClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromJoinIntoClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromJoinIntoClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromJoinIntoClauseCore(property, position, parent);
//    		InsertedFromJoinIntoClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromJoinIntoClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromJoinIntoClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromJoinIntoClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromJoinIntoClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromJoinIntoClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromJoinIntoClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromJoinIntoClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromJoinIntoClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromJoinIntoClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromJoinIntoClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromJoinIntoClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromJoinIntoClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromJoinIntoClauseCore(property, parent);
//    		DeletedFromJoinIntoClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromJoinIntoClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromJoinIntoClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromJoinIntoClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromJoinIntoClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromJoinIntoClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromJoinIntoClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromJoinIntoClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromJoinIntoClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromJoinIntoClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromJoinIntoClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromJoinIntoClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromJoinIntoClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromJoinIntoClauseCore(oldElement, newElement);
//    		UpdatedFromJoinIntoClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromJoinIntoClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromJoinIntoClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromJoinIntoClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromJoinIntoClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromJoinIntoClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromJoinIntoClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromJoinIntoClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromJoinIntoClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromJoinIntoClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromJoinIntoClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromJoinIntoClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromJoinIntoClauseCore(property, oldPArent, position, newParent);
//    		MovedFromJoinIntoClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOrdering(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOrdering(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOrderingCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOrdering(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOrderingBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOrderingCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOrderingCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOrderingAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOrdering(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOrderingCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOrdering(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOrderingBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOrderingCore(property, position, parent);
//    		InsertedFromOrderingAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOrdering(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOrdering(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOrderingCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOrdering(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOrderingBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOrderingCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOrderingCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOrderingAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOrdering(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOrderingCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOrdering(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOrderingBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOrderingCore(property, parent);
//    		DeletedFromOrderingAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOrdering(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOrdering(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOrderingCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOrdering(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOrderingBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOrderingCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOrderingCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOrderingAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOrdering(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOrderingCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOrdering(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOrderingBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOrderingCore(oldElement, newElement);
//    		UpdatedFromOrderingAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOrdering(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOrdering(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOrderingCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOrdering(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOrderingBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOrderingCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOrderingCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOrderingAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOrdering(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOrderingCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AscendingOrDescendingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOrdering(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOrderingBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOrderingCore(property, oldPArent, position, newParent);
//    		MovedFromOrderingAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromQueryContinuation(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryContinuation(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromQueryContinuationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromQueryContinuation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromQueryContinuationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromQueryContinuationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryContinuationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromQueryContinuationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromQueryContinuation(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryContinuationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryContinuation(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromQueryContinuationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromQueryContinuationCore(property, position, parent);
//    		InsertedFromQueryContinuationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromQueryContinuation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryContinuation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromQueryContinuationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromQueryContinuation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromQueryContinuationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromQueryContinuationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryContinuationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromQueryContinuationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromQueryContinuation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryContinuationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryContinuation(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromQueryContinuationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromQueryContinuationCore(property, parent);
//    		DeletedFromQueryContinuationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromQueryContinuation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryContinuation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromQueryContinuationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromQueryContinuation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromQueryContinuationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromQueryContinuationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryContinuationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromQueryContinuationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromQueryContinuation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryContinuationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryContinuation(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromQueryContinuationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromQueryContinuationCore(oldElement, newElement);
//    		UpdatedFromQueryContinuationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromQueryContinuation(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryContinuation(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromQueryContinuationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromQueryContinuation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromQueryContinuationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromQueryContinuationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryContinuationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromQueryContinuationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromQueryContinuation(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromQueryContinuationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IntoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromQueryContinuation(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromQueryContinuationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromQueryContinuationCore(property, oldPArent, position, newParent);
//    		MovedFromQueryContinuationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromWhenClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhenClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromWhenClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromWhenClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromWhenClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromWhenClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhenClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromWhenClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromWhenClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromWhenClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromWhenClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromWhenClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromWhenClauseCore(property, position, parent);
//    		InsertedFromWhenClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromWhenClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhenClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromWhenClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromWhenClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromWhenClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromWhenClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhenClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromWhenClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromWhenClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromWhenClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromWhenClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromWhenClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromWhenClauseCore(property, parent);
//    		DeletedFromWhenClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromWhenClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhenClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromWhenClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromWhenClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromWhenClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromWhenClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhenClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromWhenClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromWhenClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhenClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhenClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromWhenClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromWhenClauseCore(oldElement, newElement);
//    		UpdatedFromWhenClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromWhenClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhenClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromWhenClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromWhenClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromWhenClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromWhenClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhenClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromWhenClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromWhenClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromWhenClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromWhenClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromWhenClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromWhenClauseCore(property, oldPArent, position, newParent);
//    		MovedFromWhenClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterpolationAlignmentClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolationAlignmentClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterpolationAlignmentClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterpolationAlignmentClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterpolationAlignmentClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterpolationAlignmentClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolationAlignmentClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterpolationAlignmentClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterpolationAlignmentClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolationAlignmentClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CommaToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolationAlignmentClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterpolationAlignmentClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterpolationAlignmentClauseCore(property, position, parent);
//    		InsertedFromInterpolationAlignmentClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterpolationAlignmentClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolationAlignmentClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterpolationAlignmentClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterpolationAlignmentClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterpolationAlignmentClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterpolationAlignmentClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolationAlignmentClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterpolationAlignmentClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterpolationAlignmentClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolationAlignmentClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CommaToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolationAlignmentClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterpolationAlignmentClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterpolationAlignmentClauseCore(property, parent);
//    		DeletedFromInterpolationAlignmentClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterpolationAlignmentClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolationAlignmentClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterpolationAlignmentClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterpolationAlignmentClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterpolationAlignmentClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterpolationAlignmentClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolationAlignmentClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterpolationAlignmentClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterpolationAlignmentClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolationAlignmentClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CommaToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolationAlignmentClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterpolationAlignmentClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterpolationAlignmentClauseCore(oldElement, newElement);
//    		UpdatedFromInterpolationAlignmentClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterpolationAlignmentClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterpolationAlignmentClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolationAlignmentClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterpolationAlignmentClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterpolationAlignmentClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolationAlignmentClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CommaToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolationAlignmentClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterpolationAlignmentClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterpolationAlignmentClauseCore(property, oldPArent, position, newParent);
//    		MovedFromInterpolationAlignmentClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterpolationFormatClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolationFormatClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterpolationFormatClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterpolationFormatClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterpolationFormatClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterpolationFormatClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolationFormatClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterpolationFormatClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterpolationFormatClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolationFormatClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolationFormatClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterpolationFormatClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterpolationFormatClauseCore(property, position, parent);
//    		InsertedFromInterpolationFormatClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterpolationFormatClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolationFormatClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterpolationFormatClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterpolationFormatClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterpolationFormatClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterpolationFormatClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolationFormatClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterpolationFormatClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterpolationFormatClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolationFormatClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolationFormatClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterpolationFormatClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterpolationFormatClauseCore(property, parent);
//    		DeletedFromInterpolationFormatClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterpolationFormatClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolationFormatClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterpolationFormatClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterpolationFormatClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterpolationFormatClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterpolationFormatClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolationFormatClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterpolationFormatClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterpolationFormatClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolationFormatClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolationFormatClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterpolationFormatClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterpolationFormatClauseCore(oldElement, newElement);
//    		UpdatedFromInterpolationFormatClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterpolationFormatClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterpolationFormatClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterpolationFormatClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolationFormatClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterpolationFormatClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterpolationFormatClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolationFormatClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolationFormatClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterpolationFormatClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterpolationFormatClauseCore(property, oldPArent, position, newParent);
//    		MovedFromInterpolationFormatClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromVariableDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromVariableDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromVariableDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromVariableDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromVariableDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromVariableDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromVariableDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromVariableDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromVariableDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromVariableDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromVariableDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromVariableDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromVariableDeclarationCore(property, position, parent);
//    		InsertedFromVariableDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromVariableDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromVariableDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromVariableDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromVariableDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromVariableDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromVariableDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromVariableDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromVariableDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromVariableDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromVariableDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromVariableDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromVariableDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromVariableDeclarationCore(property, parent);
//    		DeletedFromVariableDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromVariableDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromVariableDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromVariableDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromVariableDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromVariableDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromVariableDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromVariableDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromVariableDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromVariableDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromVariableDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromVariableDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromVariableDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromVariableDeclarationCore(oldElement, newElement);
//    		UpdatedFromVariableDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromVariableDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromVariableDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromVariableDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromVariableDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromVariableDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromVariableDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromVariableDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromVariableDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromVariableDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromVariableDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromVariableDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromVariableDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromVariableDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromVariableDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromVariableDeclarator(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromVariableDeclarator(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromVariableDeclaratorCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromVariableDeclarator(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromVariableDeclaratorBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromVariableDeclaratorCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromVariableDeclaratorCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromVariableDeclaratorAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromVariableDeclarator(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromVariableDeclaratorCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromVariableDeclarator(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromVariableDeclaratorBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromVariableDeclaratorCore(property, position, parent);
//    		InsertedFromVariableDeclaratorAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromVariableDeclarator(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromVariableDeclarator(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromVariableDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromVariableDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromVariableDeclaratorBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromVariableDeclaratorCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromVariableDeclaratorCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromVariableDeclaratorAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromVariableDeclarator(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromVariableDeclaratorCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromVariableDeclarator(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromVariableDeclaratorBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromVariableDeclaratorCore(property, parent);
//    		DeletedFromVariableDeclaratorAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromVariableDeclarator(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromVariableDeclarator(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromVariableDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromVariableDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromVariableDeclaratorBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromVariableDeclaratorCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromVariableDeclaratorCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromVariableDeclaratorAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromVariableDeclarator(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromVariableDeclaratorCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromVariableDeclarator(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromVariableDeclaratorBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromVariableDeclaratorCore(oldElement, newElement);
//    		UpdatedFromVariableDeclaratorAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromVariableDeclarator(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromVariableDeclarator(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromVariableDeclaratorCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromVariableDeclarator(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromVariableDeclaratorBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromVariableDeclaratorCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromVariableDeclaratorAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromVariableDeclarator(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromVariableDeclaratorCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromVariableDeclarator(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromVariableDeclaratorBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromVariableDeclaratorCore(property, oldPArent, position, newParent);
//    		MovedFromVariableDeclaratorAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEqualsValueClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEqualsValueClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEqualsValueClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEqualsValueClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEqualsValueClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEqualsValueClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEqualsValueClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEqualsValueClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEqualsValueClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEqualsValueClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEqualsValueClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEqualsValueClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEqualsValueClauseCore(property, position, parent);
//    		InsertedFromEqualsValueClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEqualsValueClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEqualsValueClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEqualsValueClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEqualsValueClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEqualsValueClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEqualsValueClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEqualsValueClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEqualsValueClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEqualsValueClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEqualsValueClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEqualsValueClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEqualsValueClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEqualsValueClauseCore(property, parent);
//    		DeletedFromEqualsValueClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEqualsValueClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEqualsValueClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEqualsValueClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEqualsValueClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEqualsValueClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEqualsValueClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEqualsValueClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEqualsValueClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEqualsValueClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEqualsValueClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEqualsValueClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEqualsValueClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEqualsValueClauseCore(oldElement, newElement);
//    		UpdatedFromEqualsValueClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEqualsValueClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEqualsValueClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEqualsValueClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEqualsValueClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEqualsValueClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEqualsValueClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEqualsValueClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEqualsValueClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEqualsValueClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEqualsValueClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEqualsValueClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEqualsValueClauseCore(property, oldPArent, position, newParent);
//    		MovedFromEqualsValueClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromElseClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElseClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromElseClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromElseClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromElseClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromElseClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElseClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromElseClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromElseClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromElseClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromElseClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromElseClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromElseClauseCore(property, position, parent);
//    		InsertedFromElseClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromElseClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElseClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromElseClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromElseClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromElseClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromElseClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElseClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromElseClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromElseClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromElseClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromElseClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromElseClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromElseClauseCore(property, parent);
//    		DeletedFromElseClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromElseClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElseClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromElseClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromElseClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromElseClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromElseClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElseClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromElseClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromElseClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromElseClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromElseClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromElseClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromElseClauseCore(oldElement, newElement);
//    		UpdatedFromElseClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromElseClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElseClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromElseClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromElseClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromElseClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromElseClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElseClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromElseClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromElseClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromElseClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromElseClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromElseClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromElseClauseCore(property, oldPArent, position, newParent);
//    		MovedFromElseClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSwitchSection(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSwitchSection(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSwitchSectionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSwitchSection(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSwitchSectionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSwitchSectionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSwitchSectionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSwitchSectionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSwitchSection(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSwitchSectionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSwitchSection(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSwitchSectionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSwitchSectionCore(property, position, parent);
//    		InsertedFromSwitchSectionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSwitchSection(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSwitchSection(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSwitchSectionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSwitchSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSwitchSectionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSwitchSectionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSwitchSectionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSwitchSectionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSwitchSection(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSwitchSectionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSwitchSection(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSwitchSectionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSwitchSectionCore(property, parent);
//    		DeletedFromSwitchSectionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSwitchSection(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSwitchSection(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSwitchSectionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSwitchSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSwitchSectionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSwitchSectionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSwitchSectionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSwitchSectionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSwitchSection(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSwitchSectionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSwitchSection(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSwitchSectionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSwitchSectionCore(oldElement, newElement);
//    		UpdatedFromSwitchSectionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSwitchSection(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSwitchSection(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSwitchSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSwitchSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSwitchSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSwitchSectionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSwitchSectionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSwitchSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSwitchSection(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSwitchSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSwitchSection(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSwitchSectionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSwitchSectionCore(property, oldPArent, position, newParent);
//    		MovedFromSwitchSectionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCatchClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCatchClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCatchClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCatchClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCatchClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCatchClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCatchClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CatchKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCatchClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCatchClauseCore(property, position, parent);
//    		InsertedFromCatchClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCatchClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCatchClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCatchClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCatchClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCatchClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCatchClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCatchClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CatchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCatchClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCatchClauseCore(property, parent);
//    		DeletedFromCatchClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCatchClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCatchClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCatchClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCatchClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCatchClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCatchClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCatchClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CatchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCatchClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCatchClauseCore(oldElement, newElement);
//    		UpdatedFromCatchClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCatchClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCatchClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCatchClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCatchClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCatchClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCatchClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCatchClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCatchClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "CatchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCatchClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCatchClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCatchClauseCore(property, oldPArent, position, newParent);
//    		MovedFromCatchClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCatchDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCatchDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCatchDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCatchDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCatchDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCatchDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCatchDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCatchDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCatchDeclarationCore(property, position, parent);
//    		InsertedFromCatchDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCatchDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCatchDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCatchDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCatchDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCatchDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCatchDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCatchDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCatchDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCatchDeclarationCore(property, parent);
//    		DeletedFromCatchDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCatchDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCatchDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCatchDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCatchDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCatchDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCatchDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCatchDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCatchDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCatchDeclarationCore(oldElement, newElement);
//    		UpdatedFromCatchDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCatchDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCatchDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCatchDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCatchDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCatchDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCatchDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCatchDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCatchDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCatchDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCatchDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCatchDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromCatchDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCatchFilterClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchFilterClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCatchFilterClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCatchFilterClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCatchFilterClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCatchFilterClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCatchFilterClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCatchFilterClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCatchFilterClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchFilterClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCatchFilterClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCatchFilterClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCatchFilterClauseCore(property, position, parent);
//    		InsertedFromCatchFilterClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCatchFilterClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchFilterClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCatchFilterClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCatchFilterClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCatchFilterClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCatchFilterClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCatchFilterClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCatchFilterClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCatchFilterClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchFilterClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCatchFilterClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCatchFilterClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCatchFilterClauseCore(property, parent);
//    		DeletedFromCatchFilterClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCatchFilterClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchFilterClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCatchFilterClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCatchFilterClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCatchFilterClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCatchFilterClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCatchFilterClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCatchFilterClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCatchFilterClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchFilterClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCatchFilterClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCatchFilterClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCatchFilterClauseCore(oldElement, newElement);
//    		UpdatedFromCatchFilterClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCatchFilterClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchFilterClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCatchFilterClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCatchFilterClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCatchFilterClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCatchFilterClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCatchFilterClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCatchFilterClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCatchFilterClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhenKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCatchFilterClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCatchFilterClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCatchFilterClauseCore(property, oldPArent, position, newParent);
//    		MovedFromCatchFilterClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromFinallyClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFinallyClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromFinallyClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromFinallyClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromFinallyClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromFinallyClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFinallyClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromFinallyClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromFinallyClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromFinallyClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FinallyKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromFinallyClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromFinallyClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromFinallyClauseCore(property, position, parent);
//    		InsertedFromFinallyClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromFinallyClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFinallyClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromFinallyClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromFinallyClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromFinallyClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromFinallyClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFinallyClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromFinallyClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromFinallyClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromFinallyClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FinallyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromFinallyClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromFinallyClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromFinallyClauseCore(property, parent);
//    		DeletedFromFinallyClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromFinallyClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFinallyClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromFinallyClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromFinallyClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromFinallyClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromFinallyClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFinallyClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromFinallyClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromFinallyClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromFinallyClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FinallyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromFinallyClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromFinallyClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromFinallyClauseCore(oldElement, newElement);
//    		UpdatedFromFinallyClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromFinallyClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFinallyClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromFinallyClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromFinallyClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromFinallyClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromFinallyClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFinallyClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromFinallyClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromFinallyClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromFinallyClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FinallyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromFinallyClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromFinallyClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromFinallyClauseCore(property, oldPArent, position, newParent);
//    		MovedFromFinallyClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCompilationUnit(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCompilationUnit(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCompilationUnitCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCompilationUnit(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCompilationUnitBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCompilationUnitCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCompilationUnitCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCompilationUnitAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCompilationUnit(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCompilationUnitCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfFileToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCompilationUnit(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCompilationUnitBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCompilationUnitCore(property, position, parent);
//    		InsertedFromCompilationUnitAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCompilationUnit(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCompilationUnit(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCompilationUnitCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCompilationUnit(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCompilationUnitBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCompilationUnitCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCompilationUnitCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCompilationUnitAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCompilationUnit(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCompilationUnitCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfFileToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCompilationUnit(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCompilationUnitBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCompilationUnitCore(property, parent);
//    		DeletedFromCompilationUnitAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCompilationUnit(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCompilationUnit(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCompilationUnitCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCompilationUnit(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCompilationUnitBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCompilationUnitCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCompilationUnitCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCompilationUnitAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCompilationUnit(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCompilationUnitCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfFileToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCompilationUnit(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCompilationUnitBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCompilationUnitCore(oldElement, newElement);
//    		UpdatedFromCompilationUnitAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCompilationUnit(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCompilationUnit(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCompilationUnitCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCompilationUnit(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCompilationUnitBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCompilationUnitCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCompilationUnitCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCompilationUnitAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCompilationUnit(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCompilationUnitCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfFileToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCompilationUnit(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCompilationUnitBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCompilationUnitCore(property, oldPArent, position, newParent);
//    		MovedFromCompilationUnitAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromExternAliasDirective(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExternAliasDirective(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromExternAliasDirectiveCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromExternAliasDirective(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromExternAliasDirectiveBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromExternAliasDirectiveCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExternAliasDirectiveCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromExternAliasDirectiveAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromExternAliasDirective(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromExternAliasDirectiveCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ExternKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "AliasKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromExternAliasDirective(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromExternAliasDirectiveBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromExternAliasDirectiveCore(property, position, parent);
//    		InsertedFromExternAliasDirectiveAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromExternAliasDirective(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExternAliasDirective(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromExternAliasDirectiveCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromExternAliasDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromExternAliasDirectiveBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromExternAliasDirectiveCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExternAliasDirectiveCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromExternAliasDirectiveAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromExternAliasDirective(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromExternAliasDirectiveCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ExternKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "AliasKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromExternAliasDirective(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromExternAliasDirectiveBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromExternAliasDirectiveCore(property, parent);
//    		DeletedFromExternAliasDirectiveAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromExternAliasDirective(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExternAliasDirective(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromExternAliasDirectiveCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromExternAliasDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromExternAliasDirectiveBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromExternAliasDirectiveCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExternAliasDirectiveCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromExternAliasDirectiveAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromExternAliasDirective(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromExternAliasDirectiveCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ExternKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "AliasKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromExternAliasDirective(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromExternAliasDirectiveBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromExternAliasDirectiveCore(oldElement, newElement);
//    		UpdatedFromExternAliasDirectiveAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromExternAliasDirective(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExternAliasDirective(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromExternAliasDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromExternAliasDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromExternAliasDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExternAliasDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromExternAliasDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromExternAliasDirective(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromExternAliasDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ExternKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "AliasKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromExternAliasDirective(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromExternAliasDirectiveBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromExternAliasDirectiveCore(property, oldPArent, position, newParent);
//    		MovedFromExternAliasDirectiveAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromUsingDirective(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUsingDirective(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromUsingDirectiveCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromUsingDirective(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromUsingDirectiveBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromUsingDirectiveCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUsingDirectiveCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromUsingDirectiveAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromUsingDirective(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromUsingDirectiveCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StaticKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromUsingDirective(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromUsingDirectiveBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromUsingDirectiveCore(property, position, parent);
//    		InsertedFromUsingDirectiveAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromUsingDirective(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUsingDirective(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromUsingDirectiveCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromUsingDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromUsingDirectiveBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromUsingDirectiveCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUsingDirectiveCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromUsingDirectiveAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromUsingDirective(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromUsingDirectiveCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StaticKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromUsingDirective(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromUsingDirectiveBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromUsingDirectiveCore(property, parent);
//    		DeletedFromUsingDirectiveAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromUsingDirective(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUsingDirective(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromUsingDirectiveCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromUsingDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromUsingDirectiveBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromUsingDirectiveCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUsingDirectiveCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromUsingDirectiveAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromUsingDirective(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromUsingDirectiveCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StaticKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromUsingDirective(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromUsingDirectiveBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromUsingDirectiveCore(oldElement, newElement);
//    		UpdatedFromUsingDirectiveAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromUsingDirective(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUsingDirective(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromUsingDirectiveCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromUsingDirective(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromUsingDirectiveBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromUsingDirectiveCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUsingDirectiveCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromUsingDirectiveAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromUsingDirective(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromUsingDirectiveCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StaticKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromUsingDirective(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromUsingDirectiveBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromUsingDirectiveCore(property, oldPArent, position, newParent);
//    		MovedFromUsingDirectiveAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAttributeList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAttributeListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAttributeList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAttributeListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAttributeListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAttributeListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAttributeList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAttributeListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAttributeListCore(property, position, parent);
//    		InsertedFromAttributeListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAttributeList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAttributeListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAttributeList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAttributeListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAttributeListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAttributeListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAttributeList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAttributeListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAttributeListCore(property, parent);
//    		DeletedFromAttributeListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAttributeList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAttributeListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAttributeList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAttributeListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAttributeListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAttributeListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAttributeList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAttributeListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAttributeListCore(oldElement, newElement);
//    		UpdatedFromAttributeListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAttributeList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAttributeListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAttributeList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAttributeListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAttributeListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAttributeListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAttributeList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAttributeListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAttributeListCore(property, oldPArent, position, newParent);
//    		MovedFromAttributeListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAttributeTargetSpecifier(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeTargetSpecifier(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAttributeTargetSpecifierCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAttributeTargetSpecifier(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAttributeTargetSpecifierBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAttributeTargetSpecifierCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeTargetSpecifierCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAttributeTargetSpecifierAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAttributeTargetSpecifier(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeTargetSpecifierCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeTargetSpecifier(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAttributeTargetSpecifierBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAttributeTargetSpecifierCore(property, position, parent);
//    		InsertedFromAttributeTargetSpecifierAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAttributeTargetSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeTargetSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAttributeTargetSpecifierCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAttributeTargetSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAttributeTargetSpecifierBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAttributeTargetSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeTargetSpecifierCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAttributeTargetSpecifierAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAttributeTargetSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeTargetSpecifierCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeTargetSpecifier(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAttributeTargetSpecifierBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAttributeTargetSpecifierCore(property, parent);
//    		DeletedFromAttributeTargetSpecifierAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAttributeTargetSpecifier(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeTargetSpecifier(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAttributeTargetSpecifierCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAttributeTargetSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAttributeTargetSpecifierBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAttributeTargetSpecifierCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeTargetSpecifierCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAttributeTargetSpecifierAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAttributeTargetSpecifier(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeTargetSpecifierCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeTargetSpecifier(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAttributeTargetSpecifierBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAttributeTargetSpecifierCore(oldElement, newElement);
//    		UpdatedFromAttributeTargetSpecifierAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAttributeTargetSpecifier(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAttributeTargetSpecifierBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeTargetSpecifierCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAttributeTargetSpecifierAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAttributeTargetSpecifier(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeTargetSpecifierCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeTargetSpecifier(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAttributeTargetSpecifierBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAttributeTargetSpecifierCore(property, oldPArent, position, newParent);
//    		MovedFromAttributeTargetSpecifierAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAttribute(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttribute(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAttributeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAttribute(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAttribute(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAttributeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAttributeCore(property, position, parent);
//    		InsertedFromAttributeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAttributeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAttributeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAttribute(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAttributeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAttributeCore(property, parent);
//    		DeletedFromAttributeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttribute(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAttributeCore(oldElement, newElement);
//    		UpdatedFromAttributeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAttribute(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttribute(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAttributeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAttribute(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAttribute(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAttributeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAttributeCore(property, oldPArent, position, newParent);
//    		MovedFromAttributeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAttributeArgumentList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeArgumentList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAttributeArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAttributeArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAttributeArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAttributeArgumentListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAttributeArgumentListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAttributeArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAttributeArgumentList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeArgumentListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAttributeArgumentList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAttributeArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAttributeArgumentListCore(property, position, parent);
//    		InsertedFromAttributeArgumentListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAttributeArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAttributeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAttributeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAttributeArgumentListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAttributeArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAttributeArgumentListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAttributeArgumentListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAttributeArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeArgumentListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAttributeArgumentList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAttributeArgumentListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAttributeArgumentListCore(property, parent);
//    		DeletedFromAttributeArgumentListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAttributeArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAttributeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAttributeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAttributeArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAttributeArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAttributeArgumentListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAttributeArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAttributeArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeArgumentListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAttributeArgumentList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAttributeArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAttributeArgumentListCore(oldElement, newElement);
//    		UpdatedFromAttributeArgumentListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAttributeArgumentList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeArgumentList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAttributeArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAttributeArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAttributeArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAttributeArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAttributeArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAttributeArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAttributeArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAttributeArgumentListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAttributeArgumentListCore(property, oldPArent, position, newParent);
//    		MovedFromAttributeArgumentListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDelegateDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDelegateDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDelegateDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDelegateDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDelegateDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDelegateDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDelegateDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDelegateDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDelegateDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDelegateDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDelegateDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDelegateDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDelegateDeclarationCore(property, position, parent);
//    		InsertedFromDelegateDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDelegateDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDelegateDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDelegateDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDelegateDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDelegateDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDelegateDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDelegateDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDelegateDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDelegateDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDelegateDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDelegateDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDelegateDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDelegateDeclarationCore(property, parent);
//    		DeletedFromDelegateDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDelegateDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDelegateDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDelegateDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDelegateDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDelegateDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDelegateDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDelegateDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDelegateDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDelegateDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDelegateDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDelegateDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDelegateDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDelegateDeclarationCore(oldElement, newElement);
//    		UpdatedFromDelegateDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDelegateDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDelegateDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDelegateDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDelegateDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDelegateDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDelegateDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDelegateDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDelegateDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDelegateDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDelegateDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDelegateDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDelegateDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromDelegateDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEnumMemberDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEnumMemberDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEnumMemberDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEnumMemberDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEnumMemberDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEnumMemberDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEnumMemberDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEnumMemberDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEnumMemberDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEnumMemberDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEnumMemberDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEnumMemberDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEnumMemberDeclarationCore(property, position, parent);
//    		InsertedFromEnumMemberDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEnumMemberDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEnumMemberDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEnumMemberDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEnumMemberDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEnumMemberDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEnumMemberDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEnumMemberDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEnumMemberDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEnumMemberDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEnumMemberDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEnumMemberDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEnumMemberDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEnumMemberDeclarationCore(property, parent);
//    		DeletedFromEnumMemberDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEnumMemberDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEnumMemberDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEnumMemberDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEnumMemberDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEnumMemberDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEnumMemberDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEnumMemberDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEnumMemberDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEnumMemberDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEnumMemberDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEnumMemberDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEnumMemberDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEnumMemberDeclarationCore(oldElement, newElement);
//    		UpdatedFromEnumMemberDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEnumMemberDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEnumMemberDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEnumMemberDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEnumMemberDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEnumMemberDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEnumMemberDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEnumMemberDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEnumMemberDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEnumMemberDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromEnumMemberDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIncompleteMember(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIncompleteMember(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIncompleteMemberCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIncompleteMember(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIncompleteMemberBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIncompleteMemberCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIncompleteMemberCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIncompleteMemberAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIncompleteMember(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIncompleteMemberCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIncompleteMember(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIncompleteMemberBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIncompleteMemberCore(property, position, parent);
//    		InsertedFromIncompleteMemberAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIncompleteMember(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIncompleteMember(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIncompleteMemberCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIncompleteMember(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIncompleteMemberBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIncompleteMemberCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIncompleteMemberCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIncompleteMemberAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIncompleteMember(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIncompleteMemberCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIncompleteMember(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIncompleteMemberBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIncompleteMemberCore(property, parent);
//    		DeletedFromIncompleteMemberAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIncompleteMember(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIncompleteMember(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIncompleteMemberCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIncompleteMember(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIncompleteMemberBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIncompleteMemberCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIncompleteMemberCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIncompleteMemberAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIncompleteMember(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIncompleteMemberCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIncompleteMember(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIncompleteMemberBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIncompleteMemberCore(oldElement, newElement);
//    		UpdatedFromIncompleteMemberAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIncompleteMember(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIncompleteMember(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIncompleteMemberCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIncompleteMember(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIncompleteMemberBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIncompleteMemberCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIncompleteMemberCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIncompleteMemberAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIncompleteMember(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIncompleteMemberCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIncompleteMember(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIncompleteMemberBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIncompleteMemberCore(property, oldPArent, position, newParent);
//    		MovedFromIncompleteMemberAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromGlobalStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGlobalStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromGlobalStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromGlobalStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromGlobalStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromGlobalStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGlobalStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromGlobalStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromGlobalStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromGlobalStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromGlobalStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromGlobalStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromGlobalStatementCore(property, position, parent);
//    		InsertedFromGlobalStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromGlobalStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGlobalStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromGlobalStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromGlobalStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromGlobalStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromGlobalStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGlobalStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromGlobalStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromGlobalStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromGlobalStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromGlobalStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromGlobalStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromGlobalStatementCore(property, parent);
//    		DeletedFromGlobalStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromGlobalStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGlobalStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromGlobalStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromGlobalStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromGlobalStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromGlobalStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGlobalStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromGlobalStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromGlobalStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromGlobalStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromGlobalStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromGlobalStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromGlobalStatementCore(oldElement, newElement);
//    		UpdatedFromGlobalStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromGlobalStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGlobalStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromGlobalStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromGlobalStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromGlobalStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromGlobalStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGlobalStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromGlobalStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromGlobalStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromGlobalStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromGlobalStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromGlobalStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromGlobalStatementCore(property, oldPArent, position, newParent);
//    		MovedFromGlobalStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromNamespaceDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNamespaceDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromNamespaceDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromNamespaceDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromNamespaceDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromNamespaceDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNamespaceDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromNamespaceDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromNamespaceDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromNamespaceDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromNamespaceDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromNamespaceDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromNamespaceDeclarationCore(property, position, parent);
//    		InsertedFromNamespaceDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromNamespaceDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNamespaceDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromNamespaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromNamespaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromNamespaceDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromNamespaceDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNamespaceDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromNamespaceDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromNamespaceDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromNamespaceDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromNamespaceDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromNamespaceDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromNamespaceDeclarationCore(property, parent);
//    		DeletedFromNamespaceDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromNamespaceDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNamespaceDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromNamespaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromNamespaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromNamespaceDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromNamespaceDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNamespaceDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromNamespaceDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromNamespaceDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromNamespaceDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromNamespaceDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromNamespaceDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromNamespaceDeclarationCore(oldElement, newElement);
//    		UpdatedFromNamespaceDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromNamespaceDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromNamespaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromNamespaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromNamespaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNamespaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromNamespaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromNamespaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromNamespaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NamespaceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromNamespaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromNamespaceDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromNamespaceDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromNamespaceDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEnumDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEnumDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEnumDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEnumDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEnumDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEnumDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEnumDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEnumDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEnumDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEnumDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EnumKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEnumDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEnumDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEnumDeclarationCore(property, position, parent);
//    		InsertedFromEnumDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEnumDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEnumDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEnumDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEnumDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEnumDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEnumDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEnumDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEnumDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEnumDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEnumDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EnumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEnumDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEnumDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEnumDeclarationCore(property, parent);
//    		DeletedFromEnumDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEnumDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEnumDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEnumDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEnumDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEnumDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEnumDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEnumDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEnumDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEnumDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEnumDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EnumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEnumDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEnumDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEnumDeclarationCore(oldElement, newElement);
//    		UpdatedFromEnumDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEnumDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEnumDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEnumDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEnumDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEnumDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEnumDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEnumDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEnumDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEnumDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEnumDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EnumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEnumDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEnumDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEnumDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromEnumDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromClassDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClassDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromClassDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromClassDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromClassDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromClassDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClassDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromClassDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromClassDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromClassDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromClassDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromClassDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromClassDeclarationCore(property, position, parent);
//    		InsertedFromClassDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromClassDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClassDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromClassDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromClassDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromClassDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromClassDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClassDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromClassDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromClassDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromClassDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromClassDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromClassDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromClassDeclarationCore(property, parent);
//    		DeletedFromClassDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromClassDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClassDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromClassDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromClassDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromClassDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromClassDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClassDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromClassDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromClassDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromClassDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromClassDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromClassDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromClassDeclarationCore(oldElement, newElement);
//    		UpdatedFromClassDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromClassDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClassDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromClassDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromClassDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromClassDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromClassDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClassDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromClassDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromClassDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromClassDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromClassDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromClassDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromClassDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromClassDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromStructDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromStructDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromStructDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromStructDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromStructDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromStructDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromStructDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromStructDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromStructDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromStructDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromStructDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromStructDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromStructDeclarationCore(property, position, parent);
//    		InsertedFromStructDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromStructDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromStructDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromStructDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromStructDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromStructDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromStructDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromStructDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromStructDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromStructDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromStructDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromStructDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromStructDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromStructDeclarationCore(property, parent);
//    		DeletedFromStructDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromStructDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromStructDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromStructDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromStructDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromStructDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromStructDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromStructDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromStructDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromStructDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromStructDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromStructDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromStructDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromStructDeclarationCore(oldElement, newElement);
//    		UpdatedFromStructDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromStructDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromStructDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromStructDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromStructDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromStructDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromStructDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromStructDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromStructDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromStructDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromStructDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromStructDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromStructDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromStructDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromStructDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterfaceDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterfaceDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterfaceDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterfaceDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterfaceDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterfaceDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterfaceDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterfaceDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterfaceDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterfaceDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterfaceDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterfaceDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterfaceDeclarationCore(property, position, parent);
//    		InsertedFromInterfaceDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterfaceDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterfaceDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterfaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterfaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterfaceDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterfaceDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterfaceDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterfaceDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterfaceDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterfaceDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterfaceDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterfaceDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterfaceDeclarationCore(property, parent);
//    		DeletedFromInterfaceDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterfaceDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterfaceDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterfaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterfaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterfaceDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterfaceDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterfaceDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterfaceDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterfaceDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterfaceDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterfaceDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterfaceDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterfaceDeclarationCore(oldElement, newElement);
//    		UpdatedFromInterfaceDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterfaceDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterfaceDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterfaceDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterfaceDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterfaceDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterfaceDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterfaceDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterfaceDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterfaceDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterfaceDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterfaceDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromInterfaceDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromFieldDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFieldDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromFieldDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromFieldDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromFieldDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromFieldDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFieldDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromFieldDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromFieldDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromFieldDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromFieldDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromFieldDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromFieldDeclarationCore(property, position, parent);
//    		InsertedFromFieldDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromFieldDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFieldDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromFieldDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromFieldDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFieldDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromFieldDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromFieldDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromFieldDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromFieldDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromFieldDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromFieldDeclarationCore(property, parent);
//    		DeletedFromFieldDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromFieldDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFieldDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromFieldDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromFieldDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFieldDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromFieldDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromFieldDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromFieldDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromFieldDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromFieldDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromFieldDeclarationCore(oldElement, newElement);
//    		UpdatedFromFieldDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromFieldDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromFieldDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromFieldDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromFieldDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEventFieldDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEventFieldDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEventFieldDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEventFieldDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEventFieldDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEventFieldDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEventFieldDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEventFieldDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEventFieldDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEventFieldDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEventFieldDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEventFieldDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEventFieldDeclarationCore(property, position, parent);
//    		InsertedFromEventFieldDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEventFieldDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEventFieldDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEventFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEventFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEventFieldDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEventFieldDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEventFieldDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEventFieldDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEventFieldDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEventFieldDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEventFieldDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEventFieldDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEventFieldDeclarationCore(property, parent);
//    		DeletedFromEventFieldDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEventFieldDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEventFieldDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEventFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEventFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEventFieldDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEventFieldDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEventFieldDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEventFieldDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEventFieldDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEventFieldDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEventFieldDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEventFieldDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEventFieldDeclarationCore(oldElement, newElement);
//    		UpdatedFromEventFieldDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEventFieldDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEventFieldDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEventFieldDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEventFieldDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEventFieldDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEventFieldDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEventFieldDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEventFieldDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEventFieldDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEventFieldDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEventFieldDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromEventFieldDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromMethodDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMethodDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromMethodDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromMethodDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromMethodDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromMethodDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMethodDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromMethodDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromMethodDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromMethodDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromMethodDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromMethodDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromMethodDeclarationCore(property, position, parent);
//    		InsertedFromMethodDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromMethodDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMethodDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromMethodDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromMethodDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromMethodDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromMethodDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMethodDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromMethodDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromMethodDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromMethodDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromMethodDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromMethodDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromMethodDeclarationCore(property, parent);
//    		DeletedFromMethodDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromMethodDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMethodDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromMethodDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromMethodDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromMethodDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromMethodDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMethodDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromMethodDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromMethodDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromMethodDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromMethodDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromMethodDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromMethodDeclarationCore(oldElement, newElement);
//    		UpdatedFromMethodDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromMethodDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMethodDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromMethodDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromMethodDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromMethodDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromMethodDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMethodDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromMethodDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromMethodDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromMethodDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromMethodDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromMethodDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromMethodDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromMethodDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOperatorDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOperatorDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOperatorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOperatorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOperatorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOperatorDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOperatorDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOperatorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOperatorDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOperatorDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOperatorDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOperatorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOperatorDeclarationCore(property, position, parent);
//    		InsertedFromOperatorDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOperatorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOperatorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOperatorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOperatorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOperatorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOperatorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOperatorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOperatorDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOperatorDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOperatorDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOperatorDeclarationCore(property, parent);
//    		DeletedFromOperatorDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOperatorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOperatorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOperatorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOperatorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOperatorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOperatorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOperatorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOperatorDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOperatorDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOperatorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOperatorDeclarationCore(oldElement, newElement);
//    		UpdatedFromOperatorDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOperatorDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOperatorDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOperatorDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromOperatorDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConversionOperatorDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConversionOperatorDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConversionOperatorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConversionOperatorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConversionOperatorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConversionOperatorDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConversionOperatorDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConversionOperatorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConversionOperatorDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConversionOperatorDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConversionOperatorDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConversionOperatorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConversionOperatorDeclarationCore(property, position, parent);
//    		InsertedFromConversionOperatorDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConversionOperatorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConversionOperatorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConversionOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConversionOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConversionOperatorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConversionOperatorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConversionOperatorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConversionOperatorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConversionOperatorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConversionOperatorDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConversionOperatorDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConversionOperatorDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConversionOperatorDeclarationCore(property, parent);
//    		DeletedFromConversionOperatorDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConversionOperatorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConversionOperatorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConversionOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConversionOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConversionOperatorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConversionOperatorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConversionOperatorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConversionOperatorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConversionOperatorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConversionOperatorDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConversionOperatorDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConversionOperatorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConversionOperatorDeclarationCore(oldElement, newElement);
//    		UpdatedFromConversionOperatorDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConversionOperatorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConversionOperatorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConversionOperatorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConversionOperatorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConversionOperatorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConversionOperatorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConversionOperatorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConversionOperatorDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConversionOperatorDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromConversionOperatorDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConstructorDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConstructorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConstructorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConstructorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConstructorDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConstructorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConstructorDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConstructorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConstructorDeclarationCore(property, position, parent);
//    		InsertedFromConstructorDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConstructorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConstructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConstructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConstructorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConstructorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConstructorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConstructorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConstructorDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConstructorDeclarationCore(property, parent);
//    		DeletedFromConstructorDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConstructorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConstructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConstructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConstructorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConstructorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConstructorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConstructorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConstructorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConstructorDeclarationCore(oldElement, newElement);
//    		UpdatedFromConstructorDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConstructorDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConstructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConstructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConstructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConstructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConstructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConstructorDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConstructorDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromConstructorDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDestructorDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDestructorDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDestructorDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDestructorDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDestructorDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDestructorDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDestructorDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDestructorDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDestructorDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDestructorDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TildeToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDestructorDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDestructorDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDestructorDeclarationCore(property, position, parent);
//    		InsertedFromDestructorDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDestructorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDestructorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDestructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDestructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDestructorDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDestructorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDestructorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDestructorDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDestructorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDestructorDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TildeToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDestructorDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDestructorDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDestructorDeclarationCore(property, parent);
//    		DeletedFromDestructorDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDestructorDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDestructorDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDestructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDestructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDestructorDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDestructorDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDestructorDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDestructorDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDestructorDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDestructorDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TildeToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDestructorDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDestructorDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDestructorDeclarationCore(oldElement, newElement);
//    		UpdatedFromDestructorDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDestructorDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDestructorDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDestructorDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDestructorDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDestructorDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDestructorDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDestructorDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDestructorDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDestructorDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TildeToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDestructorDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDestructorDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDestructorDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromDestructorDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPropertyDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPropertyDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPropertyDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPropertyDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPropertyDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPropertyDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPropertyDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPropertyDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPropertyDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPropertyDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPropertyDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPropertyDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPropertyDeclarationCore(property, position, parent);
//    		InsertedFromPropertyDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPropertyDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPropertyDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPropertyDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPropertyDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPropertyDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPropertyDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPropertyDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPropertyDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPropertyDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPropertyDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPropertyDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPropertyDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPropertyDeclarationCore(property, parent);
//    		DeletedFromPropertyDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPropertyDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPropertyDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPropertyDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPropertyDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPropertyDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPropertyDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPropertyDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPropertyDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPropertyDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPropertyDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPropertyDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPropertyDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPropertyDeclarationCore(oldElement, newElement);
//    		UpdatedFromPropertyDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPropertyDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPropertyDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPropertyDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPropertyDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPropertyDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPropertyDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPropertyDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPropertyDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPropertyDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPropertyDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPropertyDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPropertyDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromPropertyDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEventDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEventDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEventDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEventDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEventDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEventDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEventDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEventDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEventDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEventDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEventDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEventDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEventDeclarationCore(property, position, parent);
//    		InsertedFromEventDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEventDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEventDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEventDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEventDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEventDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEventDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEventDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEventDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEventDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEventDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEventDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEventDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEventDeclarationCore(property, parent);
//    		DeletedFromEventDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEventDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEventDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEventDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEventDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEventDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEventDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEventDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEventDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEventDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEventDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEventDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEventDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEventDeclarationCore(oldElement, newElement);
//    		UpdatedFromEventDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEventDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEventDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEventDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEventDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEventDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEventDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEventDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEventDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEventDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEventDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EventKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEventDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEventDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEventDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromEventDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIndexerDeclaration(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIndexerDeclaration(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIndexerDeclarationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIndexerDeclaration(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIndexerDeclarationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIndexerDeclarationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIndexerDeclarationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIndexerDeclarationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIndexerDeclaration(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIndexerDeclarationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIndexerDeclaration(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIndexerDeclarationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIndexerDeclarationCore(property, position, parent);
//    		InsertedFromIndexerDeclarationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIndexerDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIndexerDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIndexerDeclarationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIndexerDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIndexerDeclarationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIndexerDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIndexerDeclarationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIndexerDeclarationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIndexerDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIndexerDeclarationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIndexerDeclaration(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIndexerDeclarationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIndexerDeclarationCore(property, parent);
//    		DeletedFromIndexerDeclarationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIndexerDeclaration(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIndexerDeclaration(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIndexerDeclarationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIndexerDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIndexerDeclarationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIndexerDeclarationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIndexerDeclarationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIndexerDeclarationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIndexerDeclaration(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIndexerDeclarationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIndexerDeclaration(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIndexerDeclarationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIndexerDeclarationCore(oldElement, newElement);
//    		UpdatedFromIndexerDeclarationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIndexerDeclaration(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIndexerDeclaration(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIndexerDeclarationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIndexerDeclaration(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIndexerDeclarationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIndexerDeclarationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIndexerDeclarationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIndexerDeclaration(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIndexerDeclarationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIndexerDeclaration(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIndexerDeclarationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIndexerDeclarationCore(property, oldPArent, position, newParent);
//    		MovedFromIndexerDeclarationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSimpleBaseType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSimpleBaseType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSimpleBaseTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSimpleBaseType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSimpleBaseTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSimpleBaseTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSimpleBaseTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSimpleBaseTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSimpleBaseType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSimpleBaseTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSimpleBaseType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSimpleBaseTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSimpleBaseTypeCore(property, position, parent);
//    		InsertedFromSimpleBaseTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSimpleBaseType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSimpleBaseType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSimpleBaseTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSimpleBaseType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSimpleBaseTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSimpleBaseTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSimpleBaseTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSimpleBaseTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSimpleBaseType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSimpleBaseTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSimpleBaseType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSimpleBaseTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSimpleBaseTypeCore(property, parent);
//    		DeletedFromSimpleBaseTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSimpleBaseType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSimpleBaseType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSimpleBaseTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSimpleBaseType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSimpleBaseTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSimpleBaseTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSimpleBaseTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSimpleBaseTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSimpleBaseType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSimpleBaseTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSimpleBaseType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSimpleBaseTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSimpleBaseTypeCore(oldElement, newElement);
//    		UpdatedFromSimpleBaseTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSimpleBaseType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSimpleBaseType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSimpleBaseTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSimpleBaseType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSimpleBaseTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSimpleBaseTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSimpleBaseTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSimpleBaseType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSimpleBaseTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSimpleBaseType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSimpleBaseTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSimpleBaseTypeCore(property, oldPArent, position, newParent);
//    		MovedFromSimpleBaseTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConstructorConstraint(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorConstraint(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConstructorConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConstructorConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConstructorConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConstructorConstraintCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstructorConstraintCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConstructorConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConstructorConstraint(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorConstraintCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConstructorConstraint(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConstructorConstraintBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConstructorConstraintCore(property, position, parent);
//    		InsertedFromConstructorConstraintAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConstructorConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConstructorConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConstructorConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConstructorConstraintBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConstructorConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstructorConstraintCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConstructorConstraintAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConstructorConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorConstraintCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConstructorConstraint(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConstructorConstraintBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConstructorConstraintCore(property, parent);
//    		DeletedFromConstructorConstraintAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConstructorConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConstructorConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConstructorConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConstructorConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConstructorConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstructorConstraintCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConstructorConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConstructorConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorConstraintCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstructorConstraint(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConstructorConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConstructorConstraintCore(oldElement, newElement);
//    		UpdatedFromConstructorConstraintAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConstructorConstraint(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorConstraint(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConstructorConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConstructorConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConstructorConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConstructorConstraintCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstructorConstraintCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConstructorConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConstructorConstraint(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConstructorConstraint(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConstructorConstraintBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConstructorConstraintCore(property, oldPArent, position, newParent);
//    		MovedFromConstructorConstraintAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromClassOrStructConstraint(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClassOrStructConstraint(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromClassOrStructConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromClassOrStructConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromClassOrStructConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromClassOrStructConstraintCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromClassOrStructConstraintCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromClassOrStructConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromClassOrStructConstraint(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromClassOrStructConstraintCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromClassOrStructConstraint(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromClassOrStructConstraintBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromClassOrStructConstraintCore(property, position, parent);
//    		InsertedFromClassOrStructConstraintAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromClassOrStructConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClassOrStructConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromClassOrStructConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromClassOrStructConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromClassOrStructConstraintBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromClassOrStructConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromClassOrStructConstraintCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromClassOrStructConstraintAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromClassOrStructConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromClassOrStructConstraintCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromClassOrStructConstraint(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromClassOrStructConstraintBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromClassOrStructConstraintCore(property, parent);
//    		DeletedFromClassOrStructConstraintAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromClassOrStructConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClassOrStructConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromClassOrStructConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromClassOrStructConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromClassOrStructConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromClassOrStructConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromClassOrStructConstraintCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromClassOrStructConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromClassOrStructConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromClassOrStructConstraintCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromClassOrStructConstraint(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromClassOrStructConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromClassOrStructConstraintCore(oldElement, newElement);
//    		UpdatedFromClassOrStructConstraintAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromClassOrStructConstraint(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromClassOrStructConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromClassOrStructConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromClassOrStructConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromClassOrStructConstraintCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromClassOrStructConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromClassOrStructConstraint(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromClassOrStructConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ClassOrStructKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromClassOrStructConstraint(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromClassOrStructConstraintBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromClassOrStructConstraintCore(property, oldPArent, position, newParent);
//    		MovedFromClassOrStructConstraintAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeConstraint(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeConstraint(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeConstraintCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeConstraint(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeConstraintBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeConstraintCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeConstraintCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeConstraintAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeConstraint(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeConstraintCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeConstraint(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeConstraintBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeConstraintCore(property, position, parent);
//    		InsertedFromTypeConstraintAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeConstraintCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeConstraintBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeConstraintCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeConstraintAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeConstraintCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeConstraint(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeConstraintBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeConstraintCore(property, parent);
//    		DeletedFromTypeConstraintAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeConstraint(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeConstraint(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeConstraintCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeConstraintBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeConstraintCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeConstraintCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeConstraintAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeConstraint(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeConstraintCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeConstraint(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeConstraintBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeConstraintCore(oldElement, newElement);
//    		UpdatedFromTypeConstraintAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeConstraint(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeConstraint(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeConstraintCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeConstraint(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeConstraintBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeConstraintCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeConstraintCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeConstraintAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeConstraint(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeConstraintCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeConstraint(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeConstraintBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeConstraintCore(property, oldPArent, position, newParent);
//    		MovedFromTypeConstraintAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromParameterList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParameterList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromParameterListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParameterListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromParameterList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromParameterListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromParameterList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromParameterListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromParameterListCore(property, position, parent);
//    		InsertedFromParameterListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromParameterListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParameterListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromParameterListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromParameterListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromParameterList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromParameterListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromParameterListCore(property, parent);
//    		DeletedFromParameterListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParameterListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromParameterListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromParameterList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromParameterListCore(oldElement, newElement);
//    		UpdatedFromParameterListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromParameterList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParameterList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromParameterListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParameterListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromParameterList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromParameterList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromParameterListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromParameterListCore(property, oldPArent, position, newParent);
//    		MovedFromParameterListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBracketedParameterList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBracketedParameterList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBracketedParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBracketedParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBracketedParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBracketedParameterListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBracketedParameterListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBracketedParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBracketedParameterList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBracketedParameterListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBracketedParameterList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBracketedParameterListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBracketedParameterListCore(property, position, parent);
//    		InsertedFromBracketedParameterListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBracketedParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBracketedParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBracketedParameterListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBracketedParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBracketedParameterListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBracketedParameterListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBracketedParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBracketedParameterListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBracketedParameterList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBracketedParameterListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBracketedParameterListCore(property, parent);
//    		DeletedFromBracketedParameterListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBracketedParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBracketedParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBracketedParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBracketedParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBracketedParameterListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBracketedParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBracketedParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBracketedParameterListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBracketedParameterList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBracketedParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBracketedParameterListCore(oldElement, newElement);
//    		UpdatedFromBracketedParameterListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBracketedParameterList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBracketedParameterListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBracketedParameterListCore(property, oldPArent, position, newParent);
//    		MovedFromBracketedParameterListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSkippedTokensTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSkippedTokensTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSkippedTokensTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSkippedTokensTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSkippedTokensTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSkippedTokensTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSkippedTokensTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSkippedTokensTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSkippedTokensTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSkippedTokensTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSkippedTokensTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSkippedTokensTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSkippedTokensTriviaCore(property, position, parent);
//    		InsertedFromSkippedTokensTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSkippedTokensTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSkippedTokensTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSkippedTokensTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSkippedTokensTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSkippedTokensTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSkippedTokensTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSkippedTokensTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSkippedTokensTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSkippedTokensTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSkippedTokensTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSkippedTokensTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSkippedTokensTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSkippedTokensTriviaCore(property, parent);
//    		DeletedFromSkippedTokensTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSkippedTokensTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSkippedTokensTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSkippedTokensTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSkippedTokensTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSkippedTokensTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSkippedTokensTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSkippedTokensTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSkippedTokensTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSkippedTokensTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSkippedTokensTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSkippedTokensTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSkippedTokensTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSkippedTokensTriviaCore(oldElement, newElement);
//    		UpdatedFromSkippedTokensTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSkippedTokensTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSkippedTokensTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSkippedTokensTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSkippedTokensTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSkippedTokensTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSkippedTokensTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSkippedTokensTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSkippedTokensTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSkippedTokensTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromSkippedTokensTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDocumentationCommentTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDocumentationCommentTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDocumentationCommentTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDocumentationCommentTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDocumentationCommentTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDocumentationCommentTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDocumentationCommentTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDocumentationCommentTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDocumentationCommentTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDocumentationCommentTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfComment")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDocumentationCommentTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDocumentationCommentTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDocumentationCommentTriviaCore(property, position, parent);
//    		InsertedFromDocumentationCommentTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDocumentationCommentTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDocumentationCommentTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDocumentationCommentTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDocumentationCommentTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDocumentationCommentTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDocumentationCommentTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDocumentationCommentTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDocumentationCommentTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDocumentationCommentTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDocumentationCommentTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfComment")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDocumentationCommentTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDocumentationCommentTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDocumentationCommentTriviaCore(property, parent);
//    		DeletedFromDocumentationCommentTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDocumentationCommentTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDocumentationCommentTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDocumentationCommentTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDocumentationCommentTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDocumentationCommentTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDocumentationCommentTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDocumentationCommentTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDocumentationCommentTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDocumentationCommentTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDocumentationCommentTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfComment")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDocumentationCommentTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDocumentationCommentTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDocumentationCommentTriviaCore(oldElement, newElement);
//    		UpdatedFromDocumentationCommentTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDocumentationCommentTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDocumentationCommentTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDocumentationCommentTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDocumentationCommentTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDocumentationCommentTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDocumentationCommentTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EndOfComment")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDocumentationCommentTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDocumentationCommentTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDocumentationCommentTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromDocumentationCommentTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEndIfDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEndIfDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEndIfDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEndIfDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEndIfDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEndIfDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEndIfDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEndIfDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEndIfDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEndIfDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndIfKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEndIfDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEndIfDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEndIfDirectiveTriviaCore(property, position, parent);
//    		InsertedFromEndIfDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEndIfDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEndIfDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEndIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEndIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEndIfDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEndIfDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEndIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEndIfDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEndIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEndIfDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndIfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEndIfDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEndIfDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEndIfDirectiveTriviaCore(property, parent);
//    		DeletedFromEndIfDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEndIfDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEndIfDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEndIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEndIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEndIfDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEndIfDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEndIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEndIfDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEndIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEndIfDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndIfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEndIfDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEndIfDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEndIfDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromEndIfDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEndIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEndIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEndIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEndIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEndIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndIfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEndIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEndIfDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEndIfDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromEndIfDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromRegionDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRegionDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromRegionDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromRegionDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromRegionDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromRegionDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRegionDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromRegionDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromRegionDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromRegionDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "RegionKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromRegionDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromRegionDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromRegionDirectiveTriviaCore(property, position, parent);
//    		InsertedFromRegionDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromRegionDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRegionDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromRegionDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromRegionDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromRegionDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromRegionDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "RegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromRegionDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromRegionDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromRegionDirectiveTriviaCore(property, parent);
//    		DeletedFromRegionDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromRegionDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRegionDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromRegionDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromRegionDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromRegionDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromRegionDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "RegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromRegionDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromRegionDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromRegionDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromRegionDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "RegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromRegionDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromRegionDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromRegionDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEndRegionDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEndRegionDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEndRegionDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEndRegionDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEndRegionDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEndRegionDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEndRegionDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEndRegionDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEndRegionDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEndRegionDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEndRegionDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEndRegionDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEndRegionDirectiveTriviaCore(property, position, parent);
//    		InsertedFromEndRegionDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEndRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEndRegionDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEndRegionDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEndRegionDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEndRegionDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEndRegionDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEndRegionDirectiveTriviaCore(property, parent);
//    		DeletedFromEndRegionDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEndRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEndRegionDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEndRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEndRegionDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEndRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEndRegionDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEndRegionDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEndRegionDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEndRegionDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromEndRegionDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEndRegionDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEndRegionDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEndRegionDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEndRegionDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEndRegionDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndRegionKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEndRegionDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEndRegionDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEndRegionDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromEndRegionDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromErrorDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromErrorDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromErrorDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromErrorDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromErrorDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromErrorDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromErrorDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromErrorDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromErrorDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromErrorDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ErrorKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromErrorDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromErrorDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromErrorDirectiveTriviaCore(property, position, parent);
//    		InsertedFromErrorDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromErrorDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromErrorDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromErrorDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromErrorDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromErrorDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromErrorDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromErrorDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromErrorDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromErrorDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromErrorDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ErrorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromErrorDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromErrorDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromErrorDirectiveTriviaCore(property, parent);
//    		DeletedFromErrorDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromErrorDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromErrorDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromErrorDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromErrorDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromErrorDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromErrorDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromErrorDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromErrorDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromErrorDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromErrorDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ErrorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromErrorDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromErrorDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromErrorDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromErrorDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromErrorDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromErrorDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromErrorDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromErrorDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromErrorDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromErrorDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ErrorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromErrorDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromErrorDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromErrorDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromErrorDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromWarningDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWarningDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromWarningDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromWarningDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromWarningDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromWarningDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWarningDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromWarningDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromWarningDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromWarningDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromWarningDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromWarningDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromWarningDirectiveTriviaCore(property, position, parent);
//    		InsertedFromWarningDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromWarningDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWarningDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromWarningDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromWarningDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromWarningDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromWarningDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromWarningDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromWarningDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromWarningDirectiveTriviaCore(property, parent);
//    		DeletedFromWarningDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromWarningDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWarningDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromWarningDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromWarningDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromWarningDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromWarningDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromWarningDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromWarningDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromWarningDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromWarningDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromWarningDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromWarningDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromWarningDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBadDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBadDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBadDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBadDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBadDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBadDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBadDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBadDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBadDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBadDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBadDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBadDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBadDirectiveTriviaCore(property, position, parent);
//    		InsertedFromBadDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBadDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBadDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBadDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBadDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBadDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBadDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBadDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBadDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBadDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBadDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBadDirectiveTriviaCore(property, parent);
//    		DeletedFromBadDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBadDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBadDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBadDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBadDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBadDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBadDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBadDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBadDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBadDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBadDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBadDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromBadDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBadDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBadDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromBadDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDefineDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefineDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDefineDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDefineDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDefineDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDefineDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefineDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDefineDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDefineDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDefineDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DefineKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDefineDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDefineDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDefineDirectiveTriviaCore(property, position, parent);
//    		InsertedFromDefineDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDefineDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefineDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDefineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDefineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDefineDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDefineDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefineDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDefineDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDefineDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDefineDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DefineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDefineDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDefineDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDefineDirectiveTriviaCore(property, parent);
//    		DeletedFromDefineDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDefineDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefineDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDefineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDefineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDefineDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDefineDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefineDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDefineDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDefineDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefineDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DefineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefineDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDefineDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDefineDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromDefineDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDefineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDefineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDefineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDefineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDefineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DefineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDefineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDefineDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDefineDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromDefineDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromUndefDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUndefDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromUndefDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromUndefDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromUndefDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromUndefDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUndefDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromUndefDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromUndefDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromUndefDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "UndefKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromUndefDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromUndefDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromUndefDirectiveTriviaCore(property, position, parent);
//    		InsertedFromUndefDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromUndefDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUndefDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromUndefDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromUndefDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromUndefDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromUndefDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUndefDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromUndefDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromUndefDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromUndefDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "UndefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromUndefDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromUndefDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromUndefDirectiveTriviaCore(property, parent);
//    		DeletedFromUndefDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromUndefDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUndefDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromUndefDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromUndefDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromUndefDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromUndefDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUndefDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromUndefDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromUndefDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromUndefDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "UndefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromUndefDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromUndefDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromUndefDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromUndefDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromUndefDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromUndefDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUndefDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromUndefDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromUndefDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromUndefDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "UndefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromUndefDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromUndefDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromUndefDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromUndefDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLineDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLineDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLineDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLineDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLineDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLineDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLineDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLineDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLineDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLineDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LineKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLineDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLineDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLineDirectiveTriviaCore(property, position, parent);
//    		InsertedFromLineDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLineDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLineDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLineDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLineDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLineDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLineDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLineDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLineDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLineDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLineDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLineDirectiveTriviaCore(property, parent);
//    		DeletedFromLineDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLineDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLineDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLineDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLineDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLineDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLineDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLineDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLineDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLineDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLineDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLineDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromLineDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLineDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLineDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLineDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLineDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLineDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLineDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LineKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLineDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLineDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLineDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromLineDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPragmaWarningDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPragmaWarningDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPragmaWarningDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPragmaWarningDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPragmaWarningDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPragmaWarningDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPragmaWarningDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPragmaWarningDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPragmaWarningDirectiveTriviaCore(property, position, parent);
//    		InsertedFromPragmaWarningDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPragmaWarningDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPragmaWarningDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPragmaWarningDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPragmaWarningDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPragmaWarningDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPragmaWarningDirectiveTriviaCore(property, parent);
//    		DeletedFromPragmaWarningDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPragmaWarningDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPragmaWarningDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPragmaWarningDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPragmaWarningDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPragmaWarningDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPragmaWarningDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromPragmaWarningDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPragmaWarningDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPragmaWarningDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPragmaWarningDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPragmaWarningDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPragmaWarningDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WarningKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPragmaWarningDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPragmaWarningDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPragmaWarningDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromPragmaWarningDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPragmaChecksumDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPragmaChecksumDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPragmaChecksumDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPragmaChecksumDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPragmaChecksumDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPragmaChecksumDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPragmaChecksumDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPragmaChecksumDirectiveTriviaCore(property, position, parent);
//    		InsertedFromPragmaChecksumDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPragmaChecksumDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPragmaChecksumDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPragmaChecksumDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPragmaChecksumDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPragmaChecksumDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPragmaChecksumDirectiveTriviaCore(property, parent);
//    		DeletedFromPragmaChecksumDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPragmaChecksumDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPragmaChecksumDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPragmaChecksumDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPragmaChecksumDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPragmaChecksumDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPragmaChecksumDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromPragmaChecksumDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPragmaChecksumDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPragmaChecksumDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPragmaChecksumDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPragmaChecksumDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPragmaChecksumDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "PragmaKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ChecksumKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPragmaChecksumDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPragmaChecksumDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPragmaChecksumDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromPragmaChecksumDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromReferenceDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromReferenceDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromReferenceDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromReferenceDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromReferenceDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromReferenceDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromReferenceDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromReferenceDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromReferenceDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromReferenceDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromReferenceDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromReferenceDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromReferenceDirectiveTriviaCore(property, position, parent);
//    		InsertedFromReferenceDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromReferenceDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromReferenceDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromReferenceDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromReferenceDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromReferenceDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromReferenceDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromReferenceDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromReferenceDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromReferenceDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromReferenceDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromReferenceDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromReferenceDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromReferenceDirectiveTriviaCore(property, parent);
//    		DeletedFromReferenceDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromReferenceDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromReferenceDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromReferenceDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromReferenceDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromReferenceDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromReferenceDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromReferenceDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromReferenceDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromReferenceDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromReferenceDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromReferenceDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromReferenceDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromReferenceDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromReferenceDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromReferenceDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromReferenceDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromReferenceDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromReferenceDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromReferenceDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReferenceKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromReferenceDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromReferenceDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromReferenceDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromReferenceDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLoadDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLoadDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLoadDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLoadDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLoadDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLoadDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLoadDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLoadDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLoadDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLoadDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LoadKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLoadDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLoadDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLoadDirectiveTriviaCore(property, position, parent);
//    		InsertedFromLoadDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLoadDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLoadDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLoadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLoadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLoadDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLoadDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLoadDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLoadDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLoadDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLoadDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LoadKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLoadDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLoadDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLoadDirectiveTriviaCore(property, parent);
//    		DeletedFromLoadDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLoadDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLoadDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLoadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLoadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLoadDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLoadDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLoadDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLoadDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLoadDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLoadDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LoadKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLoadDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLoadDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLoadDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromLoadDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLoadDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLoadDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLoadDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLoadDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLoadDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLoadDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "LoadKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLoadDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLoadDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLoadDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromLoadDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromShebangDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromShebangDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromShebangDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromShebangDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromShebangDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromShebangDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromShebangDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromShebangDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromShebangDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromShebangDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ExclamationToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromShebangDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromShebangDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromShebangDirectiveTriviaCore(property, position, parent);
//    		InsertedFromShebangDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromShebangDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromShebangDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromShebangDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromShebangDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromShebangDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromShebangDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromShebangDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromShebangDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromShebangDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromShebangDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ExclamationToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromShebangDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromShebangDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromShebangDirectiveTriviaCore(property, parent);
//    		DeletedFromShebangDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromShebangDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromShebangDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromShebangDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromShebangDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromShebangDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromShebangDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromShebangDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromShebangDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromShebangDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromShebangDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ExclamationToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromShebangDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromShebangDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromShebangDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromShebangDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromShebangDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromShebangDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromShebangDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromShebangDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromShebangDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromShebangDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ExclamationToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromShebangDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromShebangDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromShebangDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromShebangDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromElseDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElseDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromElseDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromElseDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromElseDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromElseDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElseDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromElseDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromElseDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromElseDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromElseDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromElseDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromElseDirectiveTriviaCore(property, position, parent);
//    		InsertedFromElseDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromElseDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElseDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromElseDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromElseDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromElseDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromElseDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElseDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromElseDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromElseDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromElseDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromElseDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromElseDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromElseDirectiveTriviaCore(property, parent);
//    		DeletedFromElseDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromElseDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElseDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromElseDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromElseDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromElseDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromElseDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElseDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromElseDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromElseDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromElseDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromElseDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromElseDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromElseDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromElseDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromElseDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromElseDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElseDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromElseDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromElseDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromElseDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElseKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromElseDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromElseDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromElseDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromElseDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIfDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIfDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIfDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIfDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIfDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIfDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIfDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIfDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIfDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIfDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIfDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIfDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIfDirectiveTriviaCore(property, position, parent);
//    		InsertedFromIfDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIfDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIfDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIfDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIfDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIfDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIfDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIfDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIfDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIfDirectiveTriviaCore(property, parent);
//    		DeletedFromIfDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIfDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIfDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIfDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIfDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIfDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIfDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIfDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIfDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIfDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromIfDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIfDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIfDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIfDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIfDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIfDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIfDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIfDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIfDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIfDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromIfDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromElifDirectiveTrivia(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElifDirectiveTrivia(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromElifDirectiveTriviaCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromElifDirectiveTrivia(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromElifDirectiveTriviaBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromElifDirectiveTriviaCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElifDirectiveTriviaCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromElifDirectiveTriviaAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromElifDirectiveTrivia(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromElifDirectiveTriviaCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElifKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromElifDirectiveTrivia(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromElifDirectiveTriviaBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromElifDirectiveTriviaCore(property, position, parent);
//    		InsertedFromElifDirectiveTriviaAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromElifDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElifDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromElifDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromElifDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromElifDirectiveTriviaBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromElifDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElifDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromElifDirectiveTriviaAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromElifDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromElifDirectiveTriviaCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElifKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromElifDirectiveTrivia(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromElifDirectiveTriviaBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromElifDirectiveTriviaCore(property, parent);
//    		DeletedFromElifDirectiveTriviaAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromElifDirectiveTrivia(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElifDirectiveTrivia(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromElifDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromElifDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromElifDirectiveTriviaBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromElifDirectiveTriviaCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElifDirectiveTriviaCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromElifDirectiveTriviaAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromElifDirectiveTrivia(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromElifDirectiveTriviaCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElifKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromElifDirectiveTrivia(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromElifDirectiveTriviaBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromElifDirectiveTriviaCore(oldElement, newElement);
//    		UpdatedFromElifDirectiveTriviaAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromElifDirectiveTrivia(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromElifDirectiveTriviaBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElifDirectiveTriviaCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromElifDirectiveTriviaAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromElifDirectiveTrivia(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromElifDirectiveTriviaCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "HashToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ElifKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndOfDirectiveToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromElifDirectiveTrivia(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromElifDirectiveTriviaBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromElifDirectiveTriviaCore(property, oldPArent, position, newParent);
//    		MovedFromElifDirectiveTriviaAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeCrefCore(property, position, parent);
//    		InsertedFromTypeCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeCrefCore(property, parent);
//    		DeletedFromTypeCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeCrefCore(oldElement, newElement);
//    		UpdatedFromTypeCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeCrefCore(property, oldPArent, position, newParent);
//    		MovedFromTypeCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromQualifiedCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQualifiedCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromQualifiedCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromQualifiedCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromQualifiedCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromQualifiedCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQualifiedCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromQualifiedCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromQualifiedCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromQualifiedCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromQualifiedCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromQualifiedCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromQualifiedCrefCore(property, position, parent);
//    		InsertedFromQualifiedCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromQualifiedCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQualifiedCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromQualifiedCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromQualifiedCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromQualifiedCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromQualifiedCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQualifiedCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromQualifiedCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromQualifiedCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromQualifiedCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromQualifiedCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromQualifiedCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromQualifiedCrefCore(property, parent);
//    		DeletedFromQualifiedCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromQualifiedCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQualifiedCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromQualifiedCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromQualifiedCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromQualifiedCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromQualifiedCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQualifiedCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromQualifiedCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromQualifiedCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromQualifiedCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromQualifiedCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromQualifiedCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromQualifiedCrefCore(oldElement, newElement);
//    		UpdatedFromQualifiedCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromQualifiedCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQualifiedCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromQualifiedCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromQualifiedCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromQualifiedCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromQualifiedCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQualifiedCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromQualifiedCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromQualifiedCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromQualifiedCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromQualifiedCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromQualifiedCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromQualifiedCrefCore(property, oldPArent, position, newParent);
//    		MovedFromQualifiedCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromNameMemberCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameMemberCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromNameMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromNameMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromNameMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromNameMemberCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNameMemberCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromNameMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromNameMemberCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromNameMemberCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromNameMemberCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromNameMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromNameMemberCrefCore(property, position, parent);
//    		InsertedFromNameMemberCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromNameMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromNameMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromNameMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromNameMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromNameMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNameMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromNameMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromNameMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromNameMemberCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromNameMemberCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromNameMemberCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromNameMemberCrefCore(property, parent);
//    		DeletedFromNameMemberCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromNameMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromNameMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromNameMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromNameMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromNameMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNameMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromNameMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromNameMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameMemberCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromNameMemberCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromNameMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromNameMemberCrefCore(oldElement, newElement);
//    		UpdatedFromNameMemberCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromNameMemberCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameMemberCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromNameMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromNameMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromNameMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromNameMemberCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNameMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromNameMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromNameMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromNameMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromNameMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromNameMemberCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromNameMemberCrefCore(property, oldPArent, position, newParent);
//    		MovedFromNameMemberCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIndexerMemberCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIndexerMemberCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIndexerMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIndexerMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIndexerMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIndexerMemberCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIndexerMemberCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIndexerMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIndexerMemberCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIndexerMemberCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIndexerMemberCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIndexerMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIndexerMemberCrefCore(property, position, parent);
//    		InsertedFromIndexerMemberCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIndexerMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIndexerMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIndexerMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIndexerMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIndexerMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIndexerMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIndexerMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIndexerMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIndexerMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIndexerMemberCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIndexerMemberCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIndexerMemberCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIndexerMemberCrefCore(property, parent);
//    		DeletedFromIndexerMemberCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIndexerMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIndexerMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIndexerMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIndexerMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIndexerMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIndexerMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIndexerMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIndexerMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIndexerMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIndexerMemberCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIndexerMemberCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIndexerMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIndexerMemberCrefCore(oldElement, newElement);
//    		UpdatedFromIndexerMemberCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIndexerMemberCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIndexerMemberCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIndexerMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIndexerMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIndexerMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIndexerMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIndexerMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIndexerMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIndexerMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThisKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIndexerMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIndexerMemberCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIndexerMemberCrefCore(property, oldPArent, position, newParent);
//    		MovedFromIndexerMemberCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOperatorMemberCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOperatorMemberCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOperatorMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOperatorMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOperatorMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOperatorMemberCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOperatorMemberCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOperatorMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOperatorMemberCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOperatorMemberCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOperatorMemberCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOperatorMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOperatorMemberCrefCore(property, position, parent);
//    		InsertedFromOperatorMemberCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOperatorMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOperatorMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOperatorMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOperatorMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOperatorMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOperatorMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOperatorMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOperatorMemberCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOperatorMemberCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOperatorMemberCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOperatorMemberCrefCore(property, parent);
//    		DeletedFromOperatorMemberCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOperatorMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOperatorMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOperatorMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOperatorMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOperatorMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOperatorMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOperatorMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOperatorMemberCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOperatorMemberCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOperatorMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOperatorMemberCrefCore(oldElement, newElement);
//    		UpdatedFromOperatorMemberCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOperatorMemberCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOperatorMemberCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOperatorMemberCrefCore(property, oldPArent, position, newParent);
//    		MovedFromOperatorMemberCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConversionOperatorMemberCref(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConversionOperatorMemberCref(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConversionOperatorMemberCrefCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConversionOperatorMemberCref(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConversionOperatorMemberCrefBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConversionOperatorMemberCrefCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConversionOperatorMemberCrefCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConversionOperatorMemberCrefAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConversionOperatorMemberCref(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConversionOperatorMemberCrefCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConversionOperatorMemberCref(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConversionOperatorMemberCrefBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConversionOperatorMemberCrefCore(property, position, parent);
//    		InsertedFromConversionOperatorMemberCrefAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConversionOperatorMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConversionOperatorMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConversionOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConversionOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConversionOperatorMemberCrefBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConversionOperatorMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConversionOperatorMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConversionOperatorMemberCrefAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConversionOperatorMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConversionOperatorMemberCrefCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConversionOperatorMemberCref(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConversionOperatorMemberCrefBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConversionOperatorMemberCrefCore(property, parent);
//    		DeletedFromConversionOperatorMemberCrefAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConversionOperatorMemberCref(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConversionOperatorMemberCref(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConversionOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConversionOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConversionOperatorMemberCrefBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConversionOperatorMemberCrefCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConversionOperatorMemberCrefCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConversionOperatorMemberCrefAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConversionOperatorMemberCref(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConversionOperatorMemberCrefCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConversionOperatorMemberCref(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConversionOperatorMemberCrefBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConversionOperatorMemberCrefCore(oldElement, newElement);
//    		UpdatedFromConversionOperatorMemberCrefAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConversionOperatorMemberCref(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConversionOperatorMemberCrefBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConversionOperatorMemberCrefCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConversionOperatorMemberCrefAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConversionOperatorMemberCref(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConversionOperatorMemberCrefCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ImplicitOrExplicitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OperatorKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConversionOperatorMemberCref(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConversionOperatorMemberCrefBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConversionOperatorMemberCrefCore(property, oldPArent, position, newParent);
//    		MovedFromConversionOperatorMemberCrefAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCrefParameterList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefParameterList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCrefParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCrefParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCrefParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCrefParameterListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefParameterListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCrefParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCrefParameterList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefParameterListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefParameterList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCrefParameterListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCrefParameterListCore(property, position, parent);
//    		InsertedFromCrefParameterListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCrefParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCrefParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCrefParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCrefParameterListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCrefParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefParameterListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCrefParameterListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCrefParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefParameterListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefParameterList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCrefParameterListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCrefParameterListCore(property, parent);
//    		DeletedFromCrefParameterListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCrefParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCrefParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCrefParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCrefParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCrefParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefParameterListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCrefParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCrefParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefParameterListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefParameterList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCrefParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCrefParameterListCore(oldElement, newElement);
//    		UpdatedFromCrefParameterListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCrefParameterList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefParameterList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCrefParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCrefParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCrefParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCrefParameterListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefParameterListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCrefParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCrefParameterList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCrefParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCrefParameterList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCrefParameterListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCrefParameterListCore(property, oldPArent, position, newParent);
//    		MovedFromCrefParameterListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCrefBracketedParameterList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefBracketedParameterList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCrefBracketedParameterListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCrefBracketedParameterList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCrefBracketedParameterListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCrefBracketedParameterListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCrefBracketedParameterListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCrefBracketedParameterListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCrefBracketedParameterList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefBracketedParameterListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCrefBracketedParameterList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCrefBracketedParameterListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCrefBracketedParameterListCore(property, position, parent);
//    		InsertedFromCrefBracketedParameterListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCrefBracketedParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefBracketedParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCrefBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCrefBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCrefBracketedParameterListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCrefBracketedParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCrefBracketedParameterListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCrefBracketedParameterListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCrefBracketedParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefBracketedParameterListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCrefBracketedParameterList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCrefBracketedParameterListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCrefBracketedParameterListCore(property, parent);
//    		DeletedFromCrefBracketedParameterListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCrefBracketedParameterList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefBracketedParameterList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCrefBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCrefBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCrefBracketedParameterListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCrefBracketedParameterListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCrefBracketedParameterListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCrefBracketedParameterListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCrefBracketedParameterList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefBracketedParameterListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCrefBracketedParameterList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCrefBracketedParameterListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCrefBracketedParameterListCore(oldElement, newElement);
//    		UpdatedFromCrefBracketedParameterListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCrefBracketedParameterList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCrefBracketedParameterListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCrefBracketedParameterListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCrefBracketedParameterListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCrefBracketedParameterList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCrefBracketedParameterListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCrefBracketedParameterList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCrefBracketedParameterListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCrefBracketedParameterListCore(property, oldPArent, position, newParent);
//    		MovedFromCrefBracketedParameterListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlElement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlElementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlElementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlElementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlElementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlElement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlElement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlElementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlElementCore(property, position, parent);
//    		InsertedFromXmlElementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlElementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlElementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlElementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlElement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlElementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlElementCore(property, parent);
//    		DeletedFromXmlElementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlElementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlElement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlElementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlElementCore(oldElement, newElement);
//    		UpdatedFromXmlElementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlElement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlElementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlElementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlElement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlElement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlElementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlElementCore(property, oldPArent, position, newParent);
//    		MovedFromXmlElementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlEmptyElement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlEmptyElement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlEmptyElementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlEmptyElement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlEmptyElementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlEmptyElementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlEmptyElementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlEmptyElementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlEmptyElement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlEmptyElementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlEmptyElement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlEmptyElementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlEmptyElementCore(property, position, parent);
//    		InsertedFromXmlEmptyElementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlEmptyElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlEmptyElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlEmptyElementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlEmptyElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlEmptyElementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlEmptyElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlEmptyElementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlEmptyElementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlEmptyElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlEmptyElementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlEmptyElement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlEmptyElementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlEmptyElementCore(property, parent);
//    		DeletedFromXmlEmptyElementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlEmptyElement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlEmptyElement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlEmptyElementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlEmptyElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlEmptyElementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlEmptyElementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlEmptyElementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlEmptyElementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlEmptyElement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlEmptyElementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlEmptyElement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlEmptyElementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlEmptyElementCore(oldElement, newElement);
//    		UpdatedFromXmlEmptyElementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlEmptyElement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlEmptyElement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlEmptyElementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlEmptyElement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlEmptyElementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlEmptyElementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlEmptyElementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlEmptyElement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlEmptyElementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SlashGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlEmptyElement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlEmptyElementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlEmptyElementCore(property, oldPArent, position, newParent);
//    		MovedFromXmlEmptyElementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlText(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlText(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlTextCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlText(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlTextBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlTextCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlTextCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlTextAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlText(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlTextCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlText(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlTextBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlTextCore(property, position, parent);
//    		InsertedFromXmlTextAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlText(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlText(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlTextCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlTextBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlTextCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlTextCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlTextAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlText(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlTextCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlText(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlTextBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlTextCore(property, parent);
//    		DeletedFromXmlTextAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlText(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlText(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlTextCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlTextBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlTextCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlTextCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlTextAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlText(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlTextCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlText(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlTextBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlTextCore(oldElement, newElement);
//    		UpdatedFromXmlTextAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlText(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlText(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlTextCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlTextCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlText(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlTextCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlText(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlTextBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlTextCore(property, oldPArent, position, newParent);
//    		MovedFromXmlTextAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlCDataSection(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlCDataSection(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlCDataSectionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlCDataSection(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlCDataSectionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlCDataSectionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlCDataSectionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlCDataSectionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlCDataSection(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlCDataSectionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartCDataToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndCDataToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlCDataSection(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlCDataSectionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlCDataSectionCore(property, position, parent);
//    		InsertedFromXmlCDataSectionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlCDataSection(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlCDataSection(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlCDataSectionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlCDataSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlCDataSectionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlCDataSectionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlCDataSectionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlCDataSectionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlCDataSection(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlCDataSectionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlCDataSection(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlCDataSectionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlCDataSectionCore(property, parent);
//    		DeletedFromXmlCDataSectionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlCDataSection(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlCDataSection(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlCDataSectionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlCDataSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlCDataSectionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlCDataSectionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlCDataSectionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlCDataSectionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlCDataSection(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlCDataSectionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlCDataSection(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlCDataSectionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlCDataSectionCore(oldElement, newElement);
//    		UpdatedFromXmlCDataSectionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlCDataSection(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlCDataSection(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlCDataSectionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlCDataSection(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlCDataSectionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlCDataSectionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlCDataSectionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlCDataSection(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlCDataSectionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndCDataToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlCDataSection(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlCDataSectionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlCDataSectionCore(property, oldPArent, position, newParent);
//    		MovedFromXmlCDataSectionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlProcessingInstruction(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlProcessingInstruction(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlProcessingInstructionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlProcessingInstruction(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlProcessingInstructionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlProcessingInstructionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlProcessingInstructionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlProcessingInstructionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlProcessingInstruction(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlProcessingInstructionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlProcessingInstruction(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlProcessingInstructionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlProcessingInstructionCore(property, position, parent);
//    		InsertedFromXmlProcessingInstructionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlProcessingInstruction(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlProcessingInstruction(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlProcessingInstructionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlProcessingInstruction(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlProcessingInstructionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlProcessingInstructionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlProcessingInstructionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlProcessingInstructionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlProcessingInstruction(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlProcessingInstructionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlProcessingInstruction(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlProcessingInstructionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlProcessingInstructionCore(property, parent);
//    		DeletedFromXmlProcessingInstructionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlProcessingInstruction(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlProcessingInstruction(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlProcessingInstructionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlProcessingInstruction(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlProcessingInstructionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlProcessingInstructionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlProcessingInstructionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlProcessingInstructionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlProcessingInstruction(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlProcessingInstructionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlProcessingInstruction(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlProcessingInstructionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlProcessingInstructionCore(oldElement, newElement);
//    		UpdatedFromXmlProcessingInstructionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlProcessingInstruction(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlProcessingInstructionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlProcessingInstructionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlProcessingInstructionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlProcessingInstruction(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlProcessingInstructionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StartProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndProcessingInstructionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlProcessingInstruction(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlProcessingInstructionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlProcessingInstructionCore(property, oldPArent, position, newParent);
//    		MovedFromXmlProcessingInstructionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlComment(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlComment(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlCommentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlComment(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlCommentBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlCommentCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlCommentCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlCommentAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlComment(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlCommentCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlComment(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlCommentBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlCommentCore(property, position, parent);
//    		InsertedFromXmlCommentAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlComment(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlComment(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlCommentCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlComment(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlCommentBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlCommentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlCommentCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlCommentAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlComment(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlCommentCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlComment(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlCommentBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlCommentCore(property, parent);
//    		DeletedFromXmlCommentAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlComment(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlComment(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlCommentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlComment(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlCommentBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlCommentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlCommentCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlCommentAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlComment(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlCommentCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlComment(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlCommentBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlCommentCore(oldElement, newElement);
//    		UpdatedFromXmlCommentAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlComment(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlComment(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlCommentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlComment(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlCommentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlCommentCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlCommentCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlCommentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlComment(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlCommentCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "MinusMinusGreaterThanToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlComment(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlCommentBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlCommentCore(property, oldPArent, position, newParent);
//    		MovedFromXmlCommentAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlTextAttribute(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlTextAttribute(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlTextAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlTextAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlTextAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlTextAttributeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlTextAttributeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlTextAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlTextAttribute(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlTextAttributeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlTextAttribute(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlTextAttributeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlTextAttributeCore(property, position, parent);
//    		InsertedFromXmlTextAttributeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlTextAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlTextAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlTextAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlTextAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlTextAttributeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlTextAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlTextAttributeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlTextAttributeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlTextAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlTextAttributeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlTextAttribute(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlTextAttributeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlTextAttributeCore(property, parent);
//    		DeletedFromXmlTextAttributeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlTextAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlTextAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlTextAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlTextAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlTextAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlTextAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlTextAttributeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlTextAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlTextAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlTextAttributeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlTextAttribute(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlTextAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlTextAttributeCore(oldElement, newElement);
//    		UpdatedFromXmlTextAttributeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlTextAttribute(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlTextAttribute(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlTextAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlTextAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlTextAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlTextAttributeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlTextAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlTextAttribute(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlTextAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlTextAttribute(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlTextAttributeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlTextAttributeCore(property, oldPArent, position, newParent);
//    		MovedFromXmlTextAttributeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlCrefAttribute(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlCrefAttribute(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlCrefAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlCrefAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlCrefAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlCrefAttributeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlCrefAttributeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlCrefAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlCrefAttribute(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlCrefAttributeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlCrefAttribute(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlCrefAttributeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlCrefAttributeCore(property, position, parent);
//    		InsertedFromXmlCrefAttributeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlCrefAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlCrefAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlCrefAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlCrefAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlCrefAttributeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlCrefAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlCrefAttributeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlCrefAttributeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlCrefAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlCrefAttributeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlCrefAttribute(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlCrefAttributeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlCrefAttributeCore(property, parent);
//    		DeletedFromXmlCrefAttributeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlCrefAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlCrefAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlCrefAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlCrefAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlCrefAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlCrefAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlCrefAttributeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlCrefAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlCrefAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlCrefAttributeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlCrefAttribute(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlCrefAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlCrefAttributeCore(oldElement, newElement);
//    		UpdatedFromXmlCrefAttributeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlCrefAttribute(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlCrefAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlCrefAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlCrefAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlCrefAttributeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlCrefAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlCrefAttribute(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlCrefAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlCrefAttribute(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlCrefAttributeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlCrefAttributeCore(property, oldPArent, position, newParent);
//    		MovedFromXmlCrefAttributeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromXmlNameAttribute(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlNameAttribute(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromXmlNameAttributeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromXmlNameAttribute(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromXmlNameAttributeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromXmlNameAttributeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromXmlNameAttributeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromXmlNameAttributeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromXmlNameAttribute(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlNameAttributeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromXmlNameAttribute(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromXmlNameAttributeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromXmlNameAttributeCore(property, position, parent);
//    		InsertedFromXmlNameAttributeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromXmlNameAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlNameAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromXmlNameAttributeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromXmlNameAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromXmlNameAttributeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromXmlNameAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromXmlNameAttributeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromXmlNameAttributeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromXmlNameAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlNameAttributeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromXmlNameAttribute(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromXmlNameAttributeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromXmlNameAttributeCore(property, parent);
//    		DeletedFromXmlNameAttributeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromXmlNameAttribute(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlNameAttribute(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromXmlNameAttributeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromXmlNameAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromXmlNameAttributeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromXmlNameAttributeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromXmlNameAttributeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromXmlNameAttributeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromXmlNameAttribute(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlNameAttributeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromXmlNameAttribute(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromXmlNameAttributeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromXmlNameAttributeCore(oldElement, newElement);
//    		UpdatedFromXmlNameAttributeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromXmlNameAttribute(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlNameAttribute(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromXmlNameAttributeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromXmlNameAttribute(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromXmlNameAttributeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromXmlNameAttributeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromXmlNameAttributeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromXmlNameAttribute(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromXmlNameAttributeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Name")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StartQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EndQuoteToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromXmlNameAttribute(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromXmlNameAttributeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromXmlNameAttributeCore(property, oldPArent, position, newParent);
//    		MovedFromXmlNameAttributeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromParenthesizedExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromParenthesizedExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromParenthesizedExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromParenthesizedExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromParenthesizedExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromParenthesizedExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromParenthesizedExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromParenthesizedExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromParenthesizedExpressionCore(property, position, parent);
//    		InsertedFromParenthesizedExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromParenthesizedExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromParenthesizedExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromParenthesizedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromParenthesizedExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromParenthesizedExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromParenthesizedExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromParenthesizedExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromParenthesizedExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromParenthesizedExpressionCore(property, parent);
//    		DeletedFromParenthesizedExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromParenthesizedExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromParenthesizedExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromParenthesizedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromParenthesizedExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromParenthesizedExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromParenthesizedExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromParenthesizedExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromParenthesizedExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromParenthesizedExpressionCore(oldElement, newElement);
//    		UpdatedFromParenthesizedExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromParenthesizedExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromParenthesizedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromParenthesizedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromParenthesizedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromParenthesizedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromParenthesizedExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromParenthesizedExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromParenthesizedExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromParenthesizedExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTupleExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTupleExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTupleExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTupleExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTupleExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTupleExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTupleExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTupleExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTupleExpressionCore(property, position, parent);
//    		InsertedFromTupleExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTupleExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTupleExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTupleExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTupleExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTupleExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTupleExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTupleExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTupleExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTupleExpressionCore(property, parent);
//    		DeletedFromTupleExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTupleExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTupleExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTupleExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTupleExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTupleExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTupleExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTupleExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTupleExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTupleExpressionCore(oldElement, newElement);
//    		UpdatedFromTupleExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTupleExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTupleExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTupleExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTupleExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTupleExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTupleExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTupleExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTupleExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTupleExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTupleExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTupleExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromTupleExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPrefixUnaryExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPrefixUnaryExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPrefixUnaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPrefixUnaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPrefixUnaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPrefixUnaryExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPrefixUnaryExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPrefixUnaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPrefixUnaryExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPrefixUnaryExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPrefixUnaryExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPrefixUnaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPrefixUnaryExpressionCore(property, position, parent);
//    		InsertedFromPrefixUnaryExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPrefixUnaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPrefixUnaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPrefixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPrefixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPrefixUnaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPrefixUnaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPrefixUnaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPrefixUnaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPrefixUnaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPrefixUnaryExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPrefixUnaryExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPrefixUnaryExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPrefixUnaryExpressionCore(property, parent);
//    		DeletedFromPrefixUnaryExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPrefixUnaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPrefixUnaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPrefixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPrefixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPrefixUnaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPrefixUnaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPrefixUnaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPrefixUnaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPrefixUnaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPrefixUnaryExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPrefixUnaryExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPrefixUnaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPrefixUnaryExpressionCore(oldElement, newElement);
//    		UpdatedFromPrefixUnaryExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPrefixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPrefixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPrefixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPrefixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPrefixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPrefixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPrefixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPrefixUnaryExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPrefixUnaryExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromPrefixUnaryExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAwaitExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAwaitExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAwaitExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAwaitExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAwaitExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAwaitExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAwaitExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAwaitExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAwaitExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAwaitExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AwaitKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAwaitExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAwaitExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAwaitExpressionCore(property, position, parent);
//    		InsertedFromAwaitExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAwaitExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAwaitExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAwaitExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAwaitExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAwaitExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAwaitExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAwaitExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAwaitExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAwaitExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAwaitExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AwaitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAwaitExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAwaitExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAwaitExpressionCore(property, parent);
//    		DeletedFromAwaitExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAwaitExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAwaitExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAwaitExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAwaitExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAwaitExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAwaitExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAwaitExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAwaitExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAwaitExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAwaitExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AwaitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAwaitExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAwaitExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAwaitExpressionCore(oldElement, newElement);
//    		UpdatedFromAwaitExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAwaitExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAwaitExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAwaitExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAwaitExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAwaitExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAwaitExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAwaitExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAwaitExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAwaitExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAwaitExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AwaitKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAwaitExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAwaitExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAwaitExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromAwaitExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPostfixUnaryExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPostfixUnaryExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPostfixUnaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPostfixUnaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPostfixUnaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPostfixUnaryExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPostfixUnaryExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPostfixUnaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPostfixUnaryExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPostfixUnaryExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPostfixUnaryExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPostfixUnaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPostfixUnaryExpressionCore(property, position, parent);
//    		InsertedFromPostfixUnaryExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPostfixUnaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPostfixUnaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPostfixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPostfixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPostfixUnaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPostfixUnaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPostfixUnaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPostfixUnaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPostfixUnaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPostfixUnaryExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPostfixUnaryExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPostfixUnaryExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPostfixUnaryExpressionCore(property, parent);
//    		DeletedFromPostfixUnaryExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPostfixUnaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPostfixUnaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPostfixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPostfixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPostfixUnaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPostfixUnaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPostfixUnaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPostfixUnaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPostfixUnaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPostfixUnaryExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPostfixUnaryExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPostfixUnaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPostfixUnaryExpressionCore(oldElement, newElement);
//    		UpdatedFromPostfixUnaryExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPostfixUnaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPostfixUnaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPostfixUnaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPostfixUnaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPostfixUnaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPostfixUnaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPostfixUnaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPostfixUnaryExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPostfixUnaryExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromPostfixUnaryExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromMemberAccessExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMemberAccessExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromMemberAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromMemberAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromMemberAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromMemberAccessExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMemberAccessExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromMemberAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromMemberAccessExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromMemberAccessExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromMemberAccessExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromMemberAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromMemberAccessExpressionCore(property, position, parent);
//    		InsertedFromMemberAccessExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromMemberAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMemberAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromMemberAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromMemberAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromMemberAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromMemberAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMemberAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromMemberAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromMemberAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromMemberAccessExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromMemberAccessExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromMemberAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromMemberAccessExpressionCore(property, parent);
//    		DeletedFromMemberAccessExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromMemberAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMemberAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromMemberAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromMemberAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromMemberAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromMemberAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMemberAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromMemberAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromMemberAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromMemberAccessExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromMemberAccessExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromMemberAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromMemberAccessExpressionCore(oldElement, newElement);
//    		UpdatedFromMemberAccessExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromMemberAccessExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMemberAccessExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromMemberAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromMemberAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromMemberAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMemberAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromMemberAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromMemberAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromMemberAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromMemberAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromMemberAccessExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromMemberAccessExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromMemberAccessExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConditionalAccessExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConditionalAccessExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConditionalAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConditionalAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConditionalAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConditionalAccessExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConditionalAccessExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConditionalAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConditionalAccessExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConditionalAccessExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConditionalAccessExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConditionalAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConditionalAccessExpressionCore(property, position, parent);
//    		InsertedFromConditionalAccessExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConditionalAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConditionalAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConditionalAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConditionalAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConditionalAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConditionalAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConditionalAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConditionalAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConditionalAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConditionalAccessExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConditionalAccessExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConditionalAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConditionalAccessExpressionCore(property, parent);
//    		DeletedFromConditionalAccessExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConditionalAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConditionalAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConditionalAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConditionalAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConditionalAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConditionalAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConditionalAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConditionalAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConditionalAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConditionalAccessExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConditionalAccessExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConditionalAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConditionalAccessExpressionCore(oldElement, newElement);
//    		UpdatedFromConditionalAccessExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConditionalAccessExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConditionalAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConditionalAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConditionalAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConditionalAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConditionalAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConditionalAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConditionalAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConditionalAccessExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConditionalAccessExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromConditionalAccessExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromMemberBindingExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMemberBindingExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromMemberBindingExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromMemberBindingExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromMemberBindingExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromMemberBindingExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMemberBindingExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromMemberBindingExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromMemberBindingExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromMemberBindingExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromMemberBindingExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromMemberBindingExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromMemberBindingExpressionCore(property, position, parent);
//    		InsertedFromMemberBindingExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromMemberBindingExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMemberBindingExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromMemberBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromMemberBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromMemberBindingExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromMemberBindingExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMemberBindingExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromMemberBindingExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromMemberBindingExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromMemberBindingExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromMemberBindingExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromMemberBindingExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromMemberBindingExpressionCore(property, parent);
//    		DeletedFromMemberBindingExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromMemberBindingExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMemberBindingExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromMemberBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromMemberBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromMemberBindingExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromMemberBindingExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMemberBindingExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromMemberBindingExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromMemberBindingExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromMemberBindingExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromMemberBindingExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromMemberBindingExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromMemberBindingExpressionCore(oldElement, newElement);
//    		UpdatedFromMemberBindingExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromMemberBindingExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMemberBindingExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromMemberBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromMemberBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromMemberBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMemberBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromMemberBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromMemberBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromMemberBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromMemberBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromMemberBindingExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromMemberBindingExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromMemberBindingExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromElementBindingExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElementBindingExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromElementBindingExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromElementBindingExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromElementBindingExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromElementBindingExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElementBindingExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromElementBindingExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromElementBindingExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromElementBindingExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromElementBindingExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromElementBindingExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromElementBindingExpressionCore(property, position, parent);
//    		InsertedFromElementBindingExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromElementBindingExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElementBindingExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromElementBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromElementBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromElementBindingExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromElementBindingExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElementBindingExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromElementBindingExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromElementBindingExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromElementBindingExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromElementBindingExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromElementBindingExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromElementBindingExpressionCore(property, parent);
//    		DeletedFromElementBindingExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromElementBindingExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElementBindingExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromElementBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromElementBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromElementBindingExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromElementBindingExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElementBindingExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromElementBindingExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromElementBindingExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromElementBindingExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromElementBindingExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromElementBindingExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromElementBindingExpressionCore(oldElement, newElement);
//    		UpdatedFromElementBindingExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromElementBindingExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElementBindingExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromElementBindingExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromElementBindingExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromElementBindingExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElementBindingExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromElementBindingExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromElementBindingExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromElementBindingExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromElementBindingExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromElementBindingExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromElementBindingExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromElementBindingExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromImplicitElementAccess(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromImplicitElementAccess(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromImplicitElementAccessCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromImplicitElementAccess(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromImplicitElementAccessBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromImplicitElementAccessCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromImplicitElementAccessCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromImplicitElementAccessAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromImplicitElementAccess(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromImplicitElementAccessCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromImplicitElementAccess(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromImplicitElementAccessBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromImplicitElementAccessCore(property, position, parent);
//    		InsertedFromImplicitElementAccessAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromImplicitElementAccess(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromImplicitElementAccess(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromImplicitElementAccessCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromImplicitElementAccess(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromImplicitElementAccessBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromImplicitElementAccessCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromImplicitElementAccessCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromImplicitElementAccessAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromImplicitElementAccess(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromImplicitElementAccessCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromImplicitElementAccess(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromImplicitElementAccessBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromImplicitElementAccessCore(property, parent);
//    		DeletedFromImplicitElementAccessAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromImplicitElementAccess(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromImplicitElementAccess(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromImplicitElementAccessCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromImplicitElementAccess(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromImplicitElementAccessBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromImplicitElementAccessCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromImplicitElementAccessCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromImplicitElementAccessAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromImplicitElementAccess(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromImplicitElementAccessCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromImplicitElementAccess(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromImplicitElementAccessBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromImplicitElementAccessCore(oldElement, newElement);
//    		UpdatedFromImplicitElementAccessAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromImplicitElementAccess(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromImplicitElementAccess(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromImplicitElementAccessCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromImplicitElementAccess(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromImplicitElementAccessBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromImplicitElementAccessCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromImplicitElementAccessAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromImplicitElementAccess(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromImplicitElementAccessCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromImplicitElementAccess(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromImplicitElementAccessBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromImplicitElementAccessCore(property, oldPArent, position, newParent);
//    		MovedFromImplicitElementAccessAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBinaryExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBinaryExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBinaryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBinaryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBinaryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBinaryExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBinaryExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBinaryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBinaryExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBinaryExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBinaryExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBinaryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBinaryExpressionCore(property, position, parent);
//    		InsertedFromBinaryExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBinaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBinaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBinaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBinaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBinaryExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBinaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBinaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBinaryExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBinaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBinaryExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBinaryExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBinaryExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBinaryExpressionCore(property, parent);
//    		DeletedFromBinaryExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBinaryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBinaryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBinaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBinaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBinaryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBinaryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBinaryExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBinaryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBinaryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBinaryExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBinaryExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBinaryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBinaryExpressionCore(oldElement, newElement);
//    		UpdatedFromBinaryExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBinaryExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBinaryExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBinaryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBinaryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBinaryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBinaryExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBinaryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBinaryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBinaryExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBinaryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBinaryExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBinaryExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBinaryExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromBinaryExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAssignmentExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAssignmentExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAssignmentExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAssignmentExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAssignmentExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAssignmentExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAssignmentExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAssignmentExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAssignmentExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAssignmentExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAssignmentExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAssignmentExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAssignmentExpressionCore(property, position, parent);
//    		InsertedFromAssignmentExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAssignmentExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAssignmentExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAssignmentExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAssignmentExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAssignmentExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAssignmentExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAssignmentExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAssignmentExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAssignmentExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAssignmentExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAssignmentExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAssignmentExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAssignmentExpressionCore(property, parent);
//    		DeletedFromAssignmentExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAssignmentExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAssignmentExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAssignmentExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAssignmentExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAssignmentExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAssignmentExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAssignmentExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAssignmentExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAssignmentExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAssignmentExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAssignmentExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAssignmentExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAssignmentExpressionCore(oldElement, newElement);
//    		UpdatedFromAssignmentExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAssignmentExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAssignmentExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAssignmentExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAssignmentExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAssignmentExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAssignmentExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAssignmentExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAssignmentExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAssignmentExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OperatorToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAssignmentExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAssignmentExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAssignmentExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromAssignmentExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConditionalExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConditionalExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConditionalExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConditionalExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConditionalExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConditionalExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConditionalExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConditionalExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConditionalExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConditionalExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConditionalExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConditionalExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConditionalExpressionCore(property, position, parent);
//    		InsertedFromConditionalExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConditionalExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConditionalExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConditionalExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConditionalExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConditionalExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConditionalExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConditionalExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConditionalExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConditionalExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConditionalExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConditionalExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConditionalExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConditionalExpressionCore(property, parent);
//    		DeletedFromConditionalExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConditionalExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConditionalExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConditionalExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConditionalExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConditionalExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConditionalExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConditionalExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConditionalExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConditionalExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConditionalExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConditionalExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConditionalExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConditionalExpressionCore(oldElement, newElement);
//    		UpdatedFromConditionalExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConditionalExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConditionalExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConditionalExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConditionalExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConditionalExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConditionalExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConditionalExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConditionalExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConditionalExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConditionalExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConditionalExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConditionalExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConditionalExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromConditionalExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLiteralExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLiteralExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLiteralExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLiteralExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLiteralExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLiteralExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLiteralExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLiteralExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLiteralExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLiteralExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLiteralExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLiteralExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLiteralExpressionCore(property, position, parent);
//    		InsertedFromLiteralExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLiteralExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLiteralExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLiteralExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLiteralExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLiteralExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLiteralExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLiteralExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLiteralExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLiteralExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLiteralExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLiteralExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLiteralExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLiteralExpressionCore(property, parent);
//    		DeletedFromLiteralExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLiteralExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLiteralExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLiteralExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLiteralExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLiteralExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLiteralExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLiteralExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLiteralExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLiteralExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLiteralExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLiteralExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLiteralExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLiteralExpressionCore(oldElement, newElement);
//    		UpdatedFromLiteralExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLiteralExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLiteralExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLiteralExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLiteralExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLiteralExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLiteralExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLiteralExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLiteralExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLiteralExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLiteralExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLiteralExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLiteralExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLiteralExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromLiteralExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromMakeRefExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMakeRefExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromMakeRefExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromMakeRefExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromMakeRefExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromMakeRefExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromMakeRefExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromMakeRefExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromMakeRefExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromMakeRefExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromMakeRefExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromMakeRefExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromMakeRefExpressionCore(property, position, parent);
//    		InsertedFromMakeRefExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromMakeRefExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMakeRefExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromMakeRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromMakeRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromMakeRefExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromMakeRefExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromMakeRefExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromMakeRefExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromMakeRefExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromMakeRefExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromMakeRefExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromMakeRefExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromMakeRefExpressionCore(property, parent);
//    		DeletedFromMakeRefExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromMakeRefExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMakeRefExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromMakeRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromMakeRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromMakeRefExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromMakeRefExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromMakeRefExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromMakeRefExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromMakeRefExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromMakeRefExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromMakeRefExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromMakeRefExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromMakeRefExpressionCore(oldElement, newElement);
//    		UpdatedFromMakeRefExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromMakeRefExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMakeRefExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromMakeRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromMakeRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromMakeRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromMakeRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromMakeRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromMakeRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromMakeRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromMakeRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromMakeRefExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromMakeRefExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromMakeRefExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromRefTypeExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefTypeExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromRefTypeExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromRefTypeExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromRefTypeExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromRefTypeExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefTypeExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromRefTypeExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromRefTypeExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromRefTypeExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromRefTypeExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromRefTypeExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromRefTypeExpressionCore(property, position, parent);
//    		InsertedFromRefTypeExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromRefTypeExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefTypeExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromRefTypeExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromRefTypeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromRefTypeExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromRefTypeExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefTypeExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromRefTypeExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromRefTypeExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromRefTypeExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromRefTypeExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromRefTypeExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromRefTypeExpressionCore(property, parent);
//    		DeletedFromRefTypeExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromRefTypeExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefTypeExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromRefTypeExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromRefTypeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromRefTypeExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromRefTypeExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefTypeExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromRefTypeExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromRefTypeExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefTypeExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefTypeExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromRefTypeExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromRefTypeExpressionCore(oldElement, newElement);
//    		UpdatedFromRefTypeExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromRefTypeExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefTypeExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromRefTypeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromRefTypeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromRefTypeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefTypeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromRefTypeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromRefTypeExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromRefTypeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromRefTypeExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromRefTypeExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromRefTypeExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromRefTypeExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromRefValueExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefValueExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromRefValueExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromRefValueExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromRefValueExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromRefValueExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefValueExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromRefValueExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromRefValueExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromRefValueExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "Comma")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromRefValueExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromRefValueExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromRefValueExpressionCore(property, position, parent);
//    		InsertedFromRefValueExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromRefValueExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefValueExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromRefValueExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromRefValueExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromRefValueExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromRefValueExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefValueExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromRefValueExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromRefValueExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromRefValueExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "Comma")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromRefValueExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromRefValueExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromRefValueExpressionCore(property, parent);
//    		DeletedFromRefValueExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromRefValueExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefValueExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromRefValueExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromRefValueExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromRefValueExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromRefValueExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefValueExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromRefValueExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromRefValueExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefValueExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "Comma")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefValueExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromRefValueExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromRefValueExpressionCore(oldElement, newElement);
//    		UpdatedFromRefValueExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromRefValueExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefValueExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromRefValueExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromRefValueExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromRefValueExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromRefValueExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefValueExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromRefValueExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromRefValueExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromRefValueExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "Comma")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromRefValueExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromRefValueExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromRefValueExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromRefValueExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCheckedExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCheckedExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCheckedExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCheckedExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCheckedExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCheckedExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCheckedExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCheckedExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCheckedExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCheckedExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCheckedExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCheckedExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCheckedExpressionCore(property, position, parent);
//    		InsertedFromCheckedExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCheckedExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCheckedExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCheckedExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCheckedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCheckedExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCheckedExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCheckedExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCheckedExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCheckedExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCheckedExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCheckedExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCheckedExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCheckedExpressionCore(property, parent);
//    		DeletedFromCheckedExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCheckedExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCheckedExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCheckedExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCheckedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCheckedExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCheckedExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCheckedExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCheckedExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCheckedExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCheckedExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCheckedExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCheckedExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCheckedExpressionCore(oldElement, newElement);
//    		UpdatedFromCheckedExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCheckedExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCheckedExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCheckedExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCheckedExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCheckedExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCheckedExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCheckedExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCheckedExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCheckedExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCheckedExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCheckedExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCheckedExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCheckedExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromCheckedExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDefaultExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefaultExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDefaultExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDefaultExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDefaultExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDefaultExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefaultExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDefaultExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDefaultExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDefaultExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDefaultExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDefaultExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDefaultExpressionCore(property, position, parent);
//    		InsertedFromDefaultExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDefaultExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefaultExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDefaultExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDefaultExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDefaultExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDefaultExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefaultExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDefaultExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDefaultExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDefaultExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDefaultExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDefaultExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDefaultExpressionCore(property, parent);
//    		DeletedFromDefaultExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDefaultExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefaultExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDefaultExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDefaultExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDefaultExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDefaultExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefaultExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDefaultExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDefaultExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefaultExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefaultExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDefaultExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDefaultExpressionCore(oldElement, newElement);
//    		UpdatedFromDefaultExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDefaultExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefaultExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDefaultExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDefaultExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDefaultExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDefaultExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefaultExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDefaultExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDefaultExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDefaultExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDefaultExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDefaultExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDefaultExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromDefaultExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTypeOfExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeOfExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTypeOfExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTypeOfExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTypeOfExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTypeOfExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTypeOfExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTypeOfExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTypeOfExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeOfExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTypeOfExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTypeOfExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTypeOfExpressionCore(property, position, parent);
//    		InsertedFromTypeOfExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTypeOfExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeOfExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTypeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTypeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTypeOfExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTypeOfExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTypeOfExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTypeOfExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTypeOfExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeOfExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTypeOfExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTypeOfExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTypeOfExpressionCore(property, parent);
//    		DeletedFromTypeOfExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTypeOfExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeOfExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTypeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTypeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTypeOfExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTypeOfExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTypeOfExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTypeOfExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTypeOfExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeOfExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTypeOfExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTypeOfExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTypeOfExpressionCore(oldElement, newElement);
//    		UpdatedFromTypeOfExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTypeOfExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeOfExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTypeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTypeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTypeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTypeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTypeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTypeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTypeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTypeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTypeOfExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTypeOfExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromTypeOfExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSizeOfExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSizeOfExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSizeOfExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSizeOfExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSizeOfExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSizeOfExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSizeOfExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSizeOfExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSizeOfExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSizeOfExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSizeOfExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSizeOfExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSizeOfExpressionCore(property, position, parent);
//    		InsertedFromSizeOfExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSizeOfExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSizeOfExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSizeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSizeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSizeOfExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSizeOfExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSizeOfExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSizeOfExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSizeOfExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSizeOfExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSizeOfExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSizeOfExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSizeOfExpressionCore(property, parent);
//    		DeletedFromSizeOfExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSizeOfExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSizeOfExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSizeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSizeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSizeOfExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSizeOfExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSizeOfExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSizeOfExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSizeOfExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSizeOfExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSizeOfExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSizeOfExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSizeOfExpressionCore(oldElement, newElement);
//    		UpdatedFromSizeOfExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSizeOfExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSizeOfExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSizeOfExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSizeOfExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSizeOfExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSizeOfExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSizeOfExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSizeOfExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSizeOfExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSizeOfExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSizeOfExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSizeOfExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromSizeOfExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInvocationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInvocationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInvocationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInvocationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInvocationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInvocationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInvocationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInvocationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInvocationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInvocationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInvocationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInvocationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInvocationExpressionCore(property, position, parent);
//    		InsertedFromInvocationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInvocationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInvocationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInvocationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInvocationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInvocationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInvocationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInvocationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInvocationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInvocationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInvocationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInvocationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInvocationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInvocationExpressionCore(property, parent);
//    		DeletedFromInvocationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInvocationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInvocationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInvocationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInvocationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInvocationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInvocationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInvocationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInvocationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInvocationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInvocationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInvocationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInvocationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInvocationExpressionCore(oldElement, newElement);
//    		UpdatedFromInvocationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInvocationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInvocationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInvocationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInvocationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInvocationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInvocationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInvocationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInvocationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInvocationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInvocationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInvocationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInvocationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInvocationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromInvocationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromElementAccessExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElementAccessExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromElementAccessExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromElementAccessExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromElementAccessExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromElementAccessExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromElementAccessExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromElementAccessExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromElementAccessExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromElementAccessExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromElementAccessExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromElementAccessExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromElementAccessExpressionCore(property, position, parent);
//    		InsertedFromElementAccessExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromElementAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElementAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromElementAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromElementAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromElementAccessExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromElementAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromElementAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromElementAccessExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromElementAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromElementAccessExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromElementAccessExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromElementAccessExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromElementAccessExpressionCore(property, parent);
//    		DeletedFromElementAccessExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromElementAccessExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElementAccessExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromElementAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromElementAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromElementAccessExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromElementAccessExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromElementAccessExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromElementAccessExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromElementAccessExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromElementAccessExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromElementAccessExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromElementAccessExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromElementAccessExpressionCore(oldElement, newElement);
//    		UpdatedFromElementAccessExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromElementAccessExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElementAccessExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromElementAccessExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromElementAccessExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromElementAccessExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromElementAccessExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromElementAccessExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromElementAccessExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromElementAccessExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromElementAccessExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromElementAccessExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromElementAccessExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromElementAccessExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDeclarationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDeclarationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDeclarationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDeclarationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDeclarationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDeclarationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDeclarationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDeclarationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDeclarationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDeclarationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDeclarationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDeclarationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDeclarationExpressionCore(property, position, parent);
//    		InsertedFromDeclarationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDeclarationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDeclarationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDeclarationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDeclarationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDeclarationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDeclarationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDeclarationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDeclarationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDeclarationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDeclarationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDeclarationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDeclarationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDeclarationExpressionCore(property, parent);
//    		DeletedFromDeclarationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDeclarationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDeclarationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDeclarationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDeclarationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDeclarationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDeclarationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDeclarationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDeclarationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDeclarationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDeclarationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDeclarationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDeclarationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDeclarationExpressionCore(oldElement, newElement);
//    		UpdatedFromDeclarationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDeclarationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDeclarationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDeclarationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDeclarationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDeclarationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDeclarationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDeclarationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDeclarationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDeclarationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDeclarationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDeclarationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDeclarationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromDeclarationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCastExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCastExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCastExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCastExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCastExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCastExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCastExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCastExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCastExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCastExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCastExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCastExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCastExpressionCore(property, position, parent);
//    		InsertedFromCastExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCastExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCastExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCastExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCastExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCastExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCastExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCastExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCastExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCastExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCastExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCastExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCastExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCastExpressionCore(property, parent);
//    		DeletedFromCastExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCastExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCastExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCastExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCastExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCastExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCastExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCastExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCastExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCastExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCastExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCastExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCastExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCastExpressionCore(oldElement, newElement);
//    		UpdatedFromCastExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCastExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCastExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCastExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCastExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCastExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCastExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCastExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCastExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCastExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCastExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCastExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCastExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCastExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromCastExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromRefExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromRefExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromRefExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromRefExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromRefExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromRefExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromRefExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromRefExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromRefExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromRefExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromRefExpressionCore(property, position, parent);
//    		InsertedFromRefExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromRefExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromRefExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromRefExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromRefExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromRefExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromRefExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromRefExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromRefExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromRefExpressionCore(property, parent);
//    		DeletedFromRefExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromRefExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromRefExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromRefExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromRefExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromRefExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromRefExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromRefExpressionCore(oldElement, newElement);
//    		UpdatedFromRefExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromRefExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromRefExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromRefExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromRefExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromRefExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromRefExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromRefExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromRefExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromRefExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromRefExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromRefExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromRefExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInitializerExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInitializerExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInitializerExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInitializerExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInitializerExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInitializerExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInitializerExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInitializerExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInitializerExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInitializerExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInitializerExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInitializerExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInitializerExpressionCore(property, position, parent);
//    		InsertedFromInitializerExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInitializerExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInitializerExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInitializerExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInitializerExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInitializerExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInitializerExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInitializerExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInitializerExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInitializerExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInitializerExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInitializerExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInitializerExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInitializerExpressionCore(property, parent);
//    		DeletedFromInitializerExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInitializerExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInitializerExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInitializerExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInitializerExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInitializerExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInitializerExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInitializerExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInitializerExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInitializerExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInitializerExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInitializerExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInitializerExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInitializerExpressionCore(oldElement, newElement);
//    		UpdatedFromInitializerExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInitializerExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInitializerExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInitializerExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInitializerExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInitializerExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInitializerExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInitializerExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInitializerExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInitializerExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInitializerExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInitializerExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInitializerExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInitializerExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromInitializerExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromObjectCreationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromObjectCreationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromObjectCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromObjectCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromObjectCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromObjectCreationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromObjectCreationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromObjectCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromObjectCreationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromObjectCreationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromObjectCreationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromObjectCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromObjectCreationExpressionCore(property, position, parent);
//    		InsertedFromObjectCreationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromObjectCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromObjectCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromObjectCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromObjectCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromObjectCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromObjectCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromObjectCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromObjectCreationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromObjectCreationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromObjectCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromObjectCreationExpressionCore(property, parent);
//    		DeletedFromObjectCreationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromObjectCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromObjectCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromObjectCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromObjectCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromObjectCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromObjectCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromObjectCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromObjectCreationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromObjectCreationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromObjectCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromObjectCreationExpressionCore(oldElement, newElement);
//    		UpdatedFromObjectCreationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromObjectCreationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromObjectCreationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromObjectCreationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromObjectCreationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAnonymousObjectCreationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousObjectCreationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAnonymousObjectCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAnonymousObjectCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousObjectCreationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAnonymousObjectCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAnonymousObjectCreationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousObjectCreationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousObjectCreationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAnonymousObjectCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAnonymousObjectCreationExpressionCore(property, position, parent);
//    		InsertedFromAnonymousObjectCreationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAnonymousObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAnonymousObjectCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAnonymousObjectCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousObjectCreationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousObjectCreationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAnonymousObjectCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAnonymousObjectCreationExpressionCore(property, parent);
//    		DeletedFromAnonymousObjectCreationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAnonymousObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAnonymousObjectCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAnonymousObjectCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAnonymousObjectCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousObjectCreationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousObjectCreationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAnonymousObjectCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAnonymousObjectCreationExpressionCore(oldElement, newElement);
//    		UpdatedFromAnonymousObjectCreationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAnonymousObjectCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousObjectCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAnonymousObjectCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAnonymousObjectCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousObjectCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousObjectCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAnonymousObjectCreationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAnonymousObjectCreationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromAnonymousObjectCreationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArrayCreationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayCreationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArrayCreationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayCreationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayCreationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArrayCreationExpressionCore(property, position, parent);
//    		InsertedFromArrayCreationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayCreationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayCreationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArrayCreationExpressionCore(property, parent);
//    		DeletedFromArrayCreationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayCreationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayCreationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArrayCreationExpressionCore(oldElement, newElement);
//    		UpdatedFromArrayCreationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArrayCreationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArrayCreationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArrayCreationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromArrayCreationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromImplicitArrayCreationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromImplicitArrayCreationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromImplicitArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromImplicitArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromImplicitArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromImplicitArrayCreationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromImplicitArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromImplicitArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromImplicitArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromImplicitArrayCreationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromImplicitArrayCreationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromImplicitArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromImplicitArrayCreationExpressionCore(property, position, parent);
//    		InsertedFromImplicitArrayCreationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromImplicitArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromImplicitArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromImplicitArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromImplicitArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromImplicitArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromImplicitArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromImplicitArrayCreationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromImplicitArrayCreationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromImplicitArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromImplicitArrayCreationExpressionCore(property, parent);
//    		DeletedFromImplicitArrayCreationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromImplicitArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromImplicitArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromImplicitArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromImplicitArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromImplicitArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromImplicitArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromImplicitArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromImplicitArrayCreationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromImplicitArrayCreationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromImplicitArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromImplicitArrayCreationExpressionCore(oldElement, newElement);
//    		UpdatedFromImplicitArrayCreationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromImplicitArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromImplicitArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromImplicitArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromImplicitArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromImplicitArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "NewKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromImplicitArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromImplicitArrayCreationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromImplicitArrayCreationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromImplicitArrayCreationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromStackAllocArrayCreationExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromStackAllocArrayCreationExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromStackAllocArrayCreationExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromStackAllocArrayCreationExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromStackAllocArrayCreationExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromStackAllocArrayCreationExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromStackAllocArrayCreationExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromStackAllocArrayCreationExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromStackAllocArrayCreationExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromStackAllocArrayCreationExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromStackAllocArrayCreationExpressionCore(property, position, parent);
//    		InsertedFromStackAllocArrayCreationExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromStackAllocArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromStackAllocArrayCreationExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromStackAllocArrayCreationExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromStackAllocArrayCreationExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromStackAllocArrayCreationExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromStackAllocArrayCreationExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromStackAllocArrayCreationExpressionCore(property, parent);
//    		DeletedFromStackAllocArrayCreationExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromStackAllocArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromStackAllocArrayCreationExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromStackAllocArrayCreationExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromStackAllocArrayCreationExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromStackAllocArrayCreationExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromStackAllocArrayCreationExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromStackAllocArrayCreationExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromStackAllocArrayCreationExpressionCore(oldElement, newElement);
//    		UpdatedFromStackAllocArrayCreationExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromStackAllocArrayCreationExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromStackAllocArrayCreationExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromStackAllocArrayCreationExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromStackAllocArrayCreationExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromStackAllocArrayCreationExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StackAllocKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromStackAllocArrayCreationExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromStackAllocArrayCreationExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromStackAllocArrayCreationExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromStackAllocArrayCreationExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromQueryExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromQueryExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromQueryExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromQueryExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromQueryExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQueryExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromQueryExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromQueryExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromQueryExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromQueryExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromQueryExpressionCore(property, position, parent);
//    		InsertedFromQueryExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromQueryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromQueryExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromQueryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromQueryExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromQueryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQueryExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromQueryExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromQueryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromQueryExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromQueryExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromQueryExpressionCore(property, parent);
//    		DeletedFromQueryExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromQueryExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromQueryExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromQueryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromQueryExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromQueryExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQueryExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromQueryExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromQueryExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromQueryExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromQueryExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromQueryExpressionCore(oldElement, newElement);
//    		UpdatedFromQueryExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromQueryExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromQueryExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromQueryExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromQueryExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromQueryExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQueryExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromQueryExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromQueryExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromQueryExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromQueryExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromQueryExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromQueryExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromQueryExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOmittedArraySizeExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOmittedArraySizeExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOmittedArraySizeExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOmittedArraySizeExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOmittedArraySizeExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOmittedArraySizeExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOmittedArraySizeExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOmittedArraySizeExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOmittedArraySizeExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOmittedArraySizeExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOmittedArraySizeExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOmittedArraySizeExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOmittedArraySizeExpressionCore(property, position, parent);
//    		InsertedFromOmittedArraySizeExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOmittedArraySizeExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOmittedArraySizeExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOmittedArraySizeExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOmittedArraySizeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOmittedArraySizeExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOmittedArraySizeExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOmittedArraySizeExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOmittedArraySizeExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOmittedArraySizeExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOmittedArraySizeExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOmittedArraySizeExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOmittedArraySizeExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOmittedArraySizeExpressionCore(property, parent);
//    		DeletedFromOmittedArraySizeExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOmittedArraySizeExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOmittedArraySizeExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOmittedArraySizeExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOmittedArraySizeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOmittedArraySizeExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOmittedArraySizeExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOmittedArraySizeExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOmittedArraySizeExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOmittedArraySizeExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOmittedArraySizeExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOmittedArraySizeExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOmittedArraySizeExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOmittedArraySizeExpressionCore(oldElement, newElement);
//    		UpdatedFromOmittedArraySizeExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOmittedArraySizeExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOmittedArraySizeExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOmittedArraySizeExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOmittedArraySizeExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOmittedArraySizeExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOmittedArraySizeExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedArraySizeExpressionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOmittedArraySizeExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOmittedArraySizeExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOmittedArraySizeExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromOmittedArraySizeExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterpolatedStringExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolatedStringExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterpolatedStringExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterpolatedStringExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterpolatedStringExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterpolatedStringExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolatedStringExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterpolatedStringExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterpolatedStringExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolatedStringExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StringStartToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StringEndToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolatedStringExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterpolatedStringExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterpolatedStringExpressionCore(property, position, parent);
//    		InsertedFromInterpolatedStringExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterpolatedStringExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolatedStringExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterpolatedStringExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterpolatedStringExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterpolatedStringExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterpolatedStringExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolatedStringExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterpolatedStringExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterpolatedStringExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolatedStringExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StringStartToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StringEndToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolatedStringExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterpolatedStringExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterpolatedStringExpressionCore(property, parent);
//    		DeletedFromInterpolatedStringExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterpolatedStringExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolatedStringExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterpolatedStringExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterpolatedStringExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterpolatedStringExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterpolatedStringExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolatedStringExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterpolatedStringExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterpolatedStringExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolatedStringExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StringStartToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StringEndToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolatedStringExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterpolatedStringExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterpolatedStringExpressionCore(oldElement, newElement);
//    		UpdatedFromInterpolatedStringExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterpolatedStringExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterpolatedStringExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolatedStringExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterpolatedStringExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterpolatedStringExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolatedStringExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "StringStartToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "StringEndToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolatedStringExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterpolatedStringExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterpolatedStringExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromInterpolatedStringExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIsPatternExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIsPatternExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIsPatternExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIsPatternExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIsPatternExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIsPatternExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIsPatternExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIsPatternExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIsPatternExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIsPatternExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IsKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIsPatternExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIsPatternExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIsPatternExpressionCore(property, position, parent);
//    		InsertedFromIsPatternExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIsPatternExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIsPatternExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIsPatternExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIsPatternExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIsPatternExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIsPatternExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIsPatternExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIsPatternExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIsPatternExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIsPatternExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIsPatternExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIsPatternExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIsPatternExpressionCore(property, parent);
//    		DeletedFromIsPatternExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIsPatternExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIsPatternExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIsPatternExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIsPatternExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIsPatternExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIsPatternExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIsPatternExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIsPatternExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIsPatternExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIsPatternExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIsPatternExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIsPatternExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIsPatternExpressionCore(oldElement, newElement);
//    		UpdatedFromIsPatternExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIsPatternExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIsPatternExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIsPatternExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIsPatternExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIsPatternExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIsPatternExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIsPatternExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIsPatternExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIsPatternExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIsPatternExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIsPatternExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIsPatternExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromIsPatternExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromThrowExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThrowExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromThrowExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromThrowExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromThrowExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromThrowExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThrowExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromThrowExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromThrowExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromThrowExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromThrowExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromThrowExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromThrowExpressionCore(property, position, parent);
//    		InsertedFromThrowExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromThrowExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThrowExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromThrowExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromThrowExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromThrowExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromThrowExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThrowExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromThrowExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromThrowExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromThrowExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromThrowExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromThrowExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromThrowExpressionCore(property, parent);
//    		DeletedFromThrowExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromThrowExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThrowExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromThrowExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromThrowExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromThrowExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromThrowExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThrowExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromThrowExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromThrowExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromThrowExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromThrowExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromThrowExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromThrowExpressionCore(oldElement, newElement);
//    		UpdatedFromThrowExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromThrowExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThrowExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromThrowExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromThrowExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromThrowExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromThrowExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThrowExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromThrowExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromThrowExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromThrowExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromThrowExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromThrowExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromThrowExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromThrowExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPredefinedType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPredefinedType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPredefinedTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPredefinedType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPredefinedTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPredefinedTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPredefinedTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPredefinedTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPredefinedType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPredefinedTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPredefinedType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPredefinedTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPredefinedTypeCore(property, position, parent);
//    		InsertedFromPredefinedTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPredefinedType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPredefinedType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPredefinedTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPredefinedType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPredefinedTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPredefinedTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPredefinedTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPredefinedTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPredefinedType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPredefinedTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPredefinedType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPredefinedTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPredefinedTypeCore(property, parent);
//    		DeletedFromPredefinedTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPredefinedType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPredefinedType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPredefinedTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPredefinedType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPredefinedTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPredefinedTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPredefinedTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPredefinedTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPredefinedType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPredefinedTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPredefinedType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPredefinedTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPredefinedTypeCore(oldElement, newElement);
//    		UpdatedFromPredefinedTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPredefinedType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPredefinedType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPredefinedTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPredefinedType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPredefinedTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPredefinedTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPredefinedTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPredefinedTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPredefinedType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPredefinedTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPredefinedType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPredefinedTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPredefinedTypeCore(property, oldPArent, position, newParent);
//    		MovedFromPredefinedTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArrayType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArrayTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArrayType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArrayTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArrayTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArrayTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArrayTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArrayType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArrayType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArrayTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArrayTypeCore(property, position, parent);
//    		InsertedFromArrayTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArrayType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArrayTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArrayType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArrayTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArrayTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArrayTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArrayTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArrayType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArrayType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArrayTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArrayTypeCore(property, parent);
//    		DeletedFromArrayTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArrayType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArrayTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArrayType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArrayTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArrayTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArrayTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArrayTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArrayType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArrayType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArrayTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArrayTypeCore(oldElement, newElement);
//    		UpdatedFromArrayTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArrayType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArrayTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArrayType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArrayTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArrayTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArrayTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArrayTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArrayType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArrayTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArrayType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArrayTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArrayTypeCore(property, oldPArent, position, newParent);
//    		MovedFromArrayTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromPointerType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPointerType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromPointerTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromPointerType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromPointerTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromPointerTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromPointerTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromPointerTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromPointerType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromPointerTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsteriskToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromPointerType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromPointerTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromPointerTypeCore(property, position, parent);
//    		InsertedFromPointerTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromPointerType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPointerType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromPointerTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromPointerType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromPointerTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromPointerTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromPointerTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromPointerTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromPointerType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromPointerTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsteriskToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromPointerType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromPointerTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromPointerTypeCore(property, parent);
//    		DeletedFromPointerTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromPointerType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPointerType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromPointerTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromPointerType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromPointerTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromPointerTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromPointerTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromPointerTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromPointerType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromPointerTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsteriskToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromPointerType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromPointerTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromPointerTypeCore(oldElement, newElement);
//    		UpdatedFromPointerTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromPointerType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPointerType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromPointerTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromPointerType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromPointerTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromPointerTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromPointerTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromPointerTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromPointerType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromPointerTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsteriskToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromPointerType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromPointerTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromPointerTypeCore(property, oldPArent, position, newParent);
//    		MovedFromPointerTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromNullableType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNullableType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromNullableTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromNullableType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromNullableTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromNullableTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromNullableTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromNullableTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromNullableType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromNullableTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromNullableType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromNullableTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromNullableTypeCore(property, position, parent);
//    		InsertedFromNullableTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromNullableType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNullableType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromNullableTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromNullableType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromNullableTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromNullableTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromNullableTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromNullableTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromNullableType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromNullableTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromNullableType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromNullableTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromNullableTypeCore(property, parent);
//    		DeletedFromNullableTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromNullableType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNullableType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromNullableTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromNullableType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromNullableTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromNullableTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromNullableTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromNullableTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromNullableType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromNullableTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromNullableType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromNullableTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromNullableTypeCore(oldElement, newElement);
//    		UpdatedFromNullableTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromNullableType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNullableType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromNullableTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromNullableType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromNullableTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromNullableTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromNullableTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromNullableTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromNullableType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromNullableTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "QuestionToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromNullableType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromNullableTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromNullableTypeCore(property, oldPArent, position, newParent);
//    		MovedFromNullableTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTupleType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTupleTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTupleType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTupleTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTupleTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTupleTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTupleTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTupleType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTupleType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTupleTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTupleTypeCore(property, position, parent);
//    		InsertedFromTupleTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTupleType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTupleTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTupleType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTupleTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTupleTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTupleTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTupleTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTupleType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTupleType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTupleTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTupleTypeCore(property, parent);
//    		DeletedFromTupleTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTupleType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTupleTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTupleType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTupleTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTupleTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTupleTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTupleTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTupleType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTupleType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTupleTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTupleTypeCore(oldElement, newElement);
//    		UpdatedFromTupleTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTupleType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTupleTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTupleType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTupleTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTupleTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTupleTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTupleTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTupleType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTupleTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTupleType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTupleTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTupleTypeCore(property, oldPArent, position, newParent);
//    		MovedFromTupleTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOmittedTypeArgument(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOmittedTypeArgument(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOmittedTypeArgumentCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOmittedTypeArgument(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOmittedTypeArgumentBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOmittedTypeArgumentCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOmittedTypeArgumentCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOmittedTypeArgumentAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOmittedTypeArgument(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOmittedTypeArgumentCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOmittedTypeArgument(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOmittedTypeArgumentBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOmittedTypeArgumentCore(property, position, parent);
//    		InsertedFromOmittedTypeArgumentAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOmittedTypeArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOmittedTypeArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOmittedTypeArgumentCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOmittedTypeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOmittedTypeArgumentBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOmittedTypeArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOmittedTypeArgumentCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOmittedTypeArgumentAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOmittedTypeArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOmittedTypeArgumentCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOmittedTypeArgument(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOmittedTypeArgumentBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOmittedTypeArgumentCore(property, parent);
//    		DeletedFromOmittedTypeArgumentAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOmittedTypeArgument(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOmittedTypeArgument(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOmittedTypeArgumentCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOmittedTypeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOmittedTypeArgumentBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOmittedTypeArgumentCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOmittedTypeArgumentCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOmittedTypeArgumentAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOmittedTypeArgument(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOmittedTypeArgumentCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOmittedTypeArgument(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOmittedTypeArgumentBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOmittedTypeArgumentCore(oldElement, newElement);
//    		UpdatedFromOmittedTypeArgumentAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOmittedTypeArgument(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOmittedTypeArgument(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOmittedTypeArgumentBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOmittedTypeArgumentCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOmittedTypeArgumentAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOmittedTypeArgument(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOmittedTypeArgumentCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OmittedTypeArgumentToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOmittedTypeArgument(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOmittedTypeArgumentBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOmittedTypeArgumentCore(property, oldPArent, position, newParent);
//    		MovedFromOmittedTypeArgumentAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromRefType(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefType(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromRefTypeCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromRefType(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromRefTypeBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromRefTypeCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromRefTypeCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromRefTypeAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromRefType(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromRefTypeCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromRefType(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromRefTypeBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromRefTypeCore(property, position, parent);
//    		InsertedFromRefTypeAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromRefType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromRefTypeCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromRefType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromRefTypeBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromRefTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromRefTypeCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromRefTypeAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromRefType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromRefTypeCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromRefType(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromRefTypeBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromRefTypeCore(property, parent);
//    		DeletedFromRefTypeAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromRefType(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefType(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromRefTypeCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromRefType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromRefTypeBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromRefTypeCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromRefTypeCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromRefTypeAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromRefType(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefTypeCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromRefType(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromRefTypeBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromRefTypeCore(oldElement, newElement);
//    		UpdatedFromRefTypeAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromRefType(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefType(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromRefTypeCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromRefType(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromRefTypeBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromRefTypeCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromRefTypeCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromRefTypeAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromRefType(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromRefTypeCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "RefKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReadOnlyKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromRefType(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromRefTypeBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromRefTypeCore(property, oldPArent, position, newParent);
//    		MovedFromRefTypeAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromQualifiedName(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQualifiedName(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromQualifiedNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromQualifiedName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromQualifiedNameBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromQualifiedNameCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromQualifiedNameCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromQualifiedNameAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromQualifiedName(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromQualifiedNameCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromQualifiedName(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromQualifiedNameBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromQualifiedNameCore(property, position, parent);
//    		InsertedFromQualifiedNameAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromQualifiedName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQualifiedName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromQualifiedNameBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromQualifiedNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromQualifiedNameCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromQualifiedNameAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromQualifiedName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromQualifiedNameCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromQualifiedName(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromQualifiedNameBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromQualifiedNameCore(property, parent);
//    		DeletedFromQualifiedNameAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromQualifiedName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQualifiedName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromQualifiedNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromQualifiedNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromQualifiedNameCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromQualifiedNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromQualifiedName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromQualifiedNameCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromQualifiedName(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromQualifiedNameBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromQualifiedNameCore(oldElement, newElement);
//    		UpdatedFromQualifiedNameAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromQualifiedName(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQualifiedName(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromQualifiedNameCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DotToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromQualifiedNameBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromQualifiedNameCore(property, oldPArent, position, newParent);
//    		MovedFromQualifiedNameAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAliasQualifiedName(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAliasQualifiedName(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAliasQualifiedNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAliasQualifiedName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAliasQualifiedNameBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAliasQualifiedNameCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAliasQualifiedNameCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAliasQualifiedNameAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAliasQualifiedName(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAliasQualifiedNameCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAliasQualifiedName(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAliasQualifiedNameBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAliasQualifiedNameCore(property, position, parent);
//    		InsertedFromAliasQualifiedNameAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAliasQualifiedName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAliasQualifiedName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAliasQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAliasQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAliasQualifiedNameBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAliasQualifiedNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAliasQualifiedNameCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAliasQualifiedNameAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAliasQualifiedName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAliasQualifiedNameCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAliasQualifiedName(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAliasQualifiedNameBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAliasQualifiedNameCore(property, parent);
//    		DeletedFromAliasQualifiedNameAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAliasQualifiedName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAliasQualifiedName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAliasQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAliasQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAliasQualifiedNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAliasQualifiedNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAliasQualifiedNameCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAliasQualifiedNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAliasQualifiedName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAliasQualifiedNameCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAliasQualifiedName(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAliasQualifiedNameBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAliasQualifiedNameCore(oldElement, newElement);
//    		UpdatedFromAliasQualifiedNameAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAliasQualifiedName(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAliasQualifiedName(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAliasQualifiedNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAliasQualifiedName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAliasQualifiedNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAliasQualifiedNameCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAliasQualifiedNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAliasQualifiedName(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAliasQualifiedNameCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAliasQualifiedName(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAliasQualifiedNameBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAliasQualifiedNameCore(property, oldPArent, position, newParent);
//    		MovedFromAliasQualifiedNameAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIdentifierName(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIdentifierName(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIdentifierNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIdentifierName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIdentifierNameBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIdentifierNameCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIdentifierNameCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIdentifierNameAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIdentifierName(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIdentifierNameCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIdentifierName(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIdentifierNameBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIdentifierNameCore(property, position, parent);
//    		InsertedFromIdentifierNameAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIdentifierName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIdentifierName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIdentifierNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIdentifierName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIdentifierNameBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIdentifierNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIdentifierNameCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIdentifierNameAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIdentifierName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIdentifierNameCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIdentifierName(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIdentifierNameBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIdentifierNameCore(property, parent);
//    		DeletedFromIdentifierNameAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIdentifierName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIdentifierName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIdentifierNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIdentifierName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIdentifierNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIdentifierNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIdentifierNameCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIdentifierNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIdentifierName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIdentifierNameCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIdentifierName(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIdentifierNameBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIdentifierNameCore(oldElement, newElement);
//    		UpdatedFromIdentifierNameAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIdentifierName(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIdentifierName(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIdentifierNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIdentifierName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIdentifierNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIdentifierNameCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIdentifierNameCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIdentifierNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIdentifierName(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIdentifierNameCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIdentifierName(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIdentifierNameBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIdentifierNameCore(property, oldPArent, position, newParent);
//    		MovedFromIdentifierNameAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromGenericName(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGenericName(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromGenericNameCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromGenericName(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromGenericNameBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromGenericNameCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGenericNameCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromGenericNameAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromGenericName(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromGenericNameCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromGenericName(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromGenericNameBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromGenericNameCore(property, position, parent);
//    		InsertedFromGenericNameAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromGenericName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGenericName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromGenericNameCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromGenericName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromGenericNameBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromGenericNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGenericNameCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromGenericNameAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromGenericName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromGenericNameCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromGenericName(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromGenericNameBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromGenericNameCore(property, parent);
//    		DeletedFromGenericNameAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromGenericName(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGenericName(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromGenericNameCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromGenericName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromGenericNameBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromGenericNameCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGenericNameCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromGenericNameAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromGenericName(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromGenericNameCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromGenericName(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromGenericNameBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromGenericNameCore(oldElement, newElement);
//    		UpdatedFromGenericNameAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromGenericName(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGenericName(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromGenericNameCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromGenericName(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromGenericNameBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromGenericNameCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGenericNameCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromGenericNameAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromGenericName(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromGenericNameCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromGenericName(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromGenericNameBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromGenericNameCore(property, oldPArent, position, newParent);
//    		MovedFromGenericNameAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromThisExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThisExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromThisExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromThisExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromThisExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromThisExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThisExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromThisExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromThisExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromThisExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromThisExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromThisExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromThisExpressionCore(property, position, parent);
//    		InsertedFromThisExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromThisExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThisExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromThisExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromThisExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromThisExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromThisExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThisExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromThisExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromThisExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromThisExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromThisExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromThisExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromThisExpressionCore(property, parent);
//    		DeletedFromThisExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromThisExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThisExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromThisExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromThisExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromThisExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromThisExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThisExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromThisExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromThisExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromThisExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromThisExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromThisExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromThisExpressionCore(oldElement, newElement);
//    		UpdatedFromThisExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromThisExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThisExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromThisExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromThisExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromThisExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromThisExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThisExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromThisExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromThisExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromThisExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromThisExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromThisExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromThisExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromThisExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBaseExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBaseExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBaseExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBaseExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBaseExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBaseExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBaseExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBaseExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBaseExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBaseExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBaseExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBaseExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBaseExpressionCore(property, position, parent);
//    		InsertedFromBaseExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBaseExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBaseExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBaseExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBaseExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBaseExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBaseExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBaseExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBaseExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBaseExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBaseExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBaseExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBaseExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBaseExpressionCore(property, parent);
//    		DeletedFromBaseExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBaseExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBaseExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBaseExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBaseExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBaseExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBaseExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBaseExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBaseExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBaseExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBaseExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBaseExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBaseExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBaseExpressionCore(oldElement, newElement);
//    		UpdatedFromBaseExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBaseExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBaseExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBaseExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBaseExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBaseExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBaseExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBaseExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBaseExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBaseExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBaseExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Token")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBaseExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBaseExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBaseExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromBaseExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromAnonymousMethodExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousMethodExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromAnonymousMethodExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromAnonymousMethodExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromAnonymousMethodExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromAnonymousMethodExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromAnonymousMethodExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromAnonymousMethodExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromAnonymousMethodExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousMethodExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromAnonymousMethodExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromAnonymousMethodExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromAnonymousMethodExpressionCore(property, position, parent);
//    		InsertedFromAnonymousMethodExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromAnonymousMethodExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousMethodExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromAnonymousMethodExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromAnonymousMethodExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromAnonymousMethodExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromAnonymousMethodExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromAnonymousMethodExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromAnonymousMethodExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromAnonymousMethodExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousMethodExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromAnonymousMethodExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromAnonymousMethodExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromAnonymousMethodExpressionCore(property, parent);
//    		DeletedFromAnonymousMethodExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromAnonymousMethodExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousMethodExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromAnonymousMethodExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromAnonymousMethodExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromAnonymousMethodExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromAnonymousMethodExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromAnonymousMethodExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromAnonymousMethodExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromAnonymousMethodExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousMethodExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromAnonymousMethodExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromAnonymousMethodExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromAnonymousMethodExpressionCore(oldElement, newElement);
//    		UpdatedFromAnonymousMethodExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromAnonymousMethodExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromAnonymousMethodExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromAnonymousMethodExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromAnonymousMethodExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromAnonymousMethodExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousMethodExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "DelegateKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromAnonymousMethodExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromAnonymousMethodExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromAnonymousMethodExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromAnonymousMethodExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSimpleLambdaExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSimpleLambdaExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSimpleLambdaExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSimpleLambdaExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSimpleLambdaExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSimpleLambdaExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSimpleLambdaExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSimpleLambdaExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSimpleLambdaExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSimpleLambdaExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSimpleLambdaExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSimpleLambdaExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSimpleLambdaExpressionCore(property, position, parent);
//    		InsertedFromSimpleLambdaExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSimpleLambdaExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSimpleLambdaExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSimpleLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSimpleLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSimpleLambdaExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSimpleLambdaExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSimpleLambdaExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSimpleLambdaExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSimpleLambdaExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSimpleLambdaExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSimpleLambdaExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSimpleLambdaExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSimpleLambdaExpressionCore(property, parent);
//    		DeletedFromSimpleLambdaExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSimpleLambdaExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSimpleLambdaExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSimpleLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSimpleLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSimpleLambdaExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSimpleLambdaExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSimpleLambdaExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSimpleLambdaExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSimpleLambdaExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSimpleLambdaExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSimpleLambdaExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSimpleLambdaExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSimpleLambdaExpressionCore(oldElement, newElement);
//    		UpdatedFromSimpleLambdaExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSimpleLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSimpleLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSimpleLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSimpleLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSimpleLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSimpleLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSimpleLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSimpleLambdaExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSimpleLambdaExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromSimpleLambdaExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromParenthesizedLambdaExpression(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedLambdaExpression(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromParenthesizedLambdaExpressionCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromParenthesizedLambdaExpression(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromParenthesizedLambdaExpressionBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromParenthesizedLambdaExpressionCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedLambdaExpressionCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromParenthesizedLambdaExpressionAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromParenthesizedLambdaExpression(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedLambdaExpressionCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedLambdaExpression(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromParenthesizedLambdaExpressionBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromParenthesizedLambdaExpressionCore(property, position, parent);
//    		InsertedFromParenthesizedLambdaExpressionAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromParenthesizedLambdaExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedLambdaExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromParenthesizedLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromParenthesizedLambdaExpressionBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromParenthesizedLambdaExpressionAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromParenthesizedLambdaExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedLambdaExpressionCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedLambdaExpression(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromParenthesizedLambdaExpressionBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromParenthesizedLambdaExpressionCore(property, parent);
//    		DeletedFromParenthesizedLambdaExpressionAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromParenthesizedLambdaExpression(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedLambdaExpression(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromParenthesizedLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromParenthesizedLambdaExpressionBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedLambdaExpressionCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromParenthesizedLambdaExpressionAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromParenthesizedLambdaExpression(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedLambdaExpressionCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedLambdaExpression(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromParenthesizedLambdaExpressionBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromParenthesizedLambdaExpressionCore(oldElement, newElement);
//    		UpdatedFromParenthesizedLambdaExpressionAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromParenthesizedLambdaExpressionBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedLambdaExpressionCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromParenthesizedLambdaExpressionAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromParenthesizedLambdaExpression(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedLambdaExpressionCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "AsyncKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ArrowToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedLambdaExpression(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromParenthesizedLambdaExpressionBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromParenthesizedLambdaExpressionCore(property, oldPArent, position, newParent);
//    		MovedFromParenthesizedLambdaExpressionAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromArgumentList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArgumentList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromArgumentListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromArgumentListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromArgumentList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromArgumentListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromArgumentList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromArgumentListCore(property, position, parent);
//    		InsertedFromArgumentListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromArgumentListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromArgumentListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromArgumentListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromArgumentListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromArgumentList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromArgumentListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromArgumentListCore(property, parent);
//    		DeletedFromArgumentListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromArgumentListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromArgumentListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromArgumentList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromArgumentListCore(oldElement, newElement);
//    		UpdatedFromArgumentListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromArgumentList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArgumentList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromArgumentListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromArgumentListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromArgumentListCore(property, oldPArent, position, newParent);
//    		MovedFromArgumentListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBracketedArgumentList(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBracketedArgumentList(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBracketedArgumentListCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBracketedArgumentList(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBracketedArgumentListBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBracketedArgumentListCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBracketedArgumentListCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBracketedArgumentListAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBracketedArgumentList(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBracketedArgumentListCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBracketedArgumentList(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBracketedArgumentListBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBracketedArgumentListCore(property, position, parent);
//    		InsertedFromBracketedArgumentListAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBracketedArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBracketedArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBracketedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBracketedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBracketedArgumentListBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBracketedArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBracketedArgumentListCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBracketedArgumentListAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBracketedArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBracketedArgumentListCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBracketedArgumentList(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBracketedArgumentListBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBracketedArgumentListCore(property, parent);
//    		DeletedFromBracketedArgumentListAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBracketedArgumentList(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBracketedArgumentList(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBracketedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBracketedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBracketedArgumentListBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBracketedArgumentListCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBracketedArgumentListCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBracketedArgumentListAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBracketedArgumentList(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBracketedArgumentListCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBracketedArgumentList(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBracketedArgumentListBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBracketedArgumentListCore(oldElement, newElement);
//    		UpdatedFromBracketedArgumentListAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBracketedArgumentList(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBracketedArgumentList(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBracketedArgumentListCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBracketedArgumentList(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBracketedArgumentListBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBracketedArgumentListCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBracketedArgumentListAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBracketedArgumentList(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBracketedArgumentListCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBracketToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBracketedArgumentList(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBracketedArgumentListBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBracketedArgumentListCore(property, oldPArent, position, newParent);
//    		MovedFromBracketedArgumentListAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromFromClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFromClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromFromClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromFromClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromFromClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromFromClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFromClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromFromClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromFromClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromFromClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FromKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromFromClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromFromClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromFromClauseCore(property, position, parent);
//    		InsertedFromFromClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromFromClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFromClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromFromClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromFromClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromFromClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromFromClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFromClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromFromClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromFromClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromFromClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FromKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromFromClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromFromClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromFromClauseCore(property, parent);
//    		DeletedFromFromClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromFromClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFromClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromFromClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromFromClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromFromClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromFromClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFromClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromFromClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromFromClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromFromClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FromKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromFromClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromFromClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromFromClauseCore(oldElement, newElement);
//    		UpdatedFromFromClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromFromClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFromClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromFromClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromFromClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromFromClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromFromClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFromClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromFromClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromFromClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromFromClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FromKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromFromClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromFromClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromFromClauseCore(property, oldPArent, position, newParent);
//    		MovedFromFromClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLetClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLetClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLetClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLetClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLetClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLetClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLetClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLetClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLetClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLetClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LetKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLetClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLetClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLetClauseCore(property, position, parent);
//    		InsertedFromLetClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLetClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLetClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLetClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLetClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLetClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLetClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLetClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLetClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLetClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLetClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LetKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLetClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLetClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLetClauseCore(property, parent);
//    		DeletedFromLetClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLetClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLetClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLetClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLetClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLetClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLetClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLetClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLetClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLetClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLetClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LetKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLetClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLetClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLetClauseCore(oldElement, newElement);
//    		UpdatedFromLetClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLetClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLetClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLetClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLetClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLetClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLetClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLetClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLetClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLetClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLetClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LetKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLetClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLetClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLetClauseCore(property, oldPArent, position, newParent);
//    		MovedFromLetClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromJoinClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromJoinClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromJoinClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromJoinClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromJoinClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromJoinClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromJoinClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromJoinClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromJoinClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromJoinClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "JoinKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OnKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromJoinClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromJoinClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromJoinClauseCore(property, position, parent);
//    		InsertedFromJoinClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromJoinClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromJoinClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromJoinClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromJoinClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromJoinClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromJoinClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromJoinClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromJoinClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromJoinClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromJoinClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "JoinKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromJoinClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromJoinClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromJoinClauseCore(property, parent);
//    		DeletedFromJoinClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromJoinClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromJoinClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromJoinClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromJoinClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromJoinClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromJoinClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromJoinClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromJoinClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromJoinClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromJoinClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "JoinKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromJoinClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromJoinClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromJoinClauseCore(oldElement, newElement);
//    		UpdatedFromJoinClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromJoinClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromJoinClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromJoinClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromJoinClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromJoinClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromJoinClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromJoinClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromJoinClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromJoinClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromJoinClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "JoinKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "EqualsKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromJoinClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromJoinClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromJoinClauseCore(property, oldPArent, position, newParent);
//    		MovedFromJoinClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromWhereClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhereClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromWhereClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromWhereClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromWhereClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromWhereClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhereClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromWhereClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromWhereClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromWhereClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromWhereClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromWhereClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromWhereClauseCore(property, position, parent);
//    		InsertedFromWhereClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromWhereClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhereClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromWhereClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromWhereClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromWhereClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromWhereClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhereClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromWhereClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromWhereClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromWhereClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromWhereClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromWhereClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromWhereClauseCore(property, parent);
//    		DeletedFromWhereClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromWhereClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhereClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromWhereClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromWhereClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromWhereClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromWhereClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhereClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromWhereClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromWhereClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhereClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhereClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromWhereClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromWhereClauseCore(oldElement, newElement);
//    		UpdatedFromWhereClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromWhereClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhereClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromWhereClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromWhereClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromWhereClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromWhereClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhereClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromWhereClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromWhereClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromWhereClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhereKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromWhereClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromWhereClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromWhereClauseCore(property, oldPArent, position, newParent);
//    		MovedFromWhereClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromOrderByClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOrderByClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromOrderByClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromOrderByClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromOrderByClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromOrderByClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromOrderByClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromOrderByClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromOrderByClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromOrderByClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OrderByKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromOrderByClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromOrderByClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromOrderByClauseCore(property, position, parent);
//    		InsertedFromOrderByClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromOrderByClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOrderByClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromOrderByClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromOrderByClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromOrderByClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromOrderByClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromOrderByClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromOrderByClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromOrderByClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromOrderByClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OrderByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromOrderByClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromOrderByClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromOrderByClauseCore(property, parent);
//    		DeletedFromOrderByClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromOrderByClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOrderByClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromOrderByClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromOrderByClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromOrderByClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromOrderByClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromOrderByClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromOrderByClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromOrderByClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromOrderByClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OrderByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromOrderByClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromOrderByClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromOrderByClauseCore(oldElement, newElement);
//    		UpdatedFromOrderByClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromOrderByClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOrderByClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromOrderByClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromOrderByClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromOrderByClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromOrderByClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromOrderByClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromOrderByClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromOrderByClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromOrderByClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OrderByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromOrderByClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromOrderByClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromOrderByClauseCore(property, oldPArent, position, newParent);
//    		MovedFromOrderByClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSelectClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSelectClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSelectClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSelectClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSelectClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSelectClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSelectClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSelectClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSelectClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSelectClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SelectKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSelectClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSelectClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSelectClauseCore(property, position, parent);
//    		InsertedFromSelectClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSelectClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSelectClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSelectClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSelectClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSelectClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSelectClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSelectClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSelectClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSelectClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSelectClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SelectKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSelectClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSelectClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSelectClauseCore(property, parent);
//    		DeletedFromSelectClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSelectClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSelectClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSelectClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSelectClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSelectClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSelectClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSelectClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSelectClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSelectClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSelectClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SelectKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSelectClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSelectClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSelectClauseCore(oldElement, newElement);
//    		UpdatedFromSelectClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSelectClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSelectClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSelectClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSelectClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSelectClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSelectClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSelectClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSelectClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSelectClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSelectClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SelectKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSelectClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSelectClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSelectClauseCore(property, oldPArent, position, newParent);
//    		MovedFromSelectClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromGroupClause(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGroupClause(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromGroupClauseCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromGroupClause(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromGroupClauseBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromGroupClauseCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGroupClauseCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromGroupClauseAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromGroupClause(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromGroupClauseCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GroupKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ByKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromGroupClause(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromGroupClauseBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromGroupClauseCore(property, position, parent);
//    		InsertedFromGroupClauseAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromGroupClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGroupClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromGroupClauseCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromGroupClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromGroupClauseBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromGroupClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGroupClauseCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromGroupClauseAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromGroupClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromGroupClauseCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GroupKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromGroupClause(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromGroupClauseBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromGroupClauseCore(property, parent);
//    		DeletedFromGroupClauseAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromGroupClause(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGroupClause(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromGroupClauseCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromGroupClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromGroupClauseBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromGroupClauseCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGroupClauseCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromGroupClauseAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromGroupClause(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromGroupClauseCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GroupKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromGroupClause(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromGroupClauseBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromGroupClauseCore(oldElement, newElement);
//    		UpdatedFromGroupClauseAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromGroupClause(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGroupClause(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromGroupClauseCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromGroupClause(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromGroupClauseBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromGroupClauseCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGroupClauseCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromGroupClauseAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromGroupClause(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromGroupClauseCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GroupKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ByKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromGroupClause(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromGroupClauseBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromGroupClauseCore(property, oldPArent, position, newParent);
//    		MovedFromGroupClauseAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDeclarationPattern(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDeclarationPattern(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDeclarationPatternCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDeclarationPattern(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDeclarationPatternBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDeclarationPatternCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDeclarationPatternCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDeclarationPatternAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDeclarationPattern(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDeclarationPatternCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDeclarationPattern(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDeclarationPatternBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDeclarationPatternCore(property, position, parent);
//    		InsertedFromDeclarationPatternAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDeclarationPattern(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDeclarationPattern(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDeclarationPatternCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDeclarationPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDeclarationPatternBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDeclarationPatternCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDeclarationPatternCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDeclarationPatternAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDeclarationPattern(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDeclarationPatternCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDeclarationPattern(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDeclarationPatternBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDeclarationPatternCore(property, parent);
//    		DeletedFromDeclarationPatternAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDeclarationPattern(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDeclarationPattern(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDeclarationPatternCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDeclarationPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDeclarationPatternBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDeclarationPatternCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDeclarationPatternCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDeclarationPatternAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDeclarationPattern(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDeclarationPatternCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDeclarationPattern(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDeclarationPatternBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDeclarationPatternCore(oldElement, newElement);
//    		UpdatedFromDeclarationPatternAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDeclarationPattern(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDeclarationPattern(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDeclarationPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDeclarationPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDeclarationPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDeclarationPatternCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDeclarationPatternCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDeclarationPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDeclarationPattern(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDeclarationPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDeclarationPattern(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDeclarationPatternBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDeclarationPatternCore(property, oldPArent, position, newParent);
//    		MovedFromDeclarationPatternAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromConstantPattern(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstantPattern(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromConstantPatternCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromConstantPattern(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromConstantPatternBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromConstantPatternCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromConstantPatternCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromConstantPatternAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromConstantPattern(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromConstantPatternCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromConstantPattern(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromConstantPatternBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromConstantPatternCore(property, position, parent);
//    		InsertedFromConstantPatternAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromConstantPattern(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstantPattern(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromConstantPatternCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromConstantPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromConstantPatternBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromConstantPatternCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromConstantPatternCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromConstantPatternAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromConstantPattern(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromConstantPatternCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromConstantPattern(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromConstantPatternBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromConstantPatternCore(property, parent);
//    		DeletedFromConstantPatternAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromConstantPattern(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstantPattern(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromConstantPatternCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromConstantPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromConstantPatternBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromConstantPatternCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromConstantPatternCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromConstantPatternAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromConstantPattern(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstantPatternCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromConstantPattern(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromConstantPatternBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromConstantPatternCore(oldElement, newElement);
//    		UpdatedFromConstantPatternAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromConstantPattern(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstantPattern(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromConstantPatternCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromConstantPattern(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromConstantPatternBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromConstantPatternCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromConstantPatternCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromConstantPatternAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromConstantPattern(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromConstantPatternCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromConstantPattern(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromConstantPatternBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromConstantPatternCore(property, oldPArent, position, newParent);
//    		MovedFromConstantPatternAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterpolatedStringText(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolatedStringText(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterpolatedStringTextCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterpolatedStringText(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterpolatedStringTextBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterpolatedStringTextCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolatedStringTextCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterpolatedStringTextAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterpolatedStringText(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolatedStringTextCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolatedStringText(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterpolatedStringTextBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterpolatedStringTextCore(property, position, parent);
//    		InsertedFromInterpolatedStringTextAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterpolatedStringText(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolatedStringText(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterpolatedStringTextCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterpolatedStringText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterpolatedStringTextBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterpolatedStringTextCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolatedStringTextCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterpolatedStringTextAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterpolatedStringText(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolatedStringTextCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolatedStringText(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterpolatedStringTextBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterpolatedStringTextCore(property, parent);
//    		DeletedFromInterpolatedStringTextAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterpolatedStringText(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolatedStringText(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterpolatedStringTextCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterpolatedStringText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterpolatedStringTextBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterpolatedStringTextCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolatedStringTextCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterpolatedStringTextAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterpolatedStringText(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolatedStringTextCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolatedStringText(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterpolatedStringTextBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterpolatedStringTextCore(oldElement, newElement);
//    		UpdatedFromInterpolatedStringTextAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterpolatedStringText(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolatedStringText(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterpolatedStringTextCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterpolatedStringText(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterpolatedStringTextBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolatedStringTextCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterpolatedStringTextAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterpolatedStringText(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolatedStringTextCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolatedStringText(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterpolatedStringTextBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterpolatedStringTextCore(property, oldPArent, position, newParent);
//    		MovedFromInterpolatedStringTextAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromInterpolation(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolation(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromInterpolationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromInterpolation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromInterpolationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromInterpolationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromInterpolationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromInterpolationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromInterpolation(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromInterpolation(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromInterpolationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromInterpolationCore(property, position, parent);
//    		InsertedFromInterpolationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromInterpolation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromInterpolationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromInterpolation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromInterpolationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromInterpolationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromInterpolationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromInterpolationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromInterpolation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromInterpolation(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromInterpolationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromInterpolationCore(property, parent);
//    		DeletedFromInterpolationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromInterpolation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromInterpolationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromInterpolation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromInterpolationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromInterpolationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromInterpolationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromInterpolationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromInterpolation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromInterpolation(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromInterpolationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromInterpolationCore(oldElement, newElement);
//    		UpdatedFromInterpolationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromInterpolation(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolation(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromInterpolationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromInterpolation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromInterpolationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromInterpolationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromInterpolationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromInterpolationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromInterpolation(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromInterpolation(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromInterpolationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromInterpolationCore(property, oldPArent, position, newParent);
//    		MovedFromInterpolationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBlock(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBlock(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBlockCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBlock(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBlockBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBlockCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBlockCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBlockAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBlock(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBlockCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBlock(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBlockBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBlockCore(property, position, parent);
//    		InsertedFromBlockAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBlock(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBlock(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBlockCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBlock(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBlockBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBlockCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBlockCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBlockAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBlock(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBlockCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBlock(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBlockBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBlockCore(property, parent);
//    		DeletedFromBlockAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBlock(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBlock(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBlockCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBlock(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBlockBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBlockCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBlockCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBlockAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBlock(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBlockCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBlock(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBlockBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBlockCore(oldElement, newElement);
//    		UpdatedFromBlockAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBlock(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBlock(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBlockCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBlock(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBlockBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBlockCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBlockCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBlockAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBlock(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBlockCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBlock(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBlockBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBlockCore(property, oldPArent, position, newParent);
//    		MovedFromBlockAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLocalFunctionStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLocalFunctionStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLocalFunctionStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLocalFunctionStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLocalFunctionStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLocalFunctionStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLocalFunctionStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLocalFunctionStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLocalFunctionStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLocalFunctionStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLocalFunctionStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLocalFunctionStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLocalFunctionStatementCore(property, position, parent);
//    		InsertedFromLocalFunctionStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLocalFunctionStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLocalFunctionStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLocalFunctionStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLocalFunctionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLocalFunctionStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLocalFunctionStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLocalFunctionStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLocalFunctionStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLocalFunctionStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLocalFunctionStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLocalFunctionStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLocalFunctionStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLocalFunctionStatementCore(property, parent);
//    		DeletedFromLocalFunctionStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLocalFunctionStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLocalFunctionStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLocalFunctionStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLocalFunctionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLocalFunctionStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLocalFunctionStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLocalFunctionStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLocalFunctionStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLocalFunctionStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLocalFunctionStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLocalFunctionStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLocalFunctionStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLocalFunctionStatementCore(oldElement, newElement);
//    		UpdatedFromLocalFunctionStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLocalFunctionStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLocalFunctionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLocalFunctionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLocalFunctionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLocalFunctionStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLocalFunctionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLocalFunctionStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLocalFunctionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLocalFunctionStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLocalFunctionStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLocalFunctionStatementCore(property, oldPArent, position, newParent);
//    		MovedFromLocalFunctionStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLocalDeclarationStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLocalDeclarationStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLocalDeclarationStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLocalDeclarationStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLocalDeclarationStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLocalDeclarationStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLocalDeclarationStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLocalDeclarationStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLocalDeclarationStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLocalDeclarationStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLocalDeclarationStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLocalDeclarationStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLocalDeclarationStatementCore(property, position, parent);
//    		InsertedFromLocalDeclarationStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLocalDeclarationStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLocalDeclarationStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLocalDeclarationStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLocalDeclarationStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLocalDeclarationStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLocalDeclarationStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLocalDeclarationStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLocalDeclarationStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLocalDeclarationStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLocalDeclarationStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLocalDeclarationStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLocalDeclarationStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLocalDeclarationStatementCore(property, parent);
//    		DeletedFromLocalDeclarationStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLocalDeclarationStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLocalDeclarationStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLocalDeclarationStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLocalDeclarationStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLocalDeclarationStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLocalDeclarationStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLocalDeclarationStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLocalDeclarationStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLocalDeclarationStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLocalDeclarationStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLocalDeclarationStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLocalDeclarationStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLocalDeclarationStatementCore(oldElement, newElement);
//    		UpdatedFromLocalDeclarationStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLocalDeclarationStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLocalDeclarationStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLocalDeclarationStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLocalDeclarationStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLocalDeclarationStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLocalDeclarationStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLocalDeclarationStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLocalDeclarationStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLocalDeclarationStatementCore(property, oldPArent, position, newParent);
//    		MovedFromLocalDeclarationStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromExpressionStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExpressionStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromExpressionStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromExpressionStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromExpressionStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromExpressionStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromExpressionStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromExpressionStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromExpressionStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromExpressionStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromExpressionStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromExpressionStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromExpressionStatementCore(property, position, parent);
//    		InsertedFromExpressionStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromExpressionStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExpressionStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromExpressionStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromExpressionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromExpressionStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromExpressionStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromExpressionStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromExpressionStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromExpressionStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromExpressionStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromExpressionStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromExpressionStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromExpressionStatementCore(property, parent);
//    		DeletedFromExpressionStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromExpressionStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExpressionStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromExpressionStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromExpressionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromExpressionStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromExpressionStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromExpressionStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromExpressionStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromExpressionStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromExpressionStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromExpressionStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromExpressionStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromExpressionStatementCore(oldElement, newElement);
//    		UpdatedFromExpressionStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromExpressionStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExpressionStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromExpressionStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromExpressionStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromExpressionStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromExpressionStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromExpressionStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromExpressionStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromExpressionStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromExpressionStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromExpressionStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromExpressionStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromExpressionStatementCore(property, oldPArent, position, newParent);
//    		MovedFromExpressionStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromEmptyStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEmptyStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromEmptyStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromEmptyStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromEmptyStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromEmptyStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromEmptyStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromEmptyStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromEmptyStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromEmptyStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromEmptyStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromEmptyStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromEmptyStatementCore(property, position, parent);
//    		InsertedFromEmptyStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromEmptyStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEmptyStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromEmptyStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromEmptyStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromEmptyStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromEmptyStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromEmptyStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromEmptyStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromEmptyStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromEmptyStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromEmptyStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromEmptyStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromEmptyStatementCore(property, parent);
//    		DeletedFromEmptyStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromEmptyStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEmptyStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromEmptyStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromEmptyStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromEmptyStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromEmptyStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromEmptyStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromEmptyStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromEmptyStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromEmptyStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromEmptyStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromEmptyStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromEmptyStatementCore(oldElement, newElement);
//    		UpdatedFromEmptyStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromEmptyStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEmptyStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromEmptyStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromEmptyStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromEmptyStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromEmptyStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromEmptyStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromEmptyStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromEmptyStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromEmptyStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromEmptyStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromEmptyStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromEmptyStatementCore(property, oldPArent, position, newParent);
//    		MovedFromEmptyStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLabeledStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLabeledStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLabeledStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLabeledStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLabeledStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLabeledStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLabeledStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLabeledStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLabeledStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLabeledStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLabeledStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLabeledStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLabeledStatementCore(property, position, parent);
//    		InsertedFromLabeledStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLabeledStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLabeledStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLabeledStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLabeledStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLabeledStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLabeledStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLabeledStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLabeledStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLabeledStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLabeledStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLabeledStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLabeledStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLabeledStatementCore(property, parent);
//    		DeletedFromLabeledStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLabeledStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLabeledStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLabeledStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLabeledStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLabeledStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLabeledStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLabeledStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLabeledStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLabeledStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLabeledStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLabeledStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLabeledStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLabeledStatementCore(oldElement, newElement);
//    		UpdatedFromLabeledStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLabeledStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLabeledStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLabeledStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLabeledStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLabeledStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLabeledStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLabeledStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLabeledStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLabeledStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLabeledStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLabeledStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLabeledStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLabeledStatementCore(property, oldPArent, position, newParent);
//    		MovedFromLabeledStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromGotoStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGotoStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromGotoStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromGotoStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromGotoStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromGotoStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromGotoStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromGotoStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromGotoStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromGotoStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GotoKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromGotoStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromGotoStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromGotoStatementCore(property, position, parent);
//    		InsertedFromGotoStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromGotoStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGotoStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromGotoStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromGotoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromGotoStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromGotoStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromGotoStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromGotoStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromGotoStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromGotoStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GotoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromGotoStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromGotoStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromGotoStatementCore(property, parent);
//    		DeletedFromGotoStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromGotoStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGotoStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromGotoStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromGotoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromGotoStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromGotoStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromGotoStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromGotoStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromGotoStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromGotoStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GotoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromGotoStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromGotoStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromGotoStatementCore(oldElement, newElement);
//    		UpdatedFromGotoStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromGotoStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGotoStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromGotoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromGotoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromGotoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromGotoStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromGotoStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromGotoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromGotoStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromGotoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "GotoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CaseOrDefaultKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromGotoStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromGotoStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromGotoStatementCore(property, oldPArent, position, newParent);
//    		MovedFromGotoStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromBreakStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBreakStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromBreakStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromBreakStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromBreakStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromBreakStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromBreakStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromBreakStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromBreakStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromBreakStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "BreakKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromBreakStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromBreakStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromBreakStatementCore(property, position, parent);
//    		InsertedFromBreakStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromBreakStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBreakStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromBreakStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromBreakStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromBreakStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromBreakStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromBreakStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromBreakStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromBreakStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromBreakStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "BreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromBreakStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromBreakStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromBreakStatementCore(property, parent);
//    		DeletedFromBreakStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromBreakStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBreakStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromBreakStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromBreakStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromBreakStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromBreakStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromBreakStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromBreakStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromBreakStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromBreakStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "BreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromBreakStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromBreakStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromBreakStatementCore(oldElement, newElement);
//    		UpdatedFromBreakStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromBreakStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBreakStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromBreakStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromBreakStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromBreakStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromBreakStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromBreakStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromBreakStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromBreakStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromBreakStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "BreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromBreakStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromBreakStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromBreakStatementCore(property, oldPArent, position, newParent);
//    		MovedFromBreakStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromContinueStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromContinueStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromContinueStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromContinueStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromContinueStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromContinueStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromContinueStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromContinueStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromContinueStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromContinueStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ContinueKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromContinueStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromContinueStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromContinueStatementCore(property, position, parent);
//    		InsertedFromContinueStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromContinueStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromContinueStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromContinueStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromContinueStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromContinueStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromContinueStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromContinueStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromContinueStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromContinueStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromContinueStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ContinueKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromContinueStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromContinueStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromContinueStatementCore(property, parent);
//    		DeletedFromContinueStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromContinueStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromContinueStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromContinueStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromContinueStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromContinueStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromContinueStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromContinueStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromContinueStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromContinueStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromContinueStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ContinueKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromContinueStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromContinueStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromContinueStatementCore(oldElement, newElement);
//    		UpdatedFromContinueStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromContinueStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromContinueStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromContinueStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromContinueStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromContinueStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromContinueStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromContinueStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromContinueStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromContinueStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromContinueStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ContinueKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromContinueStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromContinueStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromContinueStatementCore(property, oldPArent, position, newParent);
//    		MovedFromContinueStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromReturnStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromReturnStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromReturnStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromReturnStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromReturnStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromReturnStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromReturnStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromReturnStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromReturnStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromReturnStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ReturnKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromReturnStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromReturnStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromReturnStatementCore(property, position, parent);
//    		InsertedFromReturnStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromReturnStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromReturnStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromReturnStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromReturnStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromReturnStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromReturnStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromReturnStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromReturnStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromReturnStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromReturnStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ReturnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromReturnStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromReturnStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromReturnStatementCore(property, parent);
//    		DeletedFromReturnStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromReturnStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromReturnStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromReturnStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromReturnStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromReturnStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromReturnStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromReturnStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromReturnStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromReturnStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromReturnStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ReturnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromReturnStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromReturnStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromReturnStatementCore(oldElement, newElement);
//    		UpdatedFromReturnStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromReturnStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromReturnStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromReturnStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromReturnStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromReturnStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromReturnStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromReturnStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromReturnStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromReturnStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromReturnStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ReturnKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromReturnStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromReturnStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromReturnStatementCore(property, oldPArent, position, newParent);
//    		MovedFromReturnStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromThrowStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThrowStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromThrowStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromThrowStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromThrowStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromThrowStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromThrowStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromThrowStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromThrowStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromThrowStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromThrowStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromThrowStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromThrowStatementCore(property, position, parent);
//    		InsertedFromThrowStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromThrowStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThrowStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromThrowStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromThrowStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromThrowStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromThrowStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromThrowStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromThrowStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromThrowStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromThrowStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromThrowStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromThrowStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromThrowStatementCore(property, parent);
//    		DeletedFromThrowStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromThrowStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThrowStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromThrowStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromThrowStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromThrowStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromThrowStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromThrowStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromThrowStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromThrowStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromThrowStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromThrowStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromThrowStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromThrowStatementCore(oldElement, newElement);
//    		UpdatedFromThrowStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromThrowStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThrowStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromThrowStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromThrowStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromThrowStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromThrowStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromThrowStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromThrowStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromThrowStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromThrowStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ThrowKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromThrowStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromThrowStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromThrowStatementCore(property, oldPArent, position, newParent);
//    		MovedFromThrowStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromYieldStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromYieldStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromYieldStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromYieldStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromYieldStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromYieldStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromYieldStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromYieldStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromYieldStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromYieldStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "YieldKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromYieldStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromYieldStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromYieldStatementCore(property, position, parent);
//    		InsertedFromYieldStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromYieldStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromYieldStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromYieldStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromYieldStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromYieldStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromYieldStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromYieldStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromYieldStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromYieldStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromYieldStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "YieldKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromYieldStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromYieldStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromYieldStatementCore(property, parent);
//    		DeletedFromYieldStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromYieldStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromYieldStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromYieldStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromYieldStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromYieldStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromYieldStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromYieldStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromYieldStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromYieldStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromYieldStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "YieldKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromYieldStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromYieldStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromYieldStatementCore(oldElement, newElement);
//    		UpdatedFromYieldStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromYieldStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromYieldStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromYieldStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromYieldStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromYieldStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromYieldStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromYieldStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromYieldStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromYieldStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromYieldStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "YieldKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ReturnOrBreakKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromYieldStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromYieldStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromYieldStatementCore(property, oldPArent, position, newParent);
//    		MovedFromYieldStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromWhileStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhileStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromWhileStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromWhileStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromWhileStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromWhileStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromWhileStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromWhileStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromWhileStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromWhileStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromWhileStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromWhileStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromWhileStatementCore(property, position, parent);
//    		InsertedFromWhileStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromWhileStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhileStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromWhileStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromWhileStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromWhileStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromWhileStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromWhileStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromWhileStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromWhileStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromWhileStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromWhileStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromWhileStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromWhileStatementCore(property, parent);
//    		DeletedFromWhileStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromWhileStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhileStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromWhileStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromWhileStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromWhileStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromWhileStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromWhileStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromWhileStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromWhileStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhileStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromWhileStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromWhileStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromWhileStatementCore(oldElement, newElement);
//    		UpdatedFromWhileStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromWhileStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhileStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromWhileStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromWhileStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromWhileStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromWhileStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromWhileStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromWhileStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromWhileStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromWhileStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromWhileStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromWhileStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromWhileStatementCore(property, oldPArent, position, newParent);
//    		MovedFromWhileStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDoStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDoStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDoStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDoStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDoStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDoStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDoStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDoStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDoStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDoStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DoKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDoStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDoStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDoStatementCore(property, position, parent);
//    		InsertedFromDoStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDoStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDoStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDoStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDoStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDoStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDoStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDoStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDoStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDoStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDoStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDoStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDoStatementCore(property, parent);
//    		DeletedFromDoStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDoStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDoStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDoStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDoStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDoStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDoStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDoStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDoStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDoStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDoStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDoStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDoStatementCore(oldElement, newElement);
//    		UpdatedFromDoStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDoStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDoStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDoStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDoStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDoStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDoStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDoStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDoStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDoStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDoStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "DoKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "WhileKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDoStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDoStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDoStatementCore(property, oldPArent, position, newParent);
//    		MovedFromDoStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromForStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromForStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromForStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromForStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromForStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromForStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromForStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromForStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromForStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromForStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromForStatementCore(property, position, parent);
//    		InsertedFromForStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromForStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromForStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromForStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromForStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromForStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromForStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromForStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromForStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromForStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromForStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromForStatementCore(property, parent);
//    		DeletedFromForStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromForStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromForStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromForStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromForStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromForStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromForStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromForStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromForStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromForStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromForStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromForStatementCore(oldElement, newElement);
//    		UpdatedFromForStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromForStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromForStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromForStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromForStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromForStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromForStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromForStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromForStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "FirstSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "SecondSemicolonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromForStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromForStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromForStatementCore(property, oldPArent, position, newParent);
//    		MovedFromForStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromUsingStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUsingStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromUsingStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromUsingStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromUsingStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromUsingStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUsingStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromUsingStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromUsingStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromUsingStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromUsingStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromUsingStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromUsingStatementCore(property, position, parent);
//    		InsertedFromUsingStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromUsingStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUsingStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromUsingStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromUsingStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromUsingStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromUsingStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUsingStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromUsingStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromUsingStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromUsingStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromUsingStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromUsingStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromUsingStatementCore(property, parent);
//    		DeletedFromUsingStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromUsingStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUsingStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromUsingStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromUsingStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromUsingStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromUsingStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUsingStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromUsingStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromUsingStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromUsingStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromUsingStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromUsingStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromUsingStatementCore(oldElement, newElement);
//    		UpdatedFromUsingStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromUsingStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUsingStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromUsingStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromUsingStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromUsingStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromUsingStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUsingStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromUsingStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromUsingStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromUsingStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UsingKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromUsingStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromUsingStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromUsingStatementCore(property, oldPArent, position, newParent);
//    		MovedFromUsingStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromFixedStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFixedStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromFixedStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromFixedStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromFixedStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromFixedStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromFixedStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromFixedStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromFixedStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromFixedStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FixedKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromFixedStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromFixedStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromFixedStatementCore(property, position, parent);
//    		InsertedFromFixedStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromFixedStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFixedStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromFixedStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromFixedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromFixedStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromFixedStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromFixedStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromFixedStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromFixedStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromFixedStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FixedKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromFixedStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromFixedStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromFixedStatementCore(property, parent);
//    		DeletedFromFixedStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromFixedStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFixedStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromFixedStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromFixedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromFixedStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromFixedStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromFixedStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromFixedStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromFixedStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromFixedStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FixedKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromFixedStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromFixedStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromFixedStatementCore(oldElement, newElement);
//    		UpdatedFromFixedStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromFixedStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFixedStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromFixedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromFixedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromFixedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromFixedStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromFixedStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromFixedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromFixedStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromFixedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "FixedKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromFixedStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromFixedStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromFixedStatementCore(property, oldPArent, position, newParent);
//    		MovedFromFixedStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCheckedStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCheckedStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCheckedStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCheckedStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCheckedStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCheckedStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCheckedStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCheckedStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCheckedStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCheckedStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCheckedStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCheckedStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCheckedStatementCore(property, position, parent);
//    		InsertedFromCheckedStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCheckedStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCheckedStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCheckedStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCheckedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCheckedStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCheckedStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCheckedStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCheckedStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCheckedStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCheckedStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCheckedStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCheckedStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCheckedStatementCore(property, parent);
//    		DeletedFromCheckedStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCheckedStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCheckedStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCheckedStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCheckedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCheckedStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCheckedStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCheckedStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCheckedStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCheckedStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCheckedStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCheckedStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCheckedStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCheckedStatementCore(oldElement, newElement);
//    		UpdatedFromCheckedStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCheckedStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCheckedStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCheckedStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCheckedStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCheckedStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCheckedStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCheckedStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCheckedStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCheckedStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCheckedStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCheckedStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCheckedStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCheckedStatementCore(property, oldPArent, position, newParent);
//    		MovedFromCheckedStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromUnsafeStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUnsafeStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromUnsafeStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromUnsafeStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromUnsafeStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromUnsafeStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromUnsafeStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromUnsafeStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromUnsafeStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromUnsafeStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromUnsafeStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromUnsafeStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromUnsafeStatementCore(property, position, parent);
//    		InsertedFromUnsafeStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromUnsafeStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUnsafeStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromUnsafeStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromUnsafeStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromUnsafeStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromUnsafeStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromUnsafeStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromUnsafeStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromUnsafeStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromUnsafeStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromUnsafeStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromUnsafeStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromUnsafeStatementCore(property, parent);
//    		DeletedFromUnsafeStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromUnsafeStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUnsafeStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromUnsafeStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromUnsafeStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromUnsafeStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromUnsafeStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromUnsafeStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromUnsafeStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromUnsafeStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromUnsafeStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromUnsafeStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromUnsafeStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromUnsafeStatementCore(oldElement, newElement);
//    		UpdatedFromUnsafeStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromUnsafeStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUnsafeStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromUnsafeStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromUnsafeStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromUnsafeStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromUnsafeStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromUnsafeStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromUnsafeStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromUnsafeStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromUnsafeStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnsafeKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromUnsafeStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromUnsafeStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromUnsafeStatementCore(property, oldPArent, position, newParent);
//    		MovedFromUnsafeStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromLockStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLockStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromLockStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromLockStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromLockStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromLockStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromLockStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromLockStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromLockStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromLockStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LockKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromLockStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromLockStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromLockStatementCore(property, position, parent);
//    		InsertedFromLockStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromLockStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLockStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromLockStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromLockStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromLockStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromLockStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromLockStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromLockStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromLockStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromLockStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LockKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromLockStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromLockStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromLockStatementCore(property, parent);
//    		DeletedFromLockStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromLockStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLockStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromLockStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromLockStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromLockStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromLockStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromLockStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromLockStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromLockStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromLockStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LockKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromLockStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromLockStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromLockStatementCore(oldElement, newElement);
//    		UpdatedFromLockStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromLockStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLockStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromLockStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromLockStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromLockStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromLockStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromLockStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromLockStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromLockStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromLockStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "LockKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromLockStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromLockStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromLockStatementCore(property, oldPArent, position, newParent);
//    		MovedFromLockStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromIfStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIfStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromIfStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromIfStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromIfStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromIfStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromIfStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromIfStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromIfStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromIfStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromIfStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromIfStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromIfStatementCore(property, position, parent);
//    		InsertedFromIfStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromIfStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIfStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromIfStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromIfStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromIfStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromIfStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromIfStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromIfStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromIfStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromIfStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromIfStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromIfStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromIfStatementCore(property, parent);
//    		DeletedFromIfStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromIfStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIfStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromIfStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromIfStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromIfStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromIfStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromIfStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromIfStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromIfStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromIfStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromIfStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromIfStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromIfStatementCore(oldElement, newElement);
//    		UpdatedFromIfStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromIfStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIfStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromIfStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromIfStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromIfStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromIfStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromIfStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromIfStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromIfStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromIfStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "IfKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromIfStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromIfStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromIfStatementCore(property, oldPArent, position, newParent);
//    		MovedFromIfStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSwitchStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSwitchStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSwitchStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSwitchStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSwitchStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSwitchStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSwitchStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSwitchStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSwitchStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSwitchStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SwitchKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSwitchStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSwitchStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSwitchStatementCore(property, position, parent);
//    		InsertedFromSwitchStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSwitchStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSwitchStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSwitchStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSwitchStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSwitchStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSwitchStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSwitchStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSwitchStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSwitchStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSwitchStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SwitchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSwitchStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSwitchStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSwitchStatementCore(property, parent);
//    		DeletedFromSwitchStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSwitchStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSwitchStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSwitchStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSwitchStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSwitchStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSwitchStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSwitchStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSwitchStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSwitchStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSwitchStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SwitchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSwitchStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSwitchStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSwitchStatementCore(oldElement, newElement);
//    		UpdatedFromSwitchStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSwitchStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSwitchStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSwitchStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSwitchStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSwitchStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSwitchStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSwitchStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSwitchStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSwitchStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSwitchStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "SwitchKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseBraceToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSwitchStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSwitchStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSwitchStatementCore(property, oldPArent, position, newParent);
//    		MovedFromSwitchStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromTryStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTryStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromTryStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromTryStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromTryStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromTryStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromTryStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromTryStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromTryStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromTryStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TryKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromTryStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromTryStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromTryStatementCore(property, position, parent);
//    		InsertedFromTryStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromTryStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTryStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromTryStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromTryStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromTryStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromTryStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromTryStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromTryStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromTryStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromTryStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TryKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromTryStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromTryStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromTryStatementCore(property, parent);
//    		DeletedFromTryStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromTryStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTryStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromTryStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromTryStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromTryStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromTryStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromTryStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromTryStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromTryStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromTryStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TryKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromTryStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromTryStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromTryStatementCore(oldElement, newElement);
//    		UpdatedFromTryStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromTryStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTryStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromTryStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromTryStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromTryStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromTryStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromTryStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromTryStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromTryStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromTryStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "TryKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromTryStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromTryStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromTryStatementCore(property, oldPArent, position, newParent);
//    		MovedFromTryStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromForEachStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForEachStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromForEachStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromForEachStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromForEachStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromForEachStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForEachStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromForEachStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromForEachStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromForEachStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromForEachStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromForEachStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromForEachStatementCore(property, position, parent);
//    		InsertedFromForEachStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromForEachStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForEachStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromForEachStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromForEachStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromForEachStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromForEachStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForEachStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromForEachStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromForEachStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromForEachStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromForEachStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromForEachStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromForEachStatementCore(property, parent);
//    		DeletedFromForEachStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromForEachStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForEachStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromForEachStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromForEachStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromForEachStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromForEachStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForEachStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromForEachStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromForEachStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromForEachStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromForEachStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromForEachStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromForEachStatementCore(oldElement, newElement);
//    		UpdatedFromForEachStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromForEachStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForEachStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromForEachStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromForEachStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromForEachStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromForEachStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForEachStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromForEachStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromForEachStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromForEachStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromForEachStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromForEachStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromForEachStatementCore(property, oldPArent, position, newParent);
//    		MovedFromForEachStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromForEachVariableStatement(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForEachVariableStatement(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromForEachVariableStatementCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromForEachVariableStatement(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromForEachVariableStatementBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromForEachVariableStatementCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromForEachVariableStatementCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromForEachVariableStatementAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromForEachVariableStatement(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromForEachVariableStatementCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromForEachVariableStatement(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromForEachVariableStatementBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromForEachVariableStatementCore(property, position, parent);
//    		InsertedFromForEachVariableStatementAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromForEachVariableStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForEachVariableStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromForEachVariableStatementCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromForEachVariableStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromForEachVariableStatementBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromForEachVariableStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromForEachVariableStatementCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromForEachVariableStatementAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromForEachVariableStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromForEachVariableStatementCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromForEachVariableStatement(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromForEachVariableStatementBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromForEachVariableStatementCore(property, parent);
//    		DeletedFromForEachVariableStatementAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromForEachVariableStatement(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForEachVariableStatement(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromForEachVariableStatementCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromForEachVariableStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromForEachVariableStatementBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromForEachVariableStatementCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromForEachVariableStatementCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromForEachVariableStatementAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromForEachVariableStatement(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromForEachVariableStatementCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromForEachVariableStatement(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromForEachVariableStatementBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromForEachVariableStatementCore(oldElement, newElement);
//    		UpdatedFromForEachVariableStatementAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromForEachVariableStatement(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForEachVariableStatement(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromForEachVariableStatementCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromForEachVariableStatement(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromForEachVariableStatementBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromForEachVariableStatementCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromForEachVariableStatementAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromForEachVariableStatement(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromForEachVariableStatementCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "ForEachKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "InKeyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromForEachVariableStatement(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromForEachVariableStatementBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromForEachVariableStatementCore(property, oldPArent, position, newParent);
//    		MovedFromForEachVariableStatementAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromSingleVariableDesignation(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSingleVariableDesignation(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromSingleVariableDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromSingleVariableDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromSingleVariableDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromSingleVariableDesignationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromSingleVariableDesignationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromSingleVariableDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromSingleVariableDesignation(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromSingleVariableDesignationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromSingleVariableDesignation(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromSingleVariableDesignationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromSingleVariableDesignationCore(property, position, parent);
//    		InsertedFromSingleVariableDesignationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromSingleVariableDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSingleVariableDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromSingleVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromSingleVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromSingleVariableDesignationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromSingleVariableDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromSingleVariableDesignationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromSingleVariableDesignationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromSingleVariableDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromSingleVariableDesignationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromSingleVariableDesignation(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromSingleVariableDesignationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromSingleVariableDesignationCore(property, parent);
//    		DeletedFromSingleVariableDesignationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromSingleVariableDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSingleVariableDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromSingleVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromSingleVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromSingleVariableDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromSingleVariableDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromSingleVariableDesignationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromSingleVariableDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromSingleVariableDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromSingleVariableDesignationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromSingleVariableDesignation(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromSingleVariableDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromSingleVariableDesignationCore(oldElement, newElement);
//    		UpdatedFromSingleVariableDesignationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromSingleVariableDesignation(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromSingleVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromSingleVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromSingleVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromSingleVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromSingleVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromSingleVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromSingleVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromSingleVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromSingleVariableDesignationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromSingleVariableDesignationCore(property, oldPArent, position, newParent);
//    		MovedFromSingleVariableDesignationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDiscardDesignation(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDiscardDesignation(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDiscardDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDiscardDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDiscardDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDiscardDesignationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDiscardDesignationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDiscardDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDiscardDesignation(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDiscardDesignationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnderscoreToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDiscardDesignation(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDiscardDesignationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDiscardDesignationCore(property, position, parent);
//    		InsertedFromDiscardDesignationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDiscardDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDiscardDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDiscardDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDiscardDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDiscardDesignationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDiscardDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDiscardDesignationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDiscardDesignationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDiscardDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDiscardDesignationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnderscoreToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDiscardDesignation(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDiscardDesignationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDiscardDesignationCore(property, parent);
//    		DeletedFromDiscardDesignationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDiscardDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDiscardDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDiscardDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDiscardDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDiscardDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDiscardDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDiscardDesignationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDiscardDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDiscardDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDiscardDesignationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnderscoreToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDiscardDesignation(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDiscardDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDiscardDesignationCore(oldElement, newElement);
//    		UpdatedFromDiscardDesignationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDiscardDesignation(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDiscardDesignation(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDiscardDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDiscardDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDiscardDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDiscardDesignationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDiscardDesignationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDiscardDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDiscardDesignation(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDiscardDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "UnderscoreToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDiscardDesignation(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDiscardDesignationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDiscardDesignationCore(property, oldPArent, position, newParent);
//    		MovedFromDiscardDesignationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromParenthesizedVariableDesignation(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedVariableDesignation(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromParenthesizedVariableDesignationCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromParenthesizedVariableDesignation(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromParenthesizedVariableDesignationBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromParenthesizedVariableDesignationCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromParenthesizedVariableDesignationCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromParenthesizedVariableDesignationAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromParenthesizedVariableDesignation(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedVariableDesignationCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromParenthesizedVariableDesignation(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromParenthesizedVariableDesignationBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromParenthesizedVariableDesignationCore(property, position, parent);
//    		InsertedFromParenthesizedVariableDesignationAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromParenthesizedVariableDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedVariableDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromParenthesizedVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromParenthesizedVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromParenthesizedVariableDesignationBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromParenthesizedVariableDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromParenthesizedVariableDesignationCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromParenthesizedVariableDesignationAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromParenthesizedVariableDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedVariableDesignationCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromParenthesizedVariableDesignation(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromParenthesizedVariableDesignationBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromParenthesizedVariableDesignationCore(property, parent);
//    		DeletedFromParenthesizedVariableDesignationAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromParenthesizedVariableDesignation(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedVariableDesignation(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromParenthesizedVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromParenthesizedVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromParenthesizedVariableDesignationBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromParenthesizedVariableDesignationCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromParenthesizedVariableDesignationCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromParenthesizedVariableDesignationAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromParenthesizedVariableDesignation(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedVariableDesignationCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromParenthesizedVariableDesignation(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromParenthesizedVariableDesignationBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromParenthesizedVariableDesignationCore(oldElement, newElement);
//    		UpdatedFromParenthesizedVariableDesignationAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromParenthesizedVariableDesignationBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromParenthesizedVariableDesignationCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromParenthesizedVariableDesignationAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromParenthesizedVariableDesignation(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedVariableDesignationCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "OpenParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "CloseParenToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromParenthesizedVariableDesignation(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromParenthesizedVariableDesignationBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromParenthesizedVariableDesignationCore(property, oldPArent, position, newParent);
//    		MovedFromParenthesizedVariableDesignationAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCasePatternSwitchLabel(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCasePatternSwitchLabel(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCasePatternSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCasePatternSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCasePatternSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCasePatternSwitchLabelCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCasePatternSwitchLabelCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCasePatternSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCasePatternSwitchLabel(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCasePatternSwitchLabelCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCasePatternSwitchLabel(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCasePatternSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCasePatternSwitchLabelCore(property, position, parent);
//    		InsertedFromCasePatternSwitchLabelAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCasePatternSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCasePatternSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCasePatternSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCasePatternSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCasePatternSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCasePatternSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCasePatternSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCasePatternSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCasePatternSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCasePatternSwitchLabelCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCasePatternSwitchLabel(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCasePatternSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCasePatternSwitchLabelCore(property, parent);
//    		DeletedFromCasePatternSwitchLabelAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCasePatternSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCasePatternSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCasePatternSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCasePatternSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCasePatternSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCasePatternSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCasePatternSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCasePatternSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCasePatternSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCasePatternSwitchLabelCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCasePatternSwitchLabel(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCasePatternSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCasePatternSwitchLabelCore(oldElement, newElement);
//    		UpdatedFromCasePatternSwitchLabelAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCasePatternSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCasePatternSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCasePatternSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCasePatternSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCasePatternSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCasePatternSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCasePatternSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCasePatternSwitchLabelBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCasePatternSwitchLabelCore(property, oldPArent, position, newParent);
//    		MovedFromCasePatternSwitchLabelAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromCaseSwitchLabel(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCaseSwitchLabel(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromCaseSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromCaseSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromCaseSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromCaseSwitchLabelCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromCaseSwitchLabelCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromCaseSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromCaseSwitchLabel(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromCaseSwitchLabelCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromCaseSwitchLabel(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromCaseSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromCaseSwitchLabelCore(property, position, parent);
//    		InsertedFromCaseSwitchLabelAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromCaseSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCaseSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromCaseSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromCaseSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromCaseSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromCaseSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromCaseSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromCaseSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromCaseSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromCaseSwitchLabelCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromCaseSwitchLabel(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromCaseSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromCaseSwitchLabelCore(property, parent);
//    		DeletedFromCaseSwitchLabelAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromCaseSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCaseSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromCaseSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromCaseSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromCaseSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromCaseSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromCaseSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromCaseSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromCaseSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromCaseSwitchLabelCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromCaseSwitchLabel(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromCaseSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromCaseSwitchLabelCore(oldElement, newElement);
//    		UpdatedFromCaseSwitchLabelAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromCaseSwitchLabel(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromCaseSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromCaseSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromCaseSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromCaseSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromCaseSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromCaseSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromCaseSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromCaseSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromCaseSwitchLabelBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromCaseSwitchLabelCore(property, oldPArent, position, newParent);
//    		MovedFromCaseSwitchLabelAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="InsertedFromDefaultSwitchLabel(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefaultSwitchLabel(XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="InsertedFromDefaultSwitchLabelCore(XElement, int, XElement)"/> is not executed and <see cref="InsertedFromDefaultSwitchLabel(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void InsertedFromDefaultSwitchLabelBefore(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="InsertedFromDefaultSwitchLabelCore(XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="InsertedFromDefaultSwitchLabelCore(XElement, int, XElement)"/>.</param>
//        partial void InsertedFromDefaultSwitchLabelAfter(XElement property, int position, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	/// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="InsertedFromDefaultSwitchLabel(XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> InsertedFromDefaultSwitchLabelCore(XElement property, int position, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.InsertFirstIffInsertSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes an insert action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where insert the property element in.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> InsertedFromDefaultSwitchLabel(XElement property, int position, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		InsertedFromDefaultSwitchLabelBefore(property, position, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.InsertedFromDefaultSwitchLabelCore(property, position, parent);
//    		InsertedFromDefaultSwitchLabelAfter(property, position, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="DeletedFromDefaultSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefaultSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="DeletedFromDefaultSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="DeletedFromDefaultSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void DeletedFromDefaultSwitchLabelBefore(XElement property, XElement parent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="DeletedFromDefaultSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="DeletedFromDefaultSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void DeletedFromDefaultSwitchLabelAfter(XElement property, XElement parent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="DeletedFromDefaultSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> DeletedFromDefaultSwitchLabelCore(XElement property, XElement parent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent, ref firstAction, ref secondAction))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a delete action.
//        /// </summary>
//        /// <param name="property">deleted element.</param>
//        /// <param name="parent">parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> DeletedFromDefaultSwitchLabel(XElement property, XElement parent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		DeletedFromDefaultSwitchLabelBefore(property, parent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.DeletedFromDefaultSwitchLabelCore(property, parent);
//    		DeletedFromDefaultSwitchLabelAfter(property, parent, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="UpdatedFromDefaultSwitchLabel(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefaultSwitchLabel(XElement, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="UpdatedFromDefaultSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="UpdatedFromDefaultSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void UpdatedFromDefaultSwitchLabelBefore(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="UpdatedFromDefaultSwitchLabelCore(XElement, XElement)"/>.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="UpdatedFromDefaultSwitchLabelCore(XElement, XElement)"/>.</param>
//        partial void UpdatedFromDefaultSwitchLabelAfter(XElement oldElement, XElement newElement, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="UpdatedFromDefaultSwitchLabel(XElement, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefaultSwitchLabelCore(XElement oldElement, XElement newElement)
//        {
//    		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
//    		if(newElement == null) throw new ArgumentNullException(nameof(newElement));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//         /// <summary>
//        /// Analyzes an update action.
//        /// </summary>
//        /// <param name="oldElement">original element.</param>
//        /// <param name="newElement">modified element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> UpdatedFromDefaultSwitchLabel(XElement oldElement, XElement newElement)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		UpdatedFromDefaultSwitchLabelBefore(oldElement, newElement, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.UpdatedFromDefaultSwitchLabelCore(oldElement, newElement);
//    		UpdatedFromDefaultSwitchLabelAfter(oldElement, newElement, ref result);
//    		return result;
//    	}
    
//    	/// <summary>
//        /// Method hook for implementing logic to execute before the <see cref="MovedFromDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</param>
//        /// <param name="ignoreCore">If true, the <see cref="MovedFromDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="MovedFromDefaultSwitchLabel(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
//        partial void MovedFromDefaultSwitchLabelBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result, ref bool ignoreCore);
        
//        /// <summary>
//        /// Method hook for implementing logic to execute after the <see cref="MovedFromDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <param name="result">Mechanism to modify the result of <see cref="MovedFromDefaultSwitchLabelCore(XElement, XElement, int, XElement)"/>.</param>
//        partial void MovedFromDefaultSwitchLabelAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<Imprecision> result);
    
//    	 /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        /// <remarks>This is the default implementation for <see cref="MovedFromDefaultSwitchLabel(XElement, XElement, int, XElement)"/>.</remarks>
//        public virtual IEnumerable<Imprecision> MovedFromDefaultSwitchLabelCore(XElement property, XElement oldParent, int position, XElement newParent)
//        {
//    		if(property == null)
//    			throw new ArgumentNullException(nameof(property));
    
//    		XElement firstAction = null, secondAction = null;
//    		if(property.Attribute("part")?.Value == "Keyword")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
//    		if(property.Attribute("part")?.Value == "ColonToken")
//    		{
//    			foreach(var imprecision in this.DeleteFirstIffDeleteSecond(property, property.Parent))
//    			{
//    				yield return imprecision;
//    			}
//    		}
    		
//    		yield break;
//        }	
    	
//        /// <summary>
//        /// Analyzes a move action.
//        /// </summary>
//        /// <param name="property">property element.</param>
//        /// <param name="position">position where the property would move.</param>
//        /// <param name="oldParent">original parent element.</param>
//        /// <param name="newParent">modified parent element.</param>
//        /// <returns>the imprecisions supposedly detected.</returns>
//        public virtual IEnumerable<Imprecision> MovedFromDefaultSwitchLabel(XElement property, XElement oldParent, int position, XElement newParent)
//    	{
//    		IEnumerable<Imprecision> result = null;
//    		var ignoreCore = false;
//    		MovedFromDefaultSwitchLabelBefore(property, oldPArent, position, newParent, ref result, ref ignoreCore);
//    		if(ignoreCore) 
//    			return result;
    		
//    		result = this.MovedFromDefaultSwitchLabelCore(property, oldPArent, position, newParent);
//    		MovedFromDefaultSwitchLabelAfter(property, oldPArent, position, newParent, ref result);
//    		return result;
//    	}
    
//    }
//}
//// Generated helper templates
//// Generated items
