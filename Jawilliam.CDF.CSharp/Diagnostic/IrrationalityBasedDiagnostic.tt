<#@ template language="C#" debug="True" hostSpecific="true"#>
<#@ output extension=".cs" #>
<#@ include file="..\TemplateFileManagerV2.1.ttinclude" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.Common.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.CSharp.2.7.0\lib\netstandard1.3\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(SolutionDir)\packages\CodePlex.LinqToXsd.2.0.2\lib\Xml.Schema.Linq.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF\bin\Debug\Jawilliam.CDF.dll" #>
<#@ assembly name="$(SolutionDir)\Jawilliam.CDF.XObjects\bin\Debug\Jawilliam.CDF.XObjects.dll" #>
<#@ assembly name="$(SolutionDir)\packages\System.Collections.Immutable.1.3.1\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Jawilliam.CDF" #>
<#@ import namespace="Jawilliam.CDF.GTED" #>
<#@ import namespace="Jawilliam.CDF.XObjects.RDSL" #>
<#
// <copyright file="LearningFromCSharpSyntaxVisitor.tt" company="Jasoco" author="Jawilliam">
//  Copyright Â© . All Rights Reserved.
// </copyright>

Type csharpSyntaxVisitor = typeof(CSharpSyntaxVisitor);
MethodInfo[] allMethods = csharpSyntaxVisitor.GetMembers().OfType<MethodInfo>().ToArray();

// Filters to methods starting with 'Visit' prefix, except that being called just 'Visit'.
MethodInfo[] visitMethods = allMethods.Where(m => m.Name.StartsWith("Visit") && m.Name != "Visit").ToArray();

// This methods represents the case logic of CSharpSyntaxVisitor for each type of syntax node, then lets to collect all that syntax node types.
List<Type> syntaxNodeTypes = visitMethods.Select(m => m.GetParameters().Single(p => p.Name == "node").ParameterType).Distinct().ToList();

// Build up the class system of syntax node types by completing the total hierarchy. 
List<Type> syntaxNodeSystem = new List<Type>(syntaxNodeTypes);
List<Type> syntaxInnerNodes = new List<Type>(220);
syntaxInnerNodes.AddRange(syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Intersect(syntaxNodeSystem));
List<Type> missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
while (missingSyntaxTypes.Any())
{
    syntaxInnerNodes.AddRange(missingSyntaxTypes);
    syntaxNodeSystem.AddRange(missingSyntaxTypes);
    missingSyntaxTypes = syntaxNodeSystem.Where(n => n.BaseType != typeof(object)).Select(n => n.BaseType).Distinct().Except(syntaxNodeSystem).ToList();
}

var syntaxNodeViews = syntaxNodeSystem
.Select(t => new
{
    Parent = t.BaseType.Name,
    Child = new Tree { Root = new Node { Label = t.Name } }
})
.ToList();

List<ITree> syntaxNodeHierarachies = new List<ITree>(220);
foreach (var parentType in syntaxInnerNodes)
{
    var parent = syntaxNodeViews.First(n => object.Equals(n.Child.Root.Label, parentType.Name));
    foreach (var child in syntaxNodeViews.Where(t => object.Equals(t.Parent, parent.Child.Root.Label)))
    {
        parent.Child.Children.Add(child.Child);
        child.Child.Parent = parent.Child;
    }
}

var syntaxSystemRoot = syntaxNodeViews.Where(t => t.Parent == typeof(object).Name).Single().Child;

CodeGenerationTools code = new CodeGenerationTools(this);
CodeRegion region = new CodeRegion(this, 1);
string namespaceName = code.VsNamespaceSuggestion();

var manager = TemplateFileManager.Create(this);

// var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.NodeTypes.Load(@"E:\Projects\Software Development Investigation\Jawilliam.Msr.Roslyn\CSharp\NodeTypeSystem.xml");
var xSyntaxTypeSystem = Jawilliam.CDF.XObjects.RDSL.Syntax.Load(@"E:\MyRepositories\Change-Detection-Foundation\Jawilliam.CDF.CSharp\RDSL.xml");

#>using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

<#
BeginNamespace(namespaceName, code);
#>
public partial class IrrationalityBasedDiagnostic
{
	#region Inserted(XElement, int, XElement)'s Visit

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Inserted(XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Inserted(XElement, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="InsertedCore(XElement, XElement)"/> is not executed and <see cref="Inserted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void InsertedBefore(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);

    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="InsertedCore(XElement, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="InsertedCore(XElement, XElement)"/>.</param>
    partial void InsertedAfter(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);
    
    /// <summary>
    /// Analyzes a insert action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Inserted(XElement, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> InsertedCore(XElement property, int position, XElement parent)
	{
		if(parent == null)
			throw new InvalidOperationException("The parent of a modified element cannot be null.");

		switch(parent.Name.LocalName)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
			case "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>": return this.Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(property, position, parent);
<#
	}
 }
}
#>
            case "SingleLineCommentTrivia": return this.InsertedFromSingleLineCommentTrivia(property, position, parent);
            case "MultiLineCommentTrivia": return this.InsertedFromMultiLineCommentTrivia(property, position, parent);
			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
		}
	}		
	
    /// <summary>
    /// Analyzes a insert action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Inserted(XElement property, int position, XElement parent)
    {
        IEnumerable<XElement> result = new XElement[0];
    	var ignoreCore = false;
    	InsertedBefore(property, position, parent, ref result, ref ignoreCore);
    	if(ignoreCore) 
    		return result;
    	
    	result = this.InsertedCore(property, position, parent);
    	InsertedAfter(property, position, parent, ref result);
    	return result;
    }

	#endregion

	#region Deleted(ElementTree, XElement)'s Visit

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Deleted(XElement)"/>.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Deleted(XElement, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="DeletedCore(XElement, XElement)"/> is not executed and <see cref="Deleted(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void DeletedBefore(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);

    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="DeletedCore(XElement, XElement)"/>.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="DeletedCore(XElement, XElement)"/>.</param>
    partial void DeletedAfter(XElement property, XElement parent, ref IEnumerable<XElement> result);
    
    /// <summary>
    /// Analyzes a delete action.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Deleted(XElement, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> DeletedCore(XElement property, XElement parent)
	{
		if(parent == null)
			throw new InvalidOperationException("The parent of a modified element cannot be null.");

		switch(parent.Name.LocalName)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
			case "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>": return this.Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(property, parent);
<#
	}
 }
}
#>
            case "SingleLineCommentTrivia": return this.DeletedFromSingleLineCommentTrivia(property, parent);
            case "MultiLineCommentTrivia": return this.DeletedFromMultiLineCommentTrivia(property, parent);
			default: throw new ArgumentException($"The type {parent.Name.LocalName} has not been found.");;//return true
		}
	}		
	
    /// <summary>
    /// Analyzes a delete action.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Deleted(XElement property, XElement parent)
    {
        IEnumerable<XElement> result = new XElement[0];
    	var ignoreCore = false;
    	DeletedBefore(property, parent, ref result, ref ignoreCore);
    	if(ignoreCore) 
    		return result;
    	
    	result = this.DeletedCore(property, parent);
    	DeletedAfter(property, parent, ref result);
    	return result;
    }

	#endregion

	#region Updated(XElement, XElement)'s Visit	

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Updated(XElement, XElement)"/>.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Updated(XElement, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="UpdatedCore(XElement, XElement)"/> is not executed and <see cref="Updated(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void UpdatedBefore(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="UpdatedCore(XElement, XElement)"/>.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="UpdatedCore(XElement, XElement)"/>.</param>
    partial void UpdatedAfter(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);

	 /// <summary>
    /// Analyzes an update action.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Updated(XElement, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> UpdatedCore(XElement oldElement, XElement newElement)
    {
		if(oldElement.Parent == null)
			throw new InvalidOperationException("The parent of a modified element cannot be null.");

		switch(oldElement.Parent.Name.LocalName)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
			case "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>": return this.Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(oldElement, newElement);
<#
	}
 }
}
#>
            case "SingleLineCommentTrivia": return this.UpdatedFromSingleLineCommentTrivia(oldElement, newElement);
            case "MultiLineCommentTrivia": return this.UpdatedFromMultiLineCommentTrivia(oldElement, newElement);
			default: throw new ArgumentException($"The type {oldElement.Parent.Name.LocalName} has not been found.");;//return true
		}
	}		
	
    /// <summary>
    /// Analyzes an update action.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Updated(XElement oldElement, XElement newElement)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		UpdatedBefore(oldElement, newElement, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.UpdatedCore(oldElement, newElement);
		UpdatedAfter(oldElement, newElement, ref result);
		return result;
	}
    
    /// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Moved(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Moved(XElement, XElement, int, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="MovedCore(XElement, XElement, int, XElement)"/> is not executed and <see cref="Moved(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void MovedBefore(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="MovedCore(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="MovedCore(XElement, XElement, int, XElement)"/>.</param>
    partial void MovedAfter(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);
    
    /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Moved(XElement, XElement, int, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> MovedCore(XElement property, XElement oldParent, int position, XElement newParent)
    {
		if(oldParent == null)
			throw new InvalidOperationException("The parent of a modified element cannot be null.");

		switch(oldParent.Name.LocalName)
		{
<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
	//manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

	if(xSyntaxNodeType != null && !isAbstract)
	{
#>
			case "<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>": return this.Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(property, oldParent, position, newParent);
<#
	}
 }
}
#>
            case "SingleLineCommentTrivia": return this.MovedFromSingleLineCommentTrivia(property, oldParent, position, newParent);
            case "MultiLineCommentTrivia": return this.MovedFromMultiLineCommentTrivia(property, oldParent, position, newParent);
			default: throw new ArgumentException($"The type {oldParent.Name.LocalName} has not been found.");//return true
		}
	}		
    
    /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Moved(XElement property, XElement oldParent, int position, XElement newParent)
    {
        IEnumerable<XElement> result = null;
        var ignoreCore = false;
        MovedBefore(property, oldParent, position, newParent, ref result, ref ignoreCore);
        if(ignoreCore) 
            return result;
        
        result = this.MovedCore(property, oldParent, position, newParent);
        MovedAfter(property, oldParent, position, newParent, ref result);
        return result;
    }

	#endregion

<#

foreach(ITree syntaxNode in syntaxSystemRoot.PostOrder<ITree>(e => e.Children)
.Where(n => !object.Equals(n.Root.Label, "SyntaxNode") && 
            !object.Equals(n.Root.Label, "CSharpSyntaxNode")))
{
    //manager.StartNewFile(syntaxNode.Root.Label + ".cs");

	var xSyntaxNodeType = xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == syntaxNode.Root.Label.ToString());
	if(xSyntaxNodeType == null) continue;
	var xSyntaxNodeBaseType = xSyntaxNodeType != null && xSyntaxNodeType.@base != null ?
	 xSyntaxTypeSystem.Nodes.Type.SingleOrDefault(n => n.name == xSyntaxNodeType.@base) 
	 : null;

	var isAbstract = xSyntaxNodeType.@abstract;
	
	var isUpdatable = false;
	if(xSyntaxNodeType != null && xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null)
		isUpdatable = xSyntaxNodeType.Properties.Property.Any(p => p.changepoint);

	if(xSyntaxNodeType != null)
    {
		var xSyntaxNodeBaseTypeProperties = xSyntaxNodeBaseType != null && xSyntaxNodeBaseType.Properties != null 
											&& xSyntaxNodeBaseType.Properties.Property != null 
				? xSyntaxNodeBaseType.Properties.Property
				: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var xSyntaxNodeProperties = xSyntaxNodeType.Properties != null && xSyntaxNodeType.Properties.Property != null 
			? xSyntaxNodeType.Properties.Property
			: new Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType[0];

		var currentType = typeof(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
			.Assembly.GetType("Microsoft.CodeAnalysis.CSharp.Syntax." + code.Escape(syntaxNode.Root.Label.ToString()));
		var currentPropertiesMetadata = currentType.GetMembers().OfType<PropertyInfo>()
			.Where(p => xSyntaxNodeProperties.Any(n => n.name == p.Name))
			.Select(p => new Tuple<PropertyInfo, Syntax.NodesLocalType.TypeLocalType.PropertiesLocalType.PropertyLocalType>(p, xSyntaxNodeProperties.Single(n => n.name == p.Name)))
			.OrderBy(p => p.Item2.index)
			.ToArray();

	if(xSyntaxNodeType != null && !isAbstract)
	{
		var filterOutTheseProperties = currentPropertiesMetadata
			.Where(p => !(p.Item2.Rules?.Topology?.relevant ?? false))
			.Select(p => p.Item2.name).ToArray();
#>
	#region <#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, int, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, int, XElement)"/> is not executed and <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(XElement property, int position, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, int, XElement)"/>.</param>
    partial void Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(XElement property, int position, XElement parent, ref IEnumerable<XElement> result);

	/// <summary>
    /// Analyzes an insert action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, int, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement property, int position, XElement parent)
    {
		if(property == null)
			throw new ArgumentNullException(nameof(property));

<#
		if(!filterOutTheseProperties.Any())
		{
#>		yield break;
<#
		}
		else
		{
#>
		XElement firstAction = null, secondAction = null;
<#
			foreach(var p in filterOutTheseProperties)
			{
#>		if(property.Attribute("part")?.Value == "<#= p #>")
		{
			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Insert", "Insert", ref firstAction, ref secondAction))
			{
				yield return imprecision;
			}
		}
<#
			}
#>		
		yield break;
<#
		}
#>
    }	
	
    /// <summary>
    /// Analyzes an insert action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where insert the property element in.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement property, int position, XElement parent)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(property, position, parent, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(property, position, parent);
		Inserted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(property, position, parent, ref result);
		return result;
	}

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/> is not executed and <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(XElement property, XElement parent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/>.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/>.</param>
    partial void Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(XElement property, XElement parent, ref IEnumerable<XElement> result);

	 /// <summary>
    /// Analyzes a delete action.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement property, XElement parent)
    {
		if(property == null)
			throw new ArgumentNullException(nameof(property));

<#
		if(!filterOutTheseProperties.Any())
		{
#>		yield break;
<#
		}
		else
		{
#>
		XElement firstAction = null, secondAction = null;
<#
			foreach(var p in filterOutTheseProperties)
			{
#>		if(property.Attribute("part")?.Value == "<#= p #>")
		{
			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
			{
				yield return imprecision;
			}
		}
<#
			}
#>		
		yield break;
<#
		}
#>
    }	
	
    /// <summary>
    /// Analyzes a delete action.
    /// </summary>
    /// <param name="property">deleted element.</param>
    /// <param name="parent">parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement property, XElement parent)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(property, parent, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(property, parent);
		Deleted<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(property, parent, ref result);
		return result;
	}

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/> is not executed and <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/>.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement)"/>.</param>
    partial void Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(XElement oldElement, XElement newElement, ref IEnumerable<XElement> result);

	 /// <summary>
    /// Analyzes an update action.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement oldElement, XElement newElement)
    {
		if(oldElement == null) throw new ArgumentNullException(nameof(oldElement));
		if(newElement == null) throw new ArgumentNullException(nameof(newElement));

<#
		if(!filterOutTheseProperties.Any())
		{
#>		yield break;
<#
		}
		else
		{
#>
		XElement firstAction = null, secondAction = null;
<#
			foreach(var p in filterOutTheseProperties)
			{
#>		if(oldElement.Attribute("part")?.Value == "<#= p #>")
		{
			foreach(var imprecision in this.FirstActionIffSecondAction(oldElement, oldElement.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
			{
				yield return imprecision;
			}
		}
<#
			}
#>		
		yield break;
<#
		}
#>
    }	
	
     /// <summary>
    /// Analyzes an update action.
    /// </summary>
    /// <param name="oldElement">original element.</param>
    /// <param name="newElement">modified element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement oldElement, XElement newElement)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(oldElement, newElement, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(oldElement, newElement);
		Updated<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(oldElement, newElement, ref result);
		return result;
	}

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/> is not executed and <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/>.</param>
    partial void Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);

	 /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement property, XElement oldParent, int position, XElement newParent)
    {
		if(property == null)
			throw new ArgumentNullException(nameof(property));

<#
		if(!filterOutTheseProperties.Any())
		{
#>		yield break;
<#
		}
		else
		{
#>
		XElement firstAction = null, secondAction = null;
<#
			foreach(var p in filterOutTheseProperties)
			{
#>		if(property.Attribute("part")?.Value == "<#= p #>")
		{
			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
			{
				yield return imprecision;
			}
		}
<#
			}
#>		
		yield break;
<#
		}
#>
    }	
	
    /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement property, XElement oldParent, int position, XElement newParent)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(property, oldParent, position, newParent, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(property, oldParent, position, newParent);
		Moved<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(property, oldParent, position, newParent, ref result);
		return result;
	}

	/// <summary>
    /// Method hook for implementing logic to execute before the <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.</param>
    /// <param name="ignoreCore">If true, the <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/> is not executed and <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/> returns the current value of <paramref name="result"/>.</param>
    partial void Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
    /// <summary>
    /// Method hook for implementing logic to execute after the <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/>.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <param name="result">Mechanism to modify the result of <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement, XElement, int, XElement)"/>.</param>
    partial void Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(XElement property, XElement oldParent, int position, XElement newParent, ref IEnumerable<XElement> result);

	 /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    /// <remarks>This is the default implementation for <see cref="Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement, XElement, int, XElement)"/>.</remarks>
    public virtual IEnumerable<XElement> Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(XElement property, XElement oldParent, int position, XElement newParent)
    {
		if(property == null)
			throw new ArgumentNullException(nameof(property));

<#
		if(!filterOutTheseProperties.Any())
		{
#>		yield break;
<#
		}
		else
		{
#>
		XElement firstAction = null, secondAction = null;
<#
			foreach(var p in filterOutTheseProperties)
			{
#>		if(property.Attribute("part")?.Value == "<#= p #>")
		{
			foreach(var imprecision in this.FirstActionIffSecondAction(property, property.Parent, "Delete", "Delete", ref firstAction, ref secondAction))
			{
				yield return imprecision;
			}
		}
<#
			}
#>		
		yield break;
<#
		}
#>
    }	
	
    /// <summary>
    /// Analyzes a move action.
    /// </summary>
    /// <param name="property">property element.</param>
    /// <param name="position">position where the property would move.</param>
    /// <param name="oldParent">original parent element.</param>
    /// <param name="newParent">modified parent element.</param>
    /// <returns>the imprecisions supposedly detected.</returns>
    public virtual IEnumerable<XElement> Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>(XElement property, XElement oldParent, int position, XElement newParent)
	{
		IEnumerable<XElement> result = null;
		var ignoreCore = false;
		Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Before(property, oldParent, position, newParent, ref result, ref ignoreCore);
		if(ignoreCore) 
			return result;
		
		result = this.Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>Core(property, oldParent, position, newParent);
		Matched<#= code.Escape(syntaxNode.Root.Label.ToString()).Replace("Syntax", "") #>After(property, oldParent, position, newParent, ref result);
		return result;
	}

	#endregion

<#
	}
 }
}
#>
}
<#
	
EndNamespace(namespaceName);

manager.Process();
#>
<#+ 
void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

string GetSyntaxType(Type t, CodeGenerationTools code, string listTypeArgument)
{
	if(t.FullName.StartsWith("Microsoft.CodeAnalysis.SeparatedSyntaxList"))
		return "SeparatedList_of_" + listTypeArgument;

	if(t.FullName.StartsWith("Microsoft.CodeAnalysis.SyntaxList"))
		return "List_of_" + listTypeArgument;

	if(t.FullName.StartsWith("Microsoft.CodeAnalysis.SyntaxTokenList"))
		return "TokenList";

	if(!t.FullName.StartsWith("Microsoft.CodeAnalysis."))
		return t.Name;

	if(t.Name == "SyntaxList`1" /*|| t.Name == "SeparatedSyntaxList`1"*/)
		return "IEnumerable<" + this.GetSyntaxType(t.GenericTypeArguments[0], code, "") + ">";

	var codeAnalysisTypes = new []{ "SyntaxNode"/*, "SyntaxTokenList"*/, "SyntaxTrivia" };
	return codeAnalysisTypes.Contains(t.Name) ? "Microsoft.CodeAnalysis." + code.Escape(t.Name) : code.Escape(t.Name) + "<TAnnotation>";
}
#>
