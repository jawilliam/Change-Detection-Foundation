
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Jawilliam.CDF.CSharp.RoslynML
{
    partial class DeltaExpander
    {
    	#region UnmatchedModified(XElement)'s Visit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModified(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModified(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCore(XElement)"/> is not executed and <see cref="UnmatchedModified(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModified(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCore(XElement mFullElement)
    	{
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    		switch(mFullElement.Name.LocalName)
    		{
    			case "AttributeArgument": return this.UnmatchedModifiedAttributeArgument(mFullElement);
    			case "NameEquals": return this.UnmatchedModifiedNameEquals(mFullElement);
    			case "TypeParameterList": return this.UnmatchedModifiedTypeParameterList(mFullElement);
    			case "TypeParameter": return this.UnmatchedModifiedTypeParameter(mFullElement);
    			case "BaseList": return this.UnmatchedModifiedBaseList(mFullElement);
    			case "TypeParameterConstraintClause": return this.UnmatchedModifiedTypeParameterConstraintClause(mFullElement);
    			case "ExplicitInterfaceSpecifier": return this.UnmatchedModifiedExplicitInterfaceSpecifier(mFullElement);
    			case "ConstructorInitializer": return this.UnmatchedModifiedConstructorInitializer(mFullElement);
    			case "ArrowExpressionClause": return this.UnmatchedModifiedArrowExpressionClause(mFullElement);
    			case "AccessorList": return this.UnmatchedModifiedAccessorList(mFullElement);
    			case "AccessorDeclaration": return this.UnmatchedModifiedAccessorDeclaration(mFullElement);
    			case "Parameter": return this.UnmatchedModifiedParameter(mFullElement);
    			case "CrefParameter": return this.UnmatchedModifiedCrefParameter(mFullElement);
    			case "XmlElementStartTag": return this.UnmatchedModifiedXmlElementStartTag(mFullElement);
    			case "XmlElementEndTag": return this.UnmatchedModifiedXmlElementEndTag(mFullElement);
    			case "XmlName": return this.UnmatchedModifiedXmlName(mFullElement);
    			case "XmlPrefix": return this.UnmatchedModifiedXmlPrefix(mFullElement);
    			case "TypeArgumentList": return this.UnmatchedModifiedTypeArgumentList(mFullElement);
    			case "ArrayRankSpecifier": return this.UnmatchedModifiedArrayRankSpecifier(mFullElement);
    			case "TupleElement": return this.UnmatchedModifiedTupleElement(mFullElement);
    			case "Argument": return this.UnmatchedModifiedArgument(mFullElement);
    			case "NameColon": return this.UnmatchedModifiedNameColon(mFullElement);
    			case "AnonymousObjectMemberDeclarator": return this.UnmatchedModifiedAnonymousObjectMemberDeclarator(mFullElement);
    			case "QueryBody": return this.UnmatchedModifiedQueryBody(mFullElement);
    			case "JoinIntoClause": return this.UnmatchedModifiedJoinIntoClause(mFullElement);
    			case "Ordering": return this.UnmatchedModifiedOrdering(mFullElement);
    			case "QueryContinuation": return this.UnmatchedModifiedQueryContinuation(mFullElement);
    			case "WhenClause": return this.UnmatchedModifiedWhenClause(mFullElement);
    			case "InterpolationAlignmentClause": return this.UnmatchedModifiedInterpolationAlignmentClause(mFullElement);
    			case "InterpolationFormatClause": return this.UnmatchedModifiedInterpolationFormatClause(mFullElement);
    			case "VariableDeclaration": return this.UnmatchedModifiedVariableDeclaration(mFullElement);
    			case "VariableDeclarator": return this.UnmatchedModifiedVariableDeclarator(mFullElement);
    			case "EqualsValueClause": return this.UnmatchedModifiedEqualsValueClause(mFullElement);
    			case "ElseClause": return this.UnmatchedModifiedElseClause(mFullElement);
    			case "SwitchSection": return this.UnmatchedModifiedSwitchSection(mFullElement);
    			case "CatchClause": return this.UnmatchedModifiedCatchClause(mFullElement);
    			case "CatchDeclaration": return this.UnmatchedModifiedCatchDeclaration(mFullElement);
    			case "CatchFilterClause": return this.UnmatchedModifiedCatchFilterClause(mFullElement);
    			case "FinallyClause": return this.UnmatchedModifiedFinallyClause(mFullElement);
    			case "CompilationUnit": return this.UnmatchedModifiedCompilationUnit(mFullElement);
    			case "ExternAliasDirective": return this.UnmatchedModifiedExternAliasDirective(mFullElement);
    			case "UsingDirective": return this.UnmatchedModifiedUsingDirective(mFullElement);
    			case "AttributeList": return this.UnmatchedModifiedAttributeList(mFullElement);
    			case "AttributeTargetSpecifier": return this.UnmatchedModifiedAttributeTargetSpecifier(mFullElement);
    			case "Attribute": return this.UnmatchedModifiedAttribute(mFullElement);
    			case "AttributeArgumentList": return this.UnmatchedModifiedAttributeArgumentList(mFullElement);
    			case "DelegateDeclaration": return this.UnmatchedModifiedDelegateDeclaration(mFullElement);
    			case "EnumMemberDeclaration": return this.UnmatchedModifiedEnumMemberDeclaration(mFullElement);
    			case "IncompleteMember": return this.UnmatchedModifiedIncompleteMember(mFullElement);
    			case "GlobalStatement": return this.UnmatchedModifiedGlobalStatement(mFullElement);
    			case "NamespaceDeclaration": return this.UnmatchedModifiedNamespaceDeclaration(mFullElement);
    			case "EnumDeclaration": return this.UnmatchedModifiedEnumDeclaration(mFullElement);
    			case "ClassDeclaration": return this.UnmatchedModifiedClassDeclaration(mFullElement);
    			case "StructDeclaration": return this.UnmatchedModifiedStructDeclaration(mFullElement);
    			case "InterfaceDeclaration": return this.UnmatchedModifiedInterfaceDeclaration(mFullElement);
    			case "FieldDeclaration": return this.UnmatchedModifiedFieldDeclaration(mFullElement);
    			case "EventFieldDeclaration": return this.UnmatchedModifiedEventFieldDeclaration(mFullElement);
    			case "MethodDeclaration": return this.UnmatchedModifiedMethodDeclaration(mFullElement);
    			case "OperatorDeclaration": return this.UnmatchedModifiedOperatorDeclaration(mFullElement);
    			case "ConversionOperatorDeclaration": return this.UnmatchedModifiedConversionOperatorDeclaration(mFullElement);
    			case "ConstructorDeclaration": return this.UnmatchedModifiedConstructorDeclaration(mFullElement);
    			case "DestructorDeclaration": return this.UnmatchedModifiedDestructorDeclaration(mFullElement);
    			case "PropertyDeclaration": return this.UnmatchedModifiedPropertyDeclaration(mFullElement);
    			case "EventDeclaration": return this.UnmatchedModifiedEventDeclaration(mFullElement);
    			case "IndexerDeclaration": return this.UnmatchedModifiedIndexerDeclaration(mFullElement);
    			case "SimpleBaseType": return this.UnmatchedModifiedSimpleBaseType(mFullElement);
    			case "ConstructorConstraint": return this.UnmatchedModifiedConstructorConstraint(mFullElement);
    			case "ClassOrStructConstraint": return this.UnmatchedModifiedClassOrStructConstraint(mFullElement);
    			case "TypeConstraint": return this.UnmatchedModifiedTypeConstraint(mFullElement);
    			case "ParameterList": return this.UnmatchedModifiedParameterList(mFullElement);
    			case "BracketedParameterList": return this.UnmatchedModifiedBracketedParameterList(mFullElement);
    			case "SkippedTokensTrivia": return this.UnmatchedModifiedSkippedTokensTrivia(mFullElement);
    			case "DocumentationCommentTrivia": return this.UnmatchedModifiedDocumentationCommentTrivia(mFullElement);
    			case "EndIfDirectiveTrivia": return this.UnmatchedModifiedEndIfDirectiveTrivia(mFullElement);
    			case "RegionDirectiveTrivia": return this.UnmatchedModifiedRegionDirectiveTrivia(mFullElement);
    			case "EndRegionDirectiveTrivia": return this.UnmatchedModifiedEndRegionDirectiveTrivia(mFullElement);
    			case "ErrorDirectiveTrivia": return this.UnmatchedModifiedErrorDirectiveTrivia(mFullElement);
    			case "WarningDirectiveTrivia": return this.UnmatchedModifiedWarningDirectiveTrivia(mFullElement);
    			case "BadDirectiveTrivia": return this.UnmatchedModifiedBadDirectiveTrivia(mFullElement);
    			case "DefineDirectiveTrivia": return this.UnmatchedModifiedDefineDirectiveTrivia(mFullElement);
    			case "UndefDirectiveTrivia": return this.UnmatchedModifiedUndefDirectiveTrivia(mFullElement);
    			case "LineDirectiveTrivia": return this.UnmatchedModifiedLineDirectiveTrivia(mFullElement);
    			case "PragmaWarningDirectiveTrivia": return this.UnmatchedModifiedPragmaWarningDirectiveTrivia(mFullElement);
    			case "PragmaChecksumDirectiveTrivia": return this.UnmatchedModifiedPragmaChecksumDirectiveTrivia(mFullElement);
    			case "ReferenceDirectiveTrivia": return this.UnmatchedModifiedReferenceDirectiveTrivia(mFullElement);
    			case "LoadDirectiveTrivia": return this.UnmatchedModifiedLoadDirectiveTrivia(mFullElement);
    			case "ShebangDirectiveTrivia": return this.UnmatchedModifiedShebangDirectiveTrivia(mFullElement);
    			case "ElseDirectiveTrivia": return this.UnmatchedModifiedElseDirectiveTrivia(mFullElement);
    			case "IfDirectiveTrivia": return this.UnmatchedModifiedIfDirectiveTrivia(mFullElement);
    			case "ElifDirectiveTrivia": return this.UnmatchedModifiedElifDirectiveTrivia(mFullElement);
    			case "TypeCref": return this.UnmatchedModifiedTypeCref(mFullElement);
    			case "QualifiedCref": return this.UnmatchedModifiedQualifiedCref(mFullElement);
    			case "NameMemberCref": return this.UnmatchedModifiedNameMemberCref(mFullElement);
    			case "IndexerMemberCref": return this.UnmatchedModifiedIndexerMemberCref(mFullElement);
    			case "OperatorMemberCref": return this.UnmatchedModifiedOperatorMemberCref(mFullElement);
    			case "ConversionOperatorMemberCref": return this.UnmatchedModifiedConversionOperatorMemberCref(mFullElement);
    			case "CrefParameterList": return this.UnmatchedModifiedCrefParameterList(mFullElement);
    			case "CrefBracketedParameterList": return this.UnmatchedModifiedCrefBracketedParameterList(mFullElement);
    			case "XmlElement": return this.UnmatchedModifiedXmlElement(mFullElement);
    			case "XmlEmptyElement": return this.UnmatchedModifiedXmlEmptyElement(mFullElement);
    			case "XmlText": return this.UnmatchedModifiedXmlText(mFullElement);
    			case "XmlCDataSection": return this.UnmatchedModifiedXmlCDataSection(mFullElement);
    			case "XmlProcessingInstruction": return this.UnmatchedModifiedXmlProcessingInstruction(mFullElement);
    			case "XmlComment": return this.UnmatchedModifiedXmlComment(mFullElement);
    			case "XmlTextAttribute": return this.UnmatchedModifiedXmlTextAttribute(mFullElement);
    			case "XmlCrefAttribute": return this.UnmatchedModifiedXmlCrefAttribute(mFullElement);
    			case "XmlNameAttribute": return this.UnmatchedModifiedXmlNameAttribute(mFullElement);
    			case "ParenthesizedExpression": return this.UnmatchedModifiedParenthesizedExpression(mFullElement);
    			case "TupleExpression": return this.UnmatchedModifiedTupleExpression(mFullElement);
    			case "PrefixUnaryExpression": return this.UnmatchedModifiedPrefixUnaryExpression(mFullElement);
    			case "AwaitExpression": return this.UnmatchedModifiedAwaitExpression(mFullElement);
    			case "PostfixUnaryExpression": return this.UnmatchedModifiedPostfixUnaryExpression(mFullElement);
    			case "MemberAccessExpression": return this.UnmatchedModifiedMemberAccessExpression(mFullElement);
    			case "ConditionalAccessExpression": return this.UnmatchedModifiedConditionalAccessExpression(mFullElement);
    			case "MemberBindingExpression": return this.UnmatchedModifiedMemberBindingExpression(mFullElement);
    			case "ElementBindingExpression": return this.UnmatchedModifiedElementBindingExpression(mFullElement);
    			case "ImplicitElementAccess": return this.UnmatchedModifiedImplicitElementAccess(mFullElement);
    			case "BinaryExpression": return this.UnmatchedModifiedBinaryExpression(mFullElement);
    			case "AssignmentExpression": return this.UnmatchedModifiedAssignmentExpression(mFullElement);
    			case "ConditionalExpression": return this.UnmatchedModifiedConditionalExpression(mFullElement);
    			case "LiteralExpression": return this.UnmatchedModifiedLiteralExpression(mFullElement);
    			case "MakeRefExpression": return this.UnmatchedModifiedMakeRefExpression(mFullElement);
    			case "RefTypeExpression": return this.UnmatchedModifiedRefTypeExpression(mFullElement);
    			case "RefValueExpression": return this.UnmatchedModifiedRefValueExpression(mFullElement);
    			case "CheckedExpression": return this.UnmatchedModifiedCheckedExpression(mFullElement);
    			case "DefaultExpression": return this.UnmatchedModifiedDefaultExpression(mFullElement);
    			case "TypeOfExpression": return this.UnmatchedModifiedTypeOfExpression(mFullElement);
    			case "SizeOfExpression": return this.UnmatchedModifiedSizeOfExpression(mFullElement);
    			case "InvocationExpression": return this.UnmatchedModifiedInvocationExpression(mFullElement);
    			case "ElementAccessExpression": return this.UnmatchedModifiedElementAccessExpression(mFullElement);
    			case "DeclarationExpression": return this.UnmatchedModifiedDeclarationExpression(mFullElement);
    			case "CastExpression": return this.UnmatchedModifiedCastExpression(mFullElement);
    			case "RefExpression": return this.UnmatchedModifiedRefExpression(mFullElement);
    			case "InitializerExpression": return this.UnmatchedModifiedInitializerExpression(mFullElement);
    			case "ObjectCreationExpression": return this.UnmatchedModifiedObjectCreationExpression(mFullElement);
    			case "AnonymousObjectCreationExpression": return this.UnmatchedModifiedAnonymousObjectCreationExpression(mFullElement);
    			case "ArrayCreationExpression": return this.UnmatchedModifiedArrayCreationExpression(mFullElement);
    			case "ImplicitArrayCreationExpression": return this.UnmatchedModifiedImplicitArrayCreationExpression(mFullElement);
    			case "StackAllocArrayCreationExpression": return this.UnmatchedModifiedStackAllocArrayCreationExpression(mFullElement);
    			case "QueryExpression": return this.UnmatchedModifiedQueryExpression(mFullElement);
    			case "OmittedArraySizeExpression": return this.UnmatchedModifiedOmittedArraySizeExpression(mFullElement);
    			case "InterpolatedStringExpression": return this.UnmatchedModifiedInterpolatedStringExpression(mFullElement);
    			case "IsPatternExpression": return this.UnmatchedModifiedIsPatternExpression(mFullElement);
    			case "ThrowExpression": return this.UnmatchedModifiedThrowExpression(mFullElement);
    			case "PredefinedType": return this.UnmatchedModifiedPredefinedType(mFullElement);
    			case "ArrayType": return this.UnmatchedModifiedArrayType(mFullElement);
    			case "PointerType": return this.UnmatchedModifiedPointerType(mFullElement);
    			case "NullableType": return this.UnmatchedModifiedNullableType(mFullElement);
    			case "TupleType": return this.UnmatchedModifiedTupleType(mFullElement);
    			case "OmittedTypeArgument": return this.UnmatchedModifiedOmittedTypeArgument(mFullElement);
    			case "RefType": return this.UnmatchedModifiedRefType(mFullElement);
    			case "QualifiedName": return this.UnmatchedModifiedQualifiedName(mFullElement);
    			case "AliasQualifiedName": return this.UnmatchedModifiedAliasQualifiedName(mFullElement);
    			case "IdentifierName": return this.UnmatchedModifiedIdentifierName(mFullElement);
    			case "GenericName": return this.UnmatchedModifiedGenericName(mFullElement);
    			case "ThisExpression": return this.UnmatchedModifiedThisExpression(mFullElement);
    			case "BaseExpression": return this.UnmatchedModifiedBaseExpression(mFullElement);
    			case "AnonymousMethodExpression": return this.UnmatchedModifiedAnonymousMethodExpression(mFullElement);
    			case "SimpleLambdaExpression": return this.UnmatchedModifiedSimpleLambdaExpression(mFullElement);
    			case "ParenthesizedLambdaExpression": return this.UnmatchedModifiedParenthesizedLambdaExpression(mFullElement);
    			case "ArgumentList": return this.UnmatchedModifiedArgumentList(mFullElement);
    			case "BracketedArgumentList": return this.UnmatchedModifiedBracketedArgumentList(mFullElement);
    			case "FromClause": return this.UnmatchedModifiedFromClause(mFullElement);
    			case "LetClause": return this.UnmatchedModifiedLetClause(mFullElement);
    			case "JoinClause": return this.UnmatchedModifiedJoinClause(mFullElement);
    			case "WhereClause": return this.UnmatchedModifiedWhereClause(mFullElement);
    			case "OrderByClause": return this.UnmatchedModifiedOrderByClause(mFullElement);
    			case "SelectClause": return this.UnmatchedModifiedSelectClause(mFullElement);
    			case "GroupClause": return this.UnmatchedModifiedGroupClause(mFullElement);
    			case "DeclarationPattern": return this.UnmatchedModifiedDeclarationPattern(mFullElement);
    			case "ConstantPattern": return this.UnmatchedModifiedConstantPattern(mFullElement);
    			case "InterpolatedStringText": return this.UnmatchedModifiedInterpolatedStringText(mFullElement);
    			case "Interpolation": return this.UnmatchedModifiedInterpolation(mFullElement);
    			case "Block": return this.UnmatchedModifiedBlock(mFullElement);
    			case "LocalFunctionStatement": return this.UnmatchedModifiedLocalFunctionStatement(mFullElement);
    			case "LocalDeclarationStatement": return this.UnmatchedModifiedLocalDeclarationStatement(mFullElement);
    			case "ExpressionStatement": return this.UnmatchedModifiedExpressionStatement(mFullElement);
    			case "EmptyStatement": return this.UnmatchedModifiedEmptyStatement(mFullElement);
    			case "LabeledStatement": return this.UnmatchedModifiedLabeledStatement(mFullElement);
    			case "GotoStatement": return this.UnmatchedModifiedGotoStatement(mFullElement);
    			case "BreakStatement": return this.UnmatchedModifiedBreakStatement(mFullElement);
    			case "ContinueStatement": return this.UnmatchedModifiedContinueStatement(mFullElement);
    			case "ReturnStatement": return this.UnmatchedModifiedReturnStatement(mFullElement);
    			case "ThrowStatement": return this.UnmatchedModifiedThrowStatement(mFullElement);
    			case "YieldStatement": return this.UnmatchedModifiedYieldStatement(mFullElement);
    			case "WhileStatement": return this.UnmatchedModifiedWhileStatement(mFullElement);
    			case "DoStatement": return this.UnmatchedModifiedDoStatement(mFullElement);
    			case "ForStatement": return this.UnmatchedModifiedForStatement(mFullElement);
    			case "UsingStatement": return this.UnmatchedModifiedUsingStatement(mFullElement);
    			case "FixedStatement": return this.UnmatchedModifiedFixedStatement(mFullElement);
    			case "CheckedStatement": return this.UnmatchedModifiedCheckedStatement(mFullElement);
    			case "UnsafeStatement": return this.UnmatchedModifiedUnsafeStatement(mFullElement);
    			case "LockStatement": return this.UnmatchedModifiedLockStatement(mFullElement);
    			case "IfStatement": return this.UnmatchedModifiedIfStatement(mFullElement);
    			case "SwitchStatement": return this.UnmatchedModifiedSwitchStatement(mFullElement);
    			case "TryStatement": return this.UnmatchedModifiedTryStatement(mFullElement);
    			case "ForEachStatement": return this.UnmatchedModifiedForEachStatement(mFullElement);
    			case "ForEachVariableStatement": return this.UnmatchedModifiedForEachVariableStatement(mFullElement);
    			case "SingleVariableDesignation": return this.UnmatchedModifiedSingleVariableDesignation(mFullElement);
    			case "DiscardDesignation": return this.UnmatchedModifiedDiscardDesignation(mFullElement);
    			case "ParenthesizedVariableDesignation": return this.UnmatchedModifiedParenthesizedVariableDesignation(mFullElement);
    			case "CasePatternSwitchLabel": return this.UnmatchedModifiedCasePatternSwitchLabel(mFullElement);
    			case "CaseSwitchLabel": return this.UnmatchedModifiedCaseSwitchLabel(mFullElement);
    			case "DefaultSwitchLabel": return this.UnmatchedModifiedDefaultSwitchLabel(mFullElement);
    			default: throw new ArgumentException($"The type {mFullElement.Name.LocalName} has not been found.");;//return true
    		}
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModified(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCore(mFullElement);
        	UnmatchedModifiedAfter(mFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Matched(XElement)'s Visit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="Matched(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="Matched(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCore(XElement, XElement)"/> is not executed and <see cref="Matched(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCore(XElement, XElement)"/>.</param>
        partial void MatchedAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="Matched(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		switch(oFullElement.Name.LocalName)
    		{
    			case "AttributeArgument": return this.MatchedAttributeArgument(oFullElement, mFullElement);
    			case "NameEquals": return this.MatchedNameEquals(oFullElement, mFullElement);
    			case "TypeParameterList": return this.MatchedTypeParameterList(oFullElement, mFullElement);
    			case "TypeParameter": return this.MatchedTypeParameter(oFullElement, mFullElement);
    			case "BaseList": return this.MatchedBaseList(oFullElement, mFullElement);
    			case "TypeParameterConstraintClause": return this.MatchedTypeParameterConstraintClause(oFullElement, mFullElement);
    			case "ExplicitInterfaceSpecifier": return this.MatchedExplicitInterfaceSpecifier(oFullElement, mFullElement);
    			case "ConstructorInitializer": return this.MatchedConstructorInitializer(oFullElement, mFullElement);
    			case "ArrowExpressionClause": return this.MatchedArrowExpressionClause(oFullElement, mFullElement);
    			case "AccessorList": return this.MatchedAccessorList(oFullElement, mFullElement);
    			case "AccessorDeclaration": return this.MatchedAccessorDeclaration(oFullElement, mFullElement);
    			case "Parameter": return this.MatchedParameter(oFullElement, mFullElement);
    			case "CrefParameter": return this.MatchedCrefParameter(oFullElement, mFullElement);
    			case "XmlElementStartTag": return this.MatchedXmlElementStartTag(oFullElement, mFullElement);
    			case "XmlElementEndTag": return this.MatchedXmlElementEndTag(oFullElement, mFullElement);
    			case "XmlName": return this.MatchedXmlName(oFullElement, mFullElement);
    			case "XmlPrefix": return this.MatchedXmlPrefix(oFullElement, mFullElement);
    			case "TypeArgumentList": return this.MatchedTypeArgumentList(oFullElement, mFullElement);
    			case "ArrayRankSpecifier": return this.MatchedArrayRankSpecifier(oFullElement, mFullElement);
    			case "TupleElement": return this.MatchedTupleElement(oFullElement, mFullElement);
    			case "Argument": return this.MatchedArgument(oFullElement, mFullElement);
    			case "NameColon": return this.MatchedNameColon(oFullElement, mFullElement);
    			case "AnonymousObjectMemberDeclarator": return this.MatchedAnonymousObjectMemberDeclarator(oFullElement, mFullElement);
    			case "QueryBody": return this.MatchedQueryBody(oFullElement, mFullElement);
    			case "JoinIntoClause": return this.MatchedJoinIntoClause(oFullElement, mFullElement);
    			case "Ordering": return this.MatchedOrdering(oFullElement, mFullElement);
    			case "QueryContinuation": return this.MatchedQueryContinuation(oFullElement, mFullElement);
    			case "WhenClause": return this.MatchedWhenClause(oFullElement, mFullElement);
    			case "InterpolationAlignmentClause": return this.MatchedInterpolationAlignmentClause(oFullElement, mFullElement);
    			case "InterpolationFormatClause": return this.MatchedInterpolationFormatClause(oFullElement, mFullElement);
    			case "VariableDeclaration": return this.MatchedVariableDeclaration(oFullElement, mFullElement);
    			case "VariableDeclarator": return this.MatchedVariableDeclarator(oFullElement, mFullElement);
    			case "EqualsValueClause": return this.MatchedEqualsValueClause(oFullElement, mFullElement);
    			case "ElseClause": return this.MatchedElseClause(oFullElement, mFullElement);
    			case "SwitchSection": return this.MatchedSwitchSection(oFullElement, mFullElement);
    			case "CatchClause": return this.MatchedCatchClause(oFullElement, mFullElement);
    			case "CatchDeclaration": return this.MatchedCatchDeclaration(oFullElement, mFullElement);
    			case "CatchFilterClause": return this.MatchedCatchFilterClause(oFullElement, mFullElement);
    			case "FinallyClause": return this.MatchedFinallyClause(oFullElement, mFullElement);
    			case "CompilationUnit": return this.MatchedCompilationUnit(oFullElement, mFullElement);
    			case "ExternAliasDirective": return this.MatchedExternAliasDirective(oFullElement, mFullElement);
    			case "UsingDirective": return this.MatchedUsingDirective(oFullElement, mFullElement);
    			case "AttributeList": return this.MatchedAttributeList(oFullElement, mFullElement);
    			case "AttributeTargetSpecifier": return this.MatchedAttributeTargetSpecifier(oFullElement, mFullElement);
    			case "Attribute": return this.MatchedAttribute(oFullElement, mFullElement);
    			case "AttributeArgumentList": return this.MatchedAttributeArgumentList(oFullElement, mFullElement);
    			case "DelegateDeclaration": return this.MatchedDelegateDeclaration(oFullElement, mFullElement);
    			case "EnumMemberDeclaration": return this.MatchedEnumMemberDeclaration(oFullElement, mFullElement);
    			case "IncompleteMember": return this.MatchedIncompleteMember(oFullElement, mFullElement);
    			case "GlobalStatement": return this.MatchedGlobalStatement(oFullElement, mFullElement);
    			case "NamespaceDeclaration": return this.MatchedNamespaceDeclaration(oFullElement, mFullElement);
    			case "EnumDeclaration": return this.MatchedEnumDeclaration(oFullElement, mFullElement);
    			case "ClassDeclaration": return this.MatchedClassDeclaration(oFullElement, mFullElement);
    			case "StructDeclaration": return this.MatchedStructDeclaration(oFullElement, mFullElement);
    			case "InterfaceDeclaration": return this.MatchedInterfaceDeclaration(oFullElement, mFullElement);
    			case "FieldDeclaration": return this.MatchedFieldDeclaration(oFullElement, mFullElement);
    			case "EventFieldDeclaration": return this.MatchedEventFieldDeclaration(oFullElement, mFullElement);
    			case "MethodDeclaration": return this.MatchedMethodDeclaration(oFullElement, mFullElement);
    			case "OperatorDeclaration": return this.MatchedOperatorDeclaration(oFullElement, mFullElement);
    			case "ConversionOperatorDeclaration": return this.MatchedConversionOperatorDeclaration(oFullElement, mFullElement);
    			case "ConstructorDeclaration": return this.MatchedConstructorDeclaration(oFullElement, mFullElement);
    			case "DestructorDeclaration": return this.MatchedDestructorDeclaration(oFullElement, mFullElement);
    			case "PropertyDeclaration": return this.MatchedPropertyDeclaration(oFullElement, mFullElement);
    			case "EventDeclaration": return this.MatchedEventDeclaration(oFullElement, mFullElement);
    			case "IndexerDeclaration": return this.MatchedIndexerDeclaration(oFullElement, mFullElement);
    			case "SimpleBaseType": return this.MatchedSimpleBaseType(oFullElement, mFullElement);
    			case "ConstructorConstraint": return this.MatchedConstructorConstraint(oFullElement, mFullElement);
    			case "ClassOrStructConstraint": return this.MatchedClassOrStructConstraint(oFullElement, mFullElement);
    			case "TypeConstraint": return this.MatchedTypeConstraint(oFullElement, mFullElement);
    			case "ParameterList": return this.MatchedParameterList(oFullElement, mFullElement);
    			case "BracketedParameterList": return this.MatchedBracketedParameterList(oFullElement, mFullElement);
    			case "SkippedTokensTrivia": return this.MatchedSkippedTokensTrivia(oFullElement, mFullElement);
    			case "DocumentationCommentTrivia": return this.MatchedDocumentationCommentTrivia(oFullElement, mFullElement);
    			case "EndIfDirectiveTrivia": return this.MatchedEndIfDirectiveTrivia(oFullElement, mFullElement);
    			case "RegionDirectiveTrivia": return this.MatchedRegionDirectiveTrivia(oFullElement, mFullElement);
    			case "EndRegionDirectiveTrivia": return this.MatchedEndRegionDirectiveTrivia(oFullElement, mFullElement);
    			case "ErrorDirectiveTrivia": return this.MatchedErrorDirectiveTrivia(oFullElement, mFullElement);
    			case "WarningDirectiveTrivia": return this.MatchedWarningDirectiveTrivia(oFullElement, mFullElement);
    			case "BadDirectiveTrivia": return this.MatchedBadDirectiveTrivia(oFullElement, mFullElement);
    			case "DefineDirectiveTrivia": return this.MatchedDefineDirectiveTrivia(oFullElement, mFullElement);
    			case "UndefDirectiveTrivia": return this.MatchedUndefDirectiveTrivia(oFullElement, mFullElement);
    			case "LineDirectiveTrivia": return this.MatchedLineDirectiveTrivia(oFullElement, mFullElement);
    			case "PragmaWarningDirectiveTrivia": return this.MatchedPragmaWarningDirectiveTrivia(oFullElement, mFullElement);
    			case "PragmaChecksumDirectiveTrivia": return this.MatchedPragmaChecksumDirectiveTrivia(oFullElement, mFullElement);
    			case "ReferenceDirectiveTrivia": return this.MatchedReferenceDirectiveTrivia(oFullElement, mFullElement);
    			case "LoadDirectiveTrivia": return this.MatchedLoadDirectiveTrivia(oFullElement, mFullElement);
    			case "ShebangDirectiveTrivia": return this.MatchedShebangDirectiveTrivia(oFullElement, mFullElement);
    			case "ElseDirectiveTrivia": return this.MatchedElseDirectiveTrivia(oFullElement, mFullElement);
    			case "IfDirectiveTrivia": return this.MatchedIfDirectiveTrivia(oFullElement, mFullElement);
    			case "ElifDirectiveTrivia": return this.MatchedElifDirectiveTrivia(oFullElement, mFullElement);
    			case "TypeCref": return this.MatchedTypeCref(oFullElement, mFullElement);
    			case "QualifiedCref": return this.MatchedQualifiedCref(oFullElement, mFullElement);
    			case "NameMemberCref": return this.MatchedNameMemberCref(oFullElement, mFullElement);
    			case "IndexerMemberCref": return this.MatchedIndexerMemberCref(oFullElement, mFullElement);
    			case "OperatorMemberCref": return this.MatchedOperatorMemberCref(oFullElement, mFullElement);
    			case "ConversionOperatorMemberCref": return this.MatchedConversionOperatorMemberCref(oFullElement, mFullElement);
    			case "CrefParameterList": return this.MatchedCrefParameterList(oFullElement, mFullElement);
    			case "CrefBracketedParameterList": return this.MatchedCrefBracketedParameterList(oFullElement, mFullElement);
    			case "XmlElement": return this.MatchedXmlElement(oFullElement, mFullElement);
    			case "XmlEmptyElement": return this.MatchedXmlEmptyElement(oFullElement, mFullElement);
    			case "XmlText": return this.MatchedXmlText(oFullElement, mFullElement);
    			case "XmlCDataSection": return this.MatchedXmlCDataSection(oFullElement, mFullElement);
    			case "XmlProcessingInstruction": return this.MatchedXmlProcessingInstruction(oFullElement, mFullElement);
    			case "XmlComment": return this.MatchedXmlComment(oFullElement, mFullElement);
    			case "XmlTextAttribute": return this.MatchedXmlTextAttribute(oFullElement, mFullElement);
    			case "XmlCrefAttribute": return this.MatchedXmlCrefAttribute(oFullElement, mFullElement);
    			case "XmlNameAttribute": return this.MatchedXmlNameAttribute(oFullElement, mFullElement);
    			case "ParenthesizedExpression": return this.MatchedParenthesizedExpression(oFullElement, mFullElement);
    			case "TupleExpression": return this.MatchedTupleExpression(oFullElement, mFullElement);
    			case "PrefixUnaryExpression": return this.MatchedPrefixUnaryExpression(oFullElement, mFullElement);
    			case "AwaitExpression": return this.MatchedAwaitExpression(oFullElement, mFullElement);
    			case "PostfixUnaryExpression": return this.MatchedPostfixUnaryExpression(oFullElement, mFullElement);
    			case "MemberAccessExpression": return this.MatchedMemberAccessExpression(oFullElement, mFullElement);
    			case "ConditionalAccessExpression": return this.MatchedConditionalAccessExpression(oFullElement, mFullElement);
    			case "MemberBindingExpression": return this.MatchedMemberBindingExpression(oFullElement, mFullElement);
    			case "ElementBindingExpression": return this.MatchedElementBindingExpression(oFullElement, mFullElement);
    			case "ImplicitElementAccess": return this.MatchedImplicitElementAccess(oFullElement, mFullElement);
    			case "BinaryExpression": return this.MatchedBinaryExpression(oFullElement, mFullElement);
    			case "AssignmentExpression": return this.MatchedAssignmentExpression(oFullElement, mFullElement);
    			case "ConditionalExpression": return this.MatchedConditionalExpression(oFullElement, mFullElement);
    			case "LiteralExpression": return this.MatchedLiteralExpression(oFullElement, mFullElement);
    			case "MakeRefExpression": return this.MatchedMakeRefExpression(oFullElement, mFullElement);
    			case "RefTypeExpression": return this.MatchedRefTypeExpression(oFullElement, mFullElement);
    			case "RefValueExpression": return this.MatchedRefValueExpression(oFullElement, mFullElement);
    			case "CheckedExpression": return this.MatchedCheckedExpression(oFullElement, mFullElement);
    			case "DefaultExpression": return this.MatchedDefaultExpression(oFullElement, mFullElement);
    			case "TypeOfExpression": return this.MatchedTypeOfExpression(oFullElement, mFullElement);
    			case "SizeOfExpression": return this.MatchedSizeOfExpression(oFullElement, mFullElement);
    			case "InvocationExpression": return this.MatchedInvocationExpression(oFullElement, mFullElement);
    			case "ElementAccessExpression": return this.MatchedElementAccessExpression(oFullElement, mFullElement);
    			case "DeclarationExpression": return this.MatchedDeclarationExpression(oFullElement, mFullElement);
    			case "CastExpression": return this.MatchedCastExpression(oFullElement, mFullElement);
    			case "RefExpression": return this.MatchedRefExpression(oFullElement, mFullElement);
    			case "InitializerExpression": return this.MatchedInitializerExpression(oFullElement, mFullElement);
    			case "ObjectCreationExpression": return this.MatchedObjectCreationExpression(oFullElement, mFullElement);
    			case "AnonymousObjectCreationExpression": return this.MatchedAnonymousObjectCreationExpression(oFullElement, mFullElement);
    			case "ArrayCreationExpression": return this.MatchedArrayCreationExpression(oFullElement, mFullElement);
    			case "ImplicitArrayCreationExpression": return this.MatchedImplicitArrayCreationExpression(oFullElement, mFullElement);
    			case "StackAllocArrayCreationExpression": return this.MatchedStackAllocArrayCreationExpression(oFullElement, mFullElement);
    			case "QueryExpression": return this.MatchedQueryExpression(oFullElement, mFullElement);
    			case "OmittedArraySizeExpression": return this.MatchedOmittedArraySizeExpression(oFullElement, mFullElement);
    			case "InterpolatedStringExpression": return this.MatchedInterpolatedStringExpression(oFullElement, mFullElement);
    			case "IsPatternExpression": return this.MatchedIsPatternExpression(oFullElement, mFullElement);
    			case "ThrowExpression": return this.MatchedThrowExpression(oFullElement, mFullElement);
    			case "PredefinedType": return this.MatchedPredefinedType(oFullElement, mFullElement);
    			case "ArrayType": return this.MatchedArrayType(oFullElement, mFullElement);
    			case "PointerType": return this.MatchedPointerType(oFullElement, mFullElement);
    			case "NullableType": return this.MatchedNullableType(oFullElement, mFullElement);
    			case "TupleType": return this.MatchedTupleType(oFullElement, mFullElement);
    			case "OmittedTypeArgument": return this.MatchedOmittedTypeArgument(oFullElement, mFullElement);
    			case "RefType": return this.MatchedRefType(oFullElement, mFullElement);
    			case "QualifiedName": return this.MatchedQualifiedName(oFullElement, mFullElement);
    			case "AliasQualifiedName": return this.MatchedAliasQualifiedName(oFullElement, mFullElement);
    			case "IdentifierName": return this.MatchedIdentifierName(oFullElement, mFullElement);
    			case "GenericName": return this.MatchedGenericName(oFullElement, mFullElement);
    			case "ThisExpression": return this.MatchedThisExpression(oFullElement, mFullElement);
    			case "BaseExpression": return this.MatchedBaseExpression(oFullElement, mFullElement);
    			case "AnonymousMethodExpression": return this.MatchedAnonymousMethodExpression(oFullElement, mFullElement);
    			case "SimpleLambdaExpression": return this.MatchedSimpleLambdaExpression(oFullElement, mFullElement);
    			case "ParenthesizedLambdaExpression": return this.MatchedParenthesizedLambdaExpression(oFullElement, mFullElement);
    			case "ArgumentList": return this.MatchedArgumentList(oFullElement, mFullElement);
    			case "BracketedArgumentList": return this.MatchedBracketedArgumentList(oFullElement, mFullElement);
    			case "FromClause": return this.MatchedFromClause(oFullElement, mFullElement);
    			case "LetClause": return this.MatchedLetClause(oFullElement, mFullElement);
    			case "JoinClause": return this.MatchedJoinClause(oFullElement, mFullElement);
    			case "WhereClause": return this.MatchedWhereClause(oFullElement, mFullElement);
    			case "OrderByClause": return this.MatchedOrderByClause(oFullElement, mFullElement);
    			case "SelectClause": return this.MatchedSelectClause(oFullElement, mFullElement);
    			case "GroupClause": return this.MatchedGroupClause(oFullElement, mFullElement);
    			case "DeclarationPattern": return this.MatchedDeclarationPattern(oFullElement, mFullElement);
    			case "ConstantPattern": return this.MatchedConstantPattern(oFullElement, mFullElement);
    			case "InterpolatedStringText": return this.MatchedInterpolatedStringText(oFullElement, mFullElement);
    			case "Interpolation": return this.MatchedInterpolation(oFullElement, mFullElement);
    			case "Block": return this.MatchedBlock(oFullElement, mFullElement);
    			case "LocalFunctionStatement": return this.MatchedLocalFunctionStatement(oFullElement, mFullElement);
    			case "LocalDeclarationStatement": return this.MatchedLocalDeclarationStatement(oFullElement, mFullElement);
    			case "ExpressionStatement": return this.MatchedExpressionStatement(oFullElement, mFullElement);
    			case "EmptyStatement": return this.MatchedEmptyStatement(oFullElement, mFullElement);
    			case "LabeledStatement": return this.MatchedLabeledStatement(oFullElement, mFullElement);
    			case "GotoStatement": return this.MatchedGotoStatement(oFullElement, mFullElement);
    			case "BreakStatement": return this.MatchedBreakStatement(oFullElement, mFullElement);
    			case "ContinueStatement": return this.MatchedContinueStatement(oFullElement, mFullElement);
    			case "ReturnStatement": return this.MatchedReturnStatement(oFullElement, mFullElement);
    			case "ThrowStatement": return this.MatchedThrowStatement(oFullElement, mFullElement);
    			case "YieldStatement": return this.MatchedYieldStatement(oFullElement, mFullElement);
    			case "WhileStatement": return this.MatchedWhileStatement(oFullElement, mFullElement);
    			case "DoStatement": return this.MatchedDoStatement(oFullElement, mFullElement);
    			case "ForStatement": return this.MatchedForStatement(oFullElement, mFullElement);
    			case "UsingStatement": return this.MatchedUsingStatement(oFullElement, mFullElement);
    			case "FixedStatement": return this.MatchedFixedStatement(oFullElement, mFullElement);
    			case "CheckedStatement": return this.MatchedCheckedStatement(oFullElement, mFullElement);
    			case "UnsafeStatement": return this.MatchedUnsafeStatement(oFullElement, mFullElement);
    			case "LockStatement": return this.MatchedLockStatement(oFullElement, mFullElement);
    			case "IfStatement": return this.MatchedIfStatement(oFullElement, mFullElement);
    			case "SwitchStatement": return this.MatchedSwitchStatement(oFullElement, mFullElement);
    			case "TryStatement": return this.MatchedTryStatement(oFullElement, mFullElement);
    			case "ForEachStatement": return this.MatchedForEachStatement(oFullElement, mFullElement);
    			case "ForEachVariableStatement": return this.MatchedForEachVariableStatement(oFullElement, mFullElement);
    			case "SingleVariableDesignation": return this.MatchedSingleVariableDesignation(oFullElement, mFullElement);
    			case "DiscardDesignation": return this.MatchedDiscardDesignation(oFullElement, mFullElement);
    			case "ParenthesizedVariableDesignation": return this.MatchedParenthesizedVariableDesignation(oFullElement, mFullElement);
    			case "CasePatternSwitchLabel": return this.MatchedCasePatternSwitchLabel(oFullElement, mFullElement);
    			case "CaseSwitchLabel": return this.MatchedCaseSwitchLabel(oFullElement, mFullElement);
    			case "DefaultSwitchLabel": return this.MatchedDefaultSwitchLabel(oFullElement, mFullElement);
    			default: throw new ArgumentException($"The type {oFullElement.Name.LocalName} has not been found.");;//return true
    		}
    	}	
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> Matched(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCore(oFullElement, mFullElement);
        	MatchedAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region UnmatchedOriginal(XElement)'s Visit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginal(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginal(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCore(XElement)"/> is not executed and <see cref="UnmatchedOriginal(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCore(XElement oFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		switch(oFullElement.Name.LocalName)
    		{
    			case "AttributeArgument": return this.UnmatchedOriginalAttributeArgument(oFullElement);
    			case "NameEquals": return this.UnmatchedOriginalNameEquals(oFullElement);
    			case "TypeParameterList": return this.UnmatchedOriginalTypeParameterList(oFullElement);
    			case "TypeParameter": return this.UnmatchedOriginalTypeParameter(oFullElement);
    			case "BaseList": return this.UnmatchedOriginalBaseList(oFullElement);
    			case "TypeParameterConstraintClause": return this.UnmatchedOriginalTypeParameterConstraintClause(oFullElement);
    			case "ExplicitInterfaceSpecifier": return this.UnmatchedOriginalExplicitInterfaceSpecifier(oFullElement);
    			case "ConstructorInitializer": return this.UnmatchedOriginalConstructorInitializer(oFullElement);
    			case "ArrowExpressionClause": return this.UnmatchedOriginalArrowExpressionClause(oFullElement);
    			case "AccessorList": return this.UnmatchedOriginalAccessorList(oFullElement);
    			case "AccessorDeclaration": return this.UnmatchedOriginalAccessorDeclaration(oFullElement);
    			case "Parameter": return this.UnmatchedOriginalParameter(oFullElement);
    			case "CrefParameter": return this.UnmatchedOriginalCrefParameter(oFullElement);
    			case "XmlElementStartTag": return this.UnmatchedOriginalXmlElementStartTag(oFullElement);
    			case "XmlElementEndTag": return this.UnmatchedOriginalXmlElementEndTag(oFullElement);
    			case "XmlName": return this.UnmatchedOriginalXmlName(oFullElement);
    			case "XmlPrefix": return this.UnmatchedOriginalXmlPrefix(oFullElement);
    			case "TypeArgumentList": return this.UnmatchedOriginalTypeArgumentList(oFullElement);
    			case "ArrayRankSpecifier": return this.UnmatchedOriginalArrayRankSpecifier(oFullElement);
    			case "TupleElement": return this.UnmatchedOriginalTupleElement(oFullElement);
    			case "Argument": return this.UnmatchedOriginalArgument(oFullElement);
    			case "NameColon": return this.UnmatchedOriginalNameColon(oFullElement);
    			case "AnonymousObjectMemberDeclarator": return this.UnmatchedOriginalAnonymousObjectMemberDeclarator(oFullElement);
    			case "QueryBody": return this.UnmatchedOriginalQueryBody(oFullElement);
    			case "JoinIntoClause": return this.UnmatchedOriginalJoinIntoClause(oFullElement);
    			case "Ordering": return this.UnmatchedOriginalOrdering(oFullElement);
    			case "QueryContinuation": return this.UnmatchedOriginalQueryContinuation(oFullElement);
    			case "WhenClause": return this.UnmatchedOriginalWhenClause(oFullElement);
    			case "InterpolationAlignmentClause": return this.UnmatchedOriginalInterpolationAlignmentClause(oFullElement);
    			case "InterpolationFormatClause": return this.UnmatchedOriginalInterpolationFormatClause(oFullElement);
    			case "VariableDeclaration": return this.UnmatchedOriginalVariableDeclaration(oFullElement);
    			case "VariableDeclarator": return this.UnmatchedOriginalVariableDeclarator(oFullElement);
    			case "EqualsValueClause": return this.UnmatchedOriginalEqualsValueClause(oFullElement);
    			case "ElseClause": return this.UnmatchedOriginalElseClause(oFullElement);
    			case "SwitchSection": return this.UnmatchedOriginalSwitchSection(oFullElement);
    			case "CatchClause": return this.UnmatchedOriginalCatchClause(oFullElement);
    			case "CatchDeclaration": return this.UnmatchedOriginalCatchDeclaration(oFullElement);
    			case "CatchFilterClause": return this.UnmatchedOriginalCatchFilterClause(oFullElement);
    			case "FinallyClause": return this.UnmatchedOriginalFinallyClause(oFullElement);
    			case "CompilationUnit": return this.UnmatchedOriginalCompilationUnit(oFullElement);
    			case "ExternAliasDirective": return this.UnmatchedOriginalExternAliasDirective(oFullElement);
    			case "UsingDirective": return this.UnmatchedOriginalUsingDirective(oFullElement);
    			case "AttributeList": return this.UnmatchedOriginalAttributeList(oFullElement);
    			case "AttributeTargetSpecifier": return this.UnmatchedOriginalAttributeTargetSpecifier(oFullElement);
    			case "Attribute": return this.UnmatchedOriginalAttribute(oFullElement);
    			case "AttributeArgumentList": return this.UnmatchedOriginalAttributeArgumentList(oFullElement);
    			case "DelegateDeclaration": return this.UnmatchedOriginalDelegateDeclaration(oFullElement);
    			case "EnumMemberDeclaration": return this.UnmatchedOriginalEnumMemberDeclaration(oFullElement);
    			case "IncompleteMember": return this.UnmatchedOriginalIncompleteMember(oFullElement);
    			case "GlobalStatement": return this.UnmatchedOriginalGlobalStatement(oFullElement);
    			case "NamespaceDeclaration": return this.UnmatchedOriginalNamespaceDeclaration(oFullElement);
    			case "EnumDeclaration": return this.UnmatchedOriginalEnumDeclaration(oFullElement);
    			case "ClassDeclaration": return this.UnmatchedOriginalClassDeclaration(oFullElement);
    			case "StructDeclaration": return this.UnmatchedOriginalStructDeclaration(oFullElement);
    			case "InterfaceDeclaration": return this.UnmatchedOriginalInterfaceDeclaration(oFullElement);
    			case "FieldDeclaration": return this.UnmatchedOriginalFieldDeclaration(oFullElement);
    			case "EventFieldDeclaration": return this.UnmatchedOriginalEventFieldDeclaration(oFullElement);
    			case "MethodDeclaration": return this.UnmatchedOriginalMethodDeclaration(oFullElement);
    			case "OperatorDeclaration": return this.UnmatchedOriginalOperatorDeclaration(oFullElement);
    			case "ConversionOperatorDeclaration": return this.UnmatchedOriginalConversionOperatorDeclaration(oFullElement);
    			case "ConstructorDeclaration": return this.UnmatchedOriginalConstructorDeclaration(oFullElement);
    			case "DestructorDeclaration": return this.UnmatchedOriginalDestructorDeclaration(oFullElement);
    			case "PropertyDeclaration": return this.UnmatchedOriginalPropertyDeclaration(oFullElement);
    			case "EventDeclaration": return this.UnmatchedOriginalEventDeclaration(oFullElement);
    			case "IndexerDeclaration": return this.UnmatchedOriginalIndexerDeclaration(oFullElement);
    			case "SimpleBaseType": return this.UnmatchedOriginalSimpleBaseType(oFullElement);
    			case "ConstructorConstraint": return this.UnmatchedOriginalConstructorConstraint(oFullElement);
    			case "ClassOrStructConstraint": return this.UnmatchedOriginalClassOrStructConstraint(oFullElement);
    			case "TypeConstraint": return this.UnmatchedOriginalTypeConstraint(oFullElement);
    			case "ParameterList": return this.UnmatchedOriginalParameterList(oFullElement);
    			case "BracketedParameterList": return this.UnmatchedOriginalBracketedParameterList(oFullElement);
    			case "SkippedTokensTrivia": return this.UnmatchedOriginalSkippedTokensTrivia(oFullElement);
    			case "DocumentationCommentTrivia": return this.UnmatchedOriginalDocumentationCommentTrivia(oFullElement);
    			case "EndIfDirectiveTrivia": return this.UnmatchedOriginalEndIfDirectiveTrivia(oFullElement);
    			case "RegionDirectiveTrivia": return this.UnmatchedOriginalRegionDirectiveTrivia(oFullElement);
    			case "EndRegionDirectiveTrivia": return this.UnmatchedOriginalEndRegionDirectiveTrivia(oFullElement);
    			case "ErrorDirectiveTrivia": return this.UnmatchedOriginalErrorDirectiveTrivia(oFullElement);
    			case "WarningDirectiveTrivia": return this.UnmatchedOriginalWarningDirectiveTrivia(oFullElement);
    			case "BadDirectiveTrivia": return this.UnmatchedOriginalBadDirectiveTrivia(oFullElement);
    			case "DefineDirectiveTrivia": return this.UnmatchedOriginalDefineDirectiveTrivia(oFullElement);
    			case "UndefDirectiveTrivia": return this.UnmatchedOriginalUndefDirectiveTrivia(oFullElement);
    			case "LineDirectiveTrivia": return this.UnmatchedOriginalLineDirectiveTrivia(oFullElement);
    			case "PragmaWarningDirectiveTrivia": return this.UnmatchedOriginalPragmaWarningDirectiveTrivia(oFullElement);
    			case "PragmaChecksumDirectiveTrivia": return this.UnmatchedOriginalPragmaChecksumDirectiveTrivia(oFullElement);
    			case "ReferenceDirectiveTrivia": return this.UnmatchedOriginalReferenceDirectiveTrivia(oFullElement);
    			case "LoadDirectiveTrivia": return this.UnmatchedOriginalLoadDirectiveTrivia(oFullElement);
    			case "ShebangDirectiveTrivia": return this.UnmatchedOriginalShebangDirectiveTrivia(oFullElement);
    			case "ElseDirectiveTrivia": return this.UnmatchedOriginalElseDirectiveTrivia(oFullElement);
    			case "IfDirectiveTrivia": return this.UnmatchedOriginalIfDirectiveTrivia(oFullElement);
    			case "ElifDirectiveTrivia": return this.UnmatchedOriginalElifDirectiveTrivia(oFullElement);
    			case "TypeCref": return this.UnmatchedOriginalTypeCref(oFullElement);
    			case "QualifiedCref": return this.UnmatchedOriginalQualifiedCref(oFullElement);
    			case "NameMemberCref": return this.UnmatchedOriginalNameMemberCref(oFullElement);
    			case "IndexerMemberCref": return this.UnmatchedOriginalIndexerMemberCref(oFullElement);
    			case "OperatorMemberCref": return this.UnmatchedOriginalOperatorMemberCref(oFullElement);
    			case "ConversionOperatorMemberCref": return this.UnmatchedOriginalConversionOperatorMemberCref(oFullElement);
    			case "CrefParameterList": return this.UnmatchedOriginalCrefParameterList(oFullElement);
    			case "CrefBracketedParameterList": return this.UnmatchedOriginalCrefBracketedParameterList(oFullElement);
    			case "XmlElement": return this.UnmatchedOriginalXmlElement(oFullElement);
    			case "XmlEmptyElement": return this.UnmatchedOriginalXmlEmptyElement(oFullElement);
    			case "XmlText": return this.UnmatchedOriginalXmlText(oFullElement);
    			case "XmlCDataSection": return this.UnmatchedOriginalXmlCDataSection(oFullElement);
    			case "XmlProcessingInstruction": return this.UnmatchedOriginalXmlProcessingInstruction(oFullElement);
    			case "XmlComment": return this.UnmatchedOriginalXmlComment(oFullElement);
    			case "XmlTextAttribute": return this.UnmatchedOriginalXmlTextAttribute(oFullElement);
    			case "XmlCrefAttribute": return this.UnmatchedOriginalXmlCrefAttribute(oFullElement);
    			case "XmlNameAttribute": return this.UnmatchedOriginalXmlNameAttribute(oFullElement);
    			case "ParenthesizedExpression": return this.UnmatchedOriginalParenthesizedExpression(oFullElement);
    			case "TupleExpression": return this.UnmatchedOriginalTupleExpression(oFullElement);
    			case "PrefixUnaryExpression": return this.UnmatchedOriginalPrefixUnaryExpression(oFullElement);
    			case "AwaitExpression": return this.UnmatchedOriginalAwaitExpression(oFullElement);
    			case "PostfixUnaryExpression": return this.UnmatchedOriginalPostfixUnaryExpression(oFullElement);
    			case "MemberAccessExpression": return this.UnmatchedOriginalMemberAccessExpression(oFullElement);
    			case "ConditionalAccessExpression": return this.UnmatchedOriginalConditionalAccessExpression(oFullElement);
    			case "MemberBindingExpression": return this.UnmatchedOriginalMemberBindingExpression(oFullElement);
    			case "ElementBindingExpression": return this.UnmatchedOriginalElementBindingExpression(oFullElement);
    			case "ImplicitElementAccess": return this.UnmatchedOriginalImplicitElementAccess(oFullElement);
    			case "BinaryExpression": return this.UnmatchedOriginalBinaryExpression(oFullElement);
    			case "AssignmentExpression": return this.UnmatchedOriginalAssignmentExpression(oFullElement);
    			case "ConditionalExpression": return this.UnmatchedOriginalConditionalExpression(oFullElement);
    			case "LiteralExpression": return this.UnmatchedOriginalLiteralExpression(oFullElement);
    			case "MakeRefExpression": return this.UnmatchedOriginalMakeRefExpression(oFullElement);
    			case "RefTypeExpression": return this.UnmatchedOriginalRefTypeExpression(oFullElement);
    			case "RefValueExpression": return this.UnmatchedOriginalRefValueExpression(oFullElement);
    			case "CheckedExpression": return this.UnmatchedOriginalCheckedExpression(oFullElement);
    			case "DefaultExpression": return this.UnmatchedOriginalDefaultExpression(oFullElement);
    			case "TypeOfExpression": return this.UnmatchedOriginalTypeOfExpression(oFullElement);
    			case "SizeOfExpression": return this.UnmatchedOriginalSizeOfExpression(oFullElement);
    			case "InvocationExpression": return this.UnmatchedOriginalInvocationExpression(oFullElement);
    			case "ElementAccessExpression": return this.UnmatchedOriginalElementAccessExpression(oFullElement);
    			case "DeclarationExpression": return this.UnmatchedOriginalDeclarationExpression(oFullElement);
    			case "CastExpression": return this.UnmatchedOriginalCastExpression(oFullElement);
    			case "RefExpression": return this.UnmatchedOriginalRefExpression(oFullElement);
    			case "InitializerExpression": return this.UnmatchedOriginalInitializerExpression(oFullElement);
    			case "ObjectCreationExpression": return this.UnmatchedOriginalObjectCreationExpression(oFullElement);
    			case "AnonymousObjectCreationExpression": return this.UnmatchedOriginalAnonymousObjectCreationExpression(oFullElement);
    			case "ArrayCreationExpression": return this.UnmatchedOriginalArrayCreationExpression(oFullElement);
    			case "ImplicitArrayCreationExpression": return this.UnmatchedOriginalImplicitArrayCreationExpression(oFullElement);
    			case "StackAllocArrayCreationExpression": return this.UnmatchedOriginalStackAllocArrayCreationExpression(oFullElement);
    			case "QueryExpression": return this.UnmatchedOriginalQueryExpression(oFullElement);
    			case "OmittedArraySizeExpression": return this.UnmatchedOriginalOmittedArraySizeExpression(oFullElement);
    			case "InterpolatedStringExpression": return this.UnmatchedOriginalInterpolatedStringExpression(oFullElement);
    			case "IsPatternExpression": return this.UnmatchedOriginalIsPatternExpression(oFullElement);
    			case "ThrowExpression": return this.UnmatchedOriginalThrowExpression(oFullElement);
    			case "PredefinedType": return this.UnmatchedOriginalPredefinedType(oFullElement);
    			case "ArrayType": return this.UnmatchedOriginalArrayType(oFullElement);
    			case "PointerType": return this.UnmatchedOriginalPointerType(oFullElement);
    			case "NullableType": return this.UnmatchedOriginalNullableType(oFullElement);
    			case "TupleType": return this.UnmatchedOriginalTupleType(oFullElement);
    			case "OmittedTypeArgument": return this.UnmatchedOriginalOmittedTypeArgument(oFullElement);
    			case "RefType": return this.UnmatchedOriginalRefType(oFullElement);
    			case "QualifiedName": return this.UnmatchedOriginalQualifiedName(oFullElement);
    			case "AliasQualifiedName": return this.UnmatchedOriginalAliasQualifiedName(oFullElement);
    			case "IdentifierName": return this.UnmatchedOriginalIdentifierName(oFullElement);
    			case "GenericName": return this.UnmatchedOriginalGenericName(oFullElement);
    			case "ThisExpression": return this.UnmatchedOriginalThisExpression(oFullElement);
    			case "BaseExpression": return this.UnmatchedOriginalBaseExpression(oFullElement);
    			case "AnonymousMethodExpression": return this.UnmatchedOriginalAnonymousMethodExpression(oFullElement);
    			case "SimpleLambdaExpression": return this.UnmatchedOriginalSimpleLambdaExpression(oFullElement);
    			case "ParenthesizedLambdaExpression": return this.UnmatchedOriginalParenthesizedLambdaExpression(oFullElement);
    			case "ArgumentList": return this.UnmatchedOriginalArgumentList(oFullElement);
    			case "BracketedArgumentList": return this.UnmatchedOriginalBracketedArgumentList(oFullElement);
    			case "FromClause": return this.UnmatchedOriginalFromClause(oFullElement);
    			case "LetClause": return this.UnmatchedOriginalLetClause(oFullElement);
    			case "JoinClause": return this.UnmatchedOriginalJoinClause(oFullElement);
    			case "WhereClause": return this.UnmatchedOriginalWhereClause(oFullElement);
    			case "OrderByClause": return this.UnmatchedOriginalOrderByClause(oFullElement);
    			case "SelectClause": return this.UnmatchedOriginalSelectClause(oFullElement);
    			case "GroupClause": return this.UnmatchedOriginalGroupClause(oFullElement);
    			case "DeclarationPattern": return this.UnmatchedOriginalDeclarationPattern(oFullElement);
    			case "ConstantPattern": return this.UnmatchedOriginalConstantPattern(oFullElement);
    			case "InterpolatedStringText": return this.UnmatchedOriginalInterpolatedStringText(oFullElement);
    			case "Interpolation": return this.UnmatchedOriginalInterpolation(oFullElement);
    			case "Block": return this.UnmatchedOriginalBlock(oFullElement);
    			case "LocalFunctionStatement": return this.UnmatchedOriginalLocalFunctionStatement(oFullElement);
    			case "LocalDeclarationStatement": return this.UnmatchedOriginalLocalDeclarationStatement(oFullElement);
    			case "ExpressionStatement": return this.UnmatchedOriginalExpressionStatement(oFullElement);
    			case "EmptyStatement": return this.UnmatchedOriginalEmptyStatement(oFullElement);
    			case "LabeledStatement": return this.UnmatchedOriginalLabeledStatement(oFullElement);
    			case "GotoStatement": return this.UnmatchedOriginalGotoStatement(oFullElement);
    			case "BreakStatement": return this.UnmatchedOriginalBreakStatement(oFullElement);
    			case "ContinueStatement": return this.UnmatchedOriginalContinueStatement(oFullElement);
    			case "ReturnStatement": return this.UnmatchedOriginalReturnStatement(oFullElement);
    			case "ThrowStatement": return this.UnmatchedOriginalThrowStatement(oFullElement);
    			case "YieldStatement": return this.UnmatchedOriginalYieldStatement(oFullElement);
    			case "WhileStatement": return this.UnmatchedOriginalWhileStatement(oFullElement);
    			case "DoStatement": return this.UnmatchedOriginalDoStatement(oFullElement);
    			case "ForStatement": return this.UnmatchedOriginalForStatement(oFullElement);
    			case "UsingStatement": return this.UnmatchedOriginalUsingStatement(oFullElement);
    			case "FixedStatement": return this.UnmatchedOriginalFixedStatement(oFullElement);
    			case "CheckedStatement": return this.UnmatchedOriginalCheckedStatement(oFullElement);
    			case "UnsafeStatement": return this.UnmatchedOriginalUnsafeStatement(oFullElement);
    			case "LockStatement": return this.UnmatchedOriginalLockStatement(oFullElement);
    			case "IfStatement": return this.UnmatchedOriginalIfStatement(oFullElement);
    			case "SwitchStatement": return this.UnmatchedOriginalSwitchStatement(oFullElement);
    			case "TryStatement": return this.UnmatchedOriginalTryStatement(oFullElement);
    			case "ForEachStatement": return this.UnmatchedOriginalForEachStatement(oFullElement);
    			case "ForEachVariableStatement": return this.UnmatchedOriginalForEachVariableStatement(oFullElement);
    			case "SingleVariableDesignation": return this.UnmatchedOriginalSingleVariableDesignation(oFullElement);
    			case "DiscardDesignation": return this.UnmatchedOriginalDiscardDesignation(oFullElement);
    			case "ParenthesizedVariableDesignation": return this.UnmatchedOriginalParenthesizedVariableDesignation(oFullElement);
    			case "CasePatternSwitchLabel": return this.UnmatchedOriginalCasePatternSwitchLabel(oFullElement);
    			case "CaseSwitchLabel": return this.UnmatchedOriginalCaseSwitchLabel(oFullElement);
    			case "DefaultSwitchLabel": return this.UnmatchedOriginalDefaultSwitchLabel(oFullElement);
    			default: throw new ArgumentException($"The type {oFullElement.Name.LocalName} has not been found.");;//return true
    		}
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginal(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCore(oFullElement);
        	UnmatchedOriginalAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AttributeArgument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAttributeArgument(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAttributeArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAttributeArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAttributeArgumentBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAttributeArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeArgumentCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAttributeArgumentAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAttributeArgument(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeArgumentCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeArgument(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAttributeArgumentBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAttributeArgumentCore(mFullElement);
        	UnmatchedModifiedAttributeArgumentAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeArgumentCore(XElement, XElement)"/> is not executed and <see cref="MatchedAttributeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeArgumentBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentCore(XElement, XElement)"/>.</param>
        partial void MatchedAttributeArgumentAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeArgument(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAttributeArgumentBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAttributeArgumentCore(oFullElement, mFullElement);
        	MatchedAttributeArgumentAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAttributeArgument(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAttributeArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAttributeArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAttributeArgumentBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAttributeArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeArgumentCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAttributeArgumentAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeArgumentCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeArgument(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAttributeArgumentBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAttributeArgumentCore(oFullElement);
        	UnmatchedOriginalAttributeArgumentAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region NameEquals
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedNameEquals(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameEquals(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedNameEqualsCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedNameEquals(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedNameEqualsBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedNameEqualsCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameEqualsCore(XElement)"/>.</param>
        partial void UnmatchedModifiedNameEqualsAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedNameEquals(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameEqualsCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameEquals(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedNameEqualsBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedNameEqualsCore(mFullElement);
        	UnmatchedModifiedNameEqualsAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameEquals(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameEquals(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameEqualsCore(XElement, XElement)"/> is not executed and <see cref="MatchedNameEquals(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameEqualsBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameEqualsCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameEqualsCore(XElement, XElement)"/>.</param>
        partial void MatchedNameEqualsAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameEquals(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameEqualsCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedNameEquals(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedNameEqualsBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedNameEqualsCore(oFullElement, mFullElement);
        	MatchedNameEqualsAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalNameEquals(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameEquals(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalNameEqualsCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalNameEquals(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalNameEqualsBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalNameEqualsCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameEqualsCore(XElement)"/>.</param>
        partial void UnmatchedOriginalNameEqualsAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameEqualsCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameEquals(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalNameEqualsBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalNameEqualsCore(oFullElement);
        	UnmatchedOriginalNameEqualsAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeParameterList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeParameterListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameterListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeParameterListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeParameterList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameterListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameterList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeParameterListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeParameterListCore(mFullElement);
        	UnmatchedModifiedTypeParameterListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterListCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterListCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeParameterListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameterList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeParameterListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeParameterListCore(oFullElement, mFullElement);
        	MatchedTypeParameterListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeParameterList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeParameterListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameterListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeParameterListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameterListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameterList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeParameterListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeParameterListCore(oFullElement);
        	UnmatchedOriginalTypeParameterListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeParameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeParameter(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeParameterCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeParameterBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameterCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeParameterAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeParameter(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameterCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "VarianceKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameter(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeParameterBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeParameterCore(mFullElement);
        	UnmatchedModifiedTypeParameterAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeParameterAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "VarianceKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "VarianceKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameter(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeParameterBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeParameterCore(oFullElement, mFullElement);
        	MatchedTypeParameterAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeParameter(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeParameterCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeParameterBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameterCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeParameterAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameterCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "VarianceKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameter(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeParameterBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeParameterCore(oFullElement);
        	UnmatchedOriginalTypeParameterAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BaseList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBaseList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBaseList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBaseListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBaseList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBaseListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBaseListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBaseListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBaseListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBaseList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBaseListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBaseList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBaseListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBaseListCore(mFullElement);
        	UnmatchedModifiedBaseListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBaseList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBaseListCore(XElement, XElement)"/> is not executed and <see cref="MatchedBaseList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBaseListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBaseListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseListCore(XElement, XElement)"/>.</param>
        partial void MatchedBaseListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBaseList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBaseListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBaseList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBaseListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBaseListCore(oFullElement, mFullElement);
        	MatchedBaseListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBaseList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBaseList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBaseListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBaseList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBaseListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBaseListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBaseListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBaseListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBaseListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBaseList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBaseListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBaseListCore(oFullElement);
        	UnmatchedOriginalBaseListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeParameterConstraintClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeParameterConstraintClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameterConstraintClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeParameterConstraintClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeParameterConstraintClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeParameterConstraintClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeParameterConstraintClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeParameterConstraintClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeParameterConstraintClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeParameterConstraintClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameterConstraintClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeParameterConstraintClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeParameterConstraintClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeParameterConstraintClauseCore(mFullElement);
        	UnmatchedModifiedTypeParameterConstraintClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeParameterConstraintClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterConstraintClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeParameterConstraintClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeParameterConstraintClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeParameterConstraintClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeParameterConstraintClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeParameterConstraintClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeParameterConstraintClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeParameterConstraintClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeParameterConstraintClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeParameterConstraintClauseCore(oFullElement, mFullElement);
        	MatchedTypeParameterConstraintClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeParameterConstraintClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameterConstraintClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeParameterConstraintClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeParameterConstraintClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeParameterConstraintClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeParameterConstraintClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeParameterConstraintClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeParameterConstraintClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameterConstraintClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeParameterConstraintClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeParameterConstraintClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeParameterConstraintClauseCore(oFullElement);
        	UnmatchedOriginalTypeParameterConstraintClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ExplicitInterfaceSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedExplicitInterfaceSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExplicitInterfaceSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedExplicitInterfaceSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedExplicitInterfaceSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedExplicitInterfaceSpecifierBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedExplicitInterfaceSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExplicitInterfaceSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedModifiedExplicitInterfaceSpecifierAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedExplicitInterfaceSpecifier(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedExplicitInterfaceSpecifierCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedExplicitInterfaceSpecifier(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedExplicitInterfaceSpecifierBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedExplicitInterfaceSpecifierCore(mFullElement);
        	UnmatchedModifiedExplicitInterfaceSpecifierAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement)"/> is not executed and <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExplicitInterfaceSpecifierBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExplicitInterfaceSpecifierCore(XElement, XElement)"/>.</param>
        partial void MatchedExplicitInterfaceSpecifierAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExplicitInterfaceSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExplicitInterfaceSpecifierCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedExplicitInterfaceSpecifier(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedExplicitInterfaceSpecifierBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedExplicitInterfaceSpecifierCore(oFullElement, mFullElement);
        	MatchedExplicitInterfaceSpecifierAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalExplicitInterfaceSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExplicitInterfaceSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalExplicitInterfaceSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalExplicitInterfaceSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalExplicitInterfaceSpecifierBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalExplicitInterfaceSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExplicitInterfaceSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedOriginalExplicitInterfaceSpecifierAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalExplicitInterfaceSpecifierCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalExplicitInterfaceSpecifier(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalExplicitInterfaceSpecifierBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalExplicitInterfaceSpecifierCore(oFullElement);
        	UnmatchedOriginalExplicitInterfaceSpecifierAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConstructorInitializer
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConstructorInitializer(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorInitializer(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConstructorInitializerCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConstructorInitializer(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConstructorInitializerBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConstructorInitializerCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorInitializerCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConstructorInitializerAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConstructorInitializer(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorInitializerCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisOrBaseKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorInitializer(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConstructorInitializerBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConstructorInitializerCore(mFullElement);
        	UnmatchedModifiedConstructorInitializerAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorInitializer(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorInitializer(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorInitializerCore(XElement, XElement)"/> is not executed and <see cref="MatchedConstructorInitializer(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorInitializerBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorInitializerCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorInitializerCore(XElement, XElement)"/>.</param>
        partial void MatchedConstructorInitializerAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorInitializer(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorInitializerCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisOrBaseKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisOrBaseKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorInitializer(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConstructorInitializerBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConstructorInitializerCore(oFullElement, mFullElement);
        	MatchedConstructorInitializerAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConstructorInitializer(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorInitializer(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConstructorInitializerCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConstructorInitializer(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConstructorInitializerBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConstructorInitializerCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorInitializerCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConstructorInitializerAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorInitializerCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisOrBaseKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorInitializer(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConstructorInitializerBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConstructorInitializerCore(oFullElement);
        	UnmatchedOriginalConstructorInitializerAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ArrowExpressionClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArrowExpressionClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrowExpressionClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArrowExpressionClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArrowExpressionClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArrowExpressionClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArrowExpressionClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrowExpressionClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArrowExpressionClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArrowExpressionClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrowExpressionClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrowExpressionClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArrowExpressionClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArrowExpressionClauseCore(mFullElement);
        	UnmatchedModifiedArrowExpressionClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrowExpressionClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrowExpressionClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrowExpressionClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedArrowExpressionClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrowExpressionClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrowExpressionClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrowExpressionClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedArrowExpressionClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrowExpressionClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrowExpressionClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArrowExpressionClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArrowExpressionClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArrowExpressionClauseCore(oFullElement, mFullElement);
        	MatchedArrowExpressionClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArrowExpressionClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrowExpressionClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArrowExpressionClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArrowExpressionClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArrowExpressionClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArrowExpressionClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrowExpressionClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArrowExpressionClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrowExpressionClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrowExpressionClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArrowExpressionClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArrowExpressionClauseCore(oFullElement);
        	UnmatchedOriginalArrowExpressionClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AccessorList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAccessorList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAccessorList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAccessorListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAccessorList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAccessorListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAccessorListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAccessorListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAccessorListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAccessorList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAccessorListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAccessorList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAccessorListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAccessorListCore(mFullElement);
        	UnmatchedModifiedAccessorListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAccessorList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAccessorListCore(XElement, XElement)"/> is not executed and <see cref="MatchedAccessorList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAccessorListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAccessorListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorListCore(XElement, XElement)"/>.</param>
        partial void MatchedAccessorListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAccessorList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAccessorListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAccessorList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAccessorListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAccessorListCore(oFullElement, mFullElement);
        	MatchedAccessorListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAccessorList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAccessorList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAccessorListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAccessorList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAccessorListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAccessorListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAccessorListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAccessorListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAccessorListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAccessorList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAccessorListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAccessorListCore(oFullElement);
        	UnmatchedOriginalAccessorListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AccessorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAccessorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAccessorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAccessorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAccessorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAccessorDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAccessorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAccessorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAccessorDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAccessorDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAccessorDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAccessorDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAccessorDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAccessorDeclarationCore(mFullElement);
        	UnmatchedModifiedAccessorDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAccessorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAccessorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedAccessorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAccessorDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAccessorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAccessorDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedAccessorDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAccessorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAccessorDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAccessorDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAccessorDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAccessorDeclarationCore(oFullElement, mFullElement);
        	MatchedAccessorDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAccessorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAccessorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAccessorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAccessorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAccessorDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAccessorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAccessorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAccessorDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAccessorDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAccessorDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAccessorDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAccessorDeclarationCore(oFullElement);
        	UnmatchedOriginalAccessorDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Parameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedParameter(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedParameterCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedParameterBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParameterCore(XElement)"/>.</param>
        partial void UnmatchedModifiedParameterAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedParameter(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedParameterCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedParameter(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedParameterBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedParameterCore(mFullElement);
        	UnmatchedModifiedParameterAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParameterCore(XElement, XElement)"/> is not executed and <see cref="MatchedParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParameterBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterCore(XElement, XElement)"/>.</param>
        partial void MatchedParameterAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParameterCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedParameter(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedParameterBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedParameterCore(oFullElement, mFullElement);
        	MatchedParameterAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalParameter(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalParameterCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalParameterBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParameterCore(XElement)"/>.</param>
        partial void UnmatchedOriginalParameterAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalParameterCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalParameter(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalParameterBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalParameterCore(oFullElement);
        	UnmatchedOriginalParameterAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CrefParameter
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCrefParameter(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCrefParameterCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCrefParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCrefParameterBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCrefParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefParameterCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCrefParameterAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCrefParameter(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefParameterCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefParameter(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCrefParameterBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCrefParameterCore(mFullElement);
        	UnmatchedModifiedCrefParameterAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefParameter(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameter(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefParameterCore(XElement, XElement)"/> is not executed and <see cref="MatchedCrefParameter(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefParameterBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefParameterCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterCore(XElement, XElement)"/>.</param>
        partial void MatchedCrefParameterAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefParameter(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefParameterCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCrefParameter(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCrefParameterBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCrefParameterCore(oFullElement, mFullElement);
        	MatchedCrefParameterAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCrefParameter(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefParameter(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCrefParameterCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCrefParameter(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCrefParameterBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCrefParameterCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefParameterCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCrefParameterAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefParameterCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefParameter(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCrefParameterBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCrefParameterCore(oFullElement);
        	UnmatchedOriginalCrefParameterAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlElementStartTag
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlElementStartTag(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElementStartTag(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlElementStartTagCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlElementStartTag(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlElementStartTagBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlElementStartTagCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElementStartTagCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlElementStartTagAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlElementStartTag(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElementStartTagCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElementStartTag(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlElementStartTagBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlElementStartTagCore(mFullElement);
        	UnmatchedModifiedXmlElementStartTagAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElementStartTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementStartTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementStartTagCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlElementStartTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementStartTagBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementStartTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementStartTagCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlElementStartTagAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElementStartTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementStartTagCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElementStartTag(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlElementStartTagBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlElementStartTagCore(oFullElement, mFullElement);
        	MatchedXmlElementStartTagAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlElementStartTag(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElementStartTag(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlElementStartTagCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlElementStartTag(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlElementStartTagBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlElementStartTagCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElementStartTagCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlElementStartTagAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElementStartTagCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElementStartTag(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlElementStartTagBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlElementStartTagCore(oFullElement);
        	UnmatchedOriginalXmlElementStartTagAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlElementEndTag
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlElementEndTag(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElementEndTag(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlElementEndTagCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlElementEndTag(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlElementEndTagBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlElementEndTagCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElementEndTagCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlElementEndTagAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlElementEndTag(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElementEndTagCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanSlashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElementEndTag(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlElementEndTagBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlElementEndTagCore(mFullElement);
        	UnmatchedModifiedXmlElementEndTagAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElementEndTag(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementEndTag(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementEndTagCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlElementEndTag(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementEndTagBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementEndTagCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementEndTagCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlElementEndTagAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElementEndTag(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementEndTagCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanSlashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanSlashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElementEndTag(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlElementEndTagBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlElementEndTagCore(oFullElement, mFullElement);
        	MatchedXmlElementEndTagAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlElementEndTag(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElementEndTag(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlElementEndTagCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlElementEndTag(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlElementEndTagBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlElementEndTagCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElementEndTagCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlElementEndTagAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElementEndTagCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanSlashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElementEndTag(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlElementEndTagBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlElementEndTagCore(oFullElement);
        	UnmatchedOriginalXmlElementEndTagAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlName(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlNameCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlNameBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlNameCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlNameCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlNameAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlName(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlNameCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LocalName");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlName(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlNameBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlNameCore(mFullElement);
        	UnmatchedModifiedXmlNameAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlNameCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlNameBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlNameAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlNameCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LocalName");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LocalName");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlName(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlNameBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlNameCore(oFullElement, mFullElement);
        	MatchedXmlNameAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlName(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlNameCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlNameBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlNameCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlNameCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlNameAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlNameCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LocalName");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlName(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlNameBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlNameCore(oFullElement);
        	UnmatchedOriginalXmlNameAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlPrefix
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlPrefix(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlPrefix(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlPrefixCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlPrefix(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlPrefixBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlPrefixCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlPrefixCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlPrefixAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlPrefix(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlPrefixCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Prefix");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlPrefix(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlPrefixBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlPrefixCore(mFullElement);
        	UnmatchedModifiedXmlPrefixAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlPrefix(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlPrefix(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlPrefixCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlPrefix(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlPrefixBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlPrefixCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlPrefixCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlPrefixAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlPrefix(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlPrefixCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Prefix");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Prefix");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlPrefix(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlPrefixBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlPrefixCore(oFullElement, mFullElement);
        	MatchedXmlPrefixAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlPrefix(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlPrefix(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlPrefixCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlPrefix(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlPrefixBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlPrefixCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlPrefixCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlPrefixAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlPrefixCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Prefix");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlPrefix(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlPrefixBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlPrefixCore(oFullElement);
        	UnmatchedOriginalXmlPrefixAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeArgumentListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeArgumentListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeArgumentList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeArgumentListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeArgumentList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeArgumentListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeArgumentListCore(mFullElement);
        	UnmatchedModifiedTypeArgumentListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeArgumentListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeArgumentListCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeArgumentListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeArgumentListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeArgumentList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeArgumentListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeArgumentListCore(oFullElement, mFullElement);
        	MatchedTypeArgumentListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeArgumentListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeArgumentListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeArgumentListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeArgumentList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeArgumentListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeArgumentListCore(oFullElement);
        	UnmatchedOriginalTypeArgumentListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ArrayRankSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArrayRankSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayRankSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArrayRankSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArrayRankSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArrayRankSpecifierBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArrayRankSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayRankSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArrayRankSpecifierAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArrayRankSpecifier(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayRankSpecifierCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayRankSpecifier(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArrayRankSpecifierBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArrayRankSpecifierCore(mFullElement);
        	UnmatchedModifiedArrayRankSpecifierAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayRankSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayRankSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayRankSpecifierCore(XElement, XElement)"/> is not executed and <see cref="MatchedArrayRankSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayRankSpecifierBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayRankSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayRankSpecifierCore(XElement, XElement)"/>.</param>
        partial void MatchedArrayRankSpecifierAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayRankSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayRankSpecifierCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArrayRankSpecifier(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArrayRankSpecifierBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArrayRankSpecifierCore(oFullElement, mFullElement);
        	MatchedArrayRankSpecifierAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArrayRankSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayRankSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArrayRankSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArrayRankSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArrayRankSpecifierBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArrayRankSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayRankSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArrayRankSpecifierAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayRankSpecifierCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayRankSpecifier(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArrayRankSpecifierBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArrayRankSpecifierCore(oFullElement);
        	UnmatchedOriginalArrayRankSpecifierAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TupleElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTupleElement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTupleElementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTupleElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTupleElementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTupleElementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleElementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTupleElementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTupleElement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleElementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleElement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTupleElementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTupleElementCore(mFullElement);
        	UnmatchedModifiedTupleElementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleElementCore(XElement, XElement)"/> is not executed and <see cref="MatchedTupleElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleElementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleElementCore(XElement, XElement)"/>.</param>
        partial void MatchedTupleElementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleElementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTupleElement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTupleElementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTupleElementCore(oFullElement, mFullElement);
        	MatchedTupleElementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTupleElement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTupleElementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTupleElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTupleElementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTupleElementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleElementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTupleElementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleElementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleElement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTupleElementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTupleElementCore(oFullElement);
        	UnmatchedOriginalTupleElementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Argument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArgument(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArgumentBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArgumentCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArgumentAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArgument(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArgumentCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArgument(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArgumentBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArgumentCore(mFullElement);
        	UnmatchedModifiedArgumentAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArgumentCore(XElement, XElement)"/> is not executed and <see cref="MatchedArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArgumentBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentCore(XElement, XElement)"/>.</param>
        partial void MatchedArgumentAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArgumentCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArgument(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArgumentBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArgumentCore(oFullElement, mFullElement);
        	MatchedArgumentAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArgument(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArgumentBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArgumentCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArgumentAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArgumentCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKindKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArgument(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArgumentBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArgumentCore(oFullElement);
        	UnmatchedOriginalArgumentAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region NameColon
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedNameColon(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameColon(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedNameColonCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedNameColon(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedNameColonBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedNameColonCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameColonCore(XElement)"/>.</param>
        partial void UnmatchedModifiedNameColonAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedNameColon(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameColonCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameColon(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedNameColonBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedNameColonCore(mFullElement);
        	UnmatchedModifiedNameColonAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameColon(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameColon(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameColonCore(XElement, XElement)"/> is not executed and <see cref="MatchedNameColon(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameColonBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameColonCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameColonCore(XElement, XElement)"/>.</param>
        partial void MatchedNameColonAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameColon(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameColonCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedNameColon(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedNameColonBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedNameColonCore(oFullElement, mFullElement);
        	MatchedNameColonAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalNameColon(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameColon(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalNameColonCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalNameColon(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalNameColonBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalNameColonCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameColonCore(XElement)"/>.</param>
        partial void UnmatchedOriginalNameColonAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameColonCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameColon(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalNameColonBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalNameColonCore(oFullElement);
        	UnmatchedOriginalNameColonAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AnonymousObjectMemberDeclarator
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAnonymousObjectMemberDeclarator(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousObjectMemberDeclarator(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAnonymousObjectMemberDeclaratorCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAnonymousObjectMemberDeclarator(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAnonymousObjectMemberDeclaratorBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAnonymousObjectMemberDeclaratorCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousObjectMemberDeclaratorCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAnonymousObjectMemberDeclaratorAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAnonymousObjectMemberDeclarator(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousObjectMemberDeclaratorCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousObjectMemberDeclarator(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAnonymousObjectMemberDeclaratorBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAnonymousObjectMemberDeclaratorCore(mFullElement);
        	UnmatchedModifiedAnonymousObjectMemberDeclaratorAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousObjectMemberDeclaratorBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectMemberDeclaratorCore(XElement, XElement)"/>.</param>
        partial void MatchedAnonymousObjectMemberDeclaratorAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousObjectMemberDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectMemberDeclaratorCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectMemberDeclarator(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAnonymousObjectMemberDeclaratorBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAnonymousObjectMemberDeclaratorCore(oFullElement, mFullElement);
        	MatchedAnonymousObjectMemberDeclaratorAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAnonymousObjectMemberDeclarator(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousObjectMemberDeclarator(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAnonymousObjectMemberDeclaratorCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAnonymousObjectMemberDeclarator(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAnonymousObjectMemberDeclaratorBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAnonymousObjectMemberDeclaratorCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousObjectMemberDeclaratorCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAnonymousObjectMemberDeclaratorAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousObjectMemberDeclaratorCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousObjectMemberDeclarator(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAnonymousObjectMemberDeclaratorBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAnonymousObjectMemberDeclaratorCore(oFullElement);
        	UnmatchedOriginalAnonymousObjectMemberDeclaratorAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region QueryBody
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedQueryBody(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryBody(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedQueryBodyCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedQueryBody(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedQueryBodyBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedQueryBodyCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryBodyCore(XElement)"/>.</param>
        partial void UnmatchedModifiedQueryBodyAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedQueryBody(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryBodyCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryBody(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedQueryBodyBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedQueryBodyCore(mFullElement);
        	UnmatchedModifiedQueryBodyAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryBody(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryBody(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryBodyCore(XElement, XElement)"/> is not executed and <see cref="MatchedQueryBody(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryBodyBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryBodyCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryBodyCore(XElement, XElement)"/>.</param>
        partial void MatchedQueryBodyAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryBody(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryBodyCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedQueryBody(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedQueryBodyBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedQueryBodyCore(oFullElement, mFullElement);
        	MatchedQueryBodyAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalQueryBody(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryBody(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalQueryBodyCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalQueryBody(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalQueryBodyBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalQueryBodyCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryBodyCore(XElement)"/>.</param>
        partial void UnmatchedOriginalQueryBodyAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryBodyCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryBody(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalQueryBodyBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalQueryBodyCore(oFullElement);
        	UnmatchedOriginalQueryBodyAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region JoinIntoClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedJoinIntoClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedJoinIntoClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedJoinIntoClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedJoinIntoClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedJoinIntoClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedJoinIntoClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedJoinIntoClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedJoinIntoClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedJoinIntoClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedJoinIntoClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedJoinIntoClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedJoinIntoClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedJoinIntoClauseCore(mFullElement);
        	UnmatchedModifiedJoinIntoClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedJoinIntoClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinIntoClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedJoinIntoClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedJoinIntoClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedJoinIntoClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedJoinIntoClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinIntoClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedJoinIntoClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedJoinIntoClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedJoinIntoClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedJoinIntoClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedJoinIntoClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedJoinIntoClauseCore(oFullElement, mFullElement);
        	MatchedJoinIntoClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalJoinIntoClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalJoinIntoClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalJoinIntoClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalJoinIntoClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalJoinIntoClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalJoinIntoClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalJoinIntoClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalJoinIntoClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalJoinIntoClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalJoinIntoClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalJoinIntoClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalJoinIntoClauseCore(oFullElement);
        	UnmatchedOriginalJoinIntoClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Ordering
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOrdering(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOrdering(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOrderingCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOrdering(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOrderingBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOrderingCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOrderingCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOrderingAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOrdering(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOrderingCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AscendingOrDescendingKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOrdering(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOrderingBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOrderingCore(mFullElement);
        	UnmatchedModifiedOrderingAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOrdering(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrdering(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOrderingCore(XElement, XElement)"/> is not executed and <see cref="MatchedOrdering(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOrderingBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOrderingCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderingCore(XElement, XElement)"/>.</param>
        partial void MatchedOrderingAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOrdering(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOrderingCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AscendingOrDescendingKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AscendingOrDescendingKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOrdering(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOrderingBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOrderingCore(oFullElement, mFullElement);
        	MatchedOrderingAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOrdering(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOrdering(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOrderingCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOrdering(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOrderingBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOrderingCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOrderingCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOrderingAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOrderingCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AscendingOrDescendingKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOrdering(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOrderingBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOrderingCore(oFullElement);
        	UnmatchedOriginalOrderingAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region QueryContinuation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedQueryContinuation(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryContinuation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedQueryContinuationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedQueryContinuation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedQueryContinuationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedQueryContinuationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryContinuationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedQueryContinuationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedQueryContinuation(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryContinuationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryContinuation(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedQueryContinuationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedQueryContinuationCore(mFullElement);
        	UnmatchedModifiedQueryContinuationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryContinuation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryContinuation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryContinuationCore(XElement, XElement)"/> is not executed and <see cref="MatchedQueryContinuation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryContinuationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryContinuationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryContinuationCore(XElement, XElement)"/>.</param>
        partial void MatchedQueryContinuationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryContinuation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryContinuationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedQueryContinuation(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedQueryContinuationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedQueryContinuationCore(oFullElement, mFullElement);
        	MatchedQueryContinuationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalQueryContinuation(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryContinuation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalQueryContinuationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalQueryContinuation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalQueryContinuationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalQueryContinuationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryContinuationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalQueryContinuationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryContinuationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IntoKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryContinuation(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalQueryContinuationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalQueryContinuationCore(oFullElement);
        	UnmatchedOriginalQueryContinuationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region WhenClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedWhenClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhenClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedWhenClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedWhenClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedWhenClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedWhenClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhenClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedWhenClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedWhenClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhenClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhenClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedWhenClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedWhenClauseCore(mFullElement);
        	UnmatchedModifiedWhenClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhenClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhenClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhenClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedWhenClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhenClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhenClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhenClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedWhenClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhenClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhenClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedWhenClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedWhenClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedWhenClauseCore(oFullElement, mFullElement);
        	MatchedWhenClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalWhenClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhenClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalWhenClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalWhenClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalWhenClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalWhenClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhenClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalWhenClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhenClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhenClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalWhenClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalWhenClauseCore(oFullElement);
        	UnmatchedOriginalWhenClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InterpolationAlignmentClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterpolationAlignmentClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolationAlignmentClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterpolationAlignmentClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterpolationAlignmentClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterpolationAlignmentClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterpolationAlignmentClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolationAlignmentClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterpolationAlignmentClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterpolationAlignmentClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolationAlignmentClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CommaToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolationAlignmentClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterpolationAlignmentClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterpolationAlignmentClauseCore(mFullElement);
        	UnmatchedModifiedInterpolationAlignmentClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolationAlignmentClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationAlignmentClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterpolationAlignmentClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationAlignmentClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationAlignmentClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedInterpolationAlignmentClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolationAlignmentClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationAlignmentClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CommaToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CommaToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolationAlignmentClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterpolationAlignmentClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterpolationAlignmentClauseCore(oFullElement, mFullElement);
        	MatchedInterpolationAlignmentClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterpolationAlignmentClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolationAlignmentClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterpolationAlignmentClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterpolationAlignmentClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterpolationAlignmentClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterpolationAlignmentClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolationAlignmentClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterpolationAlignmentClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolationAlignmentClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CommaToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolationAlignmentClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterpolationAlignmentClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterpolationAlignmentClauseCore(oFullElement);
        	UnmatchedOriginalInterpolationAlignmentClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InterpolationFormatClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterpolationFormatClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolationFormatClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterpolationFormatClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterpolationFormatClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterpolationFormatClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterpolationFormatClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolationFormatClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterpolationFormatClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterpolationFormatClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolationFormatClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FormatStringToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolationFormatClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterpolationFormatClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterpolationFormatClauseCore(mFullElement);
        	UnmatchedModifiedInterpolationFormatClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolationFormatClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationFormatClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterpolationFormatClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationFormatClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationFormatClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedInterpolationFormatClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolationFormatClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationFormatClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FormatStringToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FormatStringToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolationFormatClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterpolationFormatClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterpolationFormatClauseCore(oFullElement, mFullElement);
        	MatchedInterpolationFormatClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterpolationFormatClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolationFormatClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterpolationFormatClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterpolationFormatClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterpolationFormatClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterpolationFormatClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolationFormatClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterpolationFormatClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolationFormatClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FormatStringToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolationFormatClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterpolationFormatClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterpolationFormatClauseCore(oFullElement);
        	UnmatchedOriginalInterpolationFormatClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region VariableDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedVariableDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedVariableDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedVariableDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedVariableDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedVariableDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedVariableDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedVariableDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedVariableDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedVariableDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedVariableDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedVariableDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedVariableDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedVariableDeclarationCore(mFullElement);
        	UnmatchedModifiedVariableDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedVariableDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedVariableDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedVariableDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedVariableDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedVariableDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedVariableDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedVariableDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedVariableDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedVariableDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedVariableDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedVariableDeclarationCore(oFullElement, mFullElement);
        	MatchedVariableDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalVariableDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalVariableDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalVariableDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalVariableDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalVariableDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalVariableDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalVariableDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalVariableDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalVariableDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalVariableDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalVariableDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalVariableDeclarationCore(oFullElement);
        	UnmatchedOriginalVariableDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region VariableDeclarator
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedVariableDeclarator(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedVariableDeclarator(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedVariableDeclaratorCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedVariableDeclarator(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedVariableDeclaratorBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedVariableDeclaratorCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedVariableDeclaratorCore(XElement)"/>.</param>
        partial void UnmatchedModifiedVariableDeclaratorAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedVariableDeclarator(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedVariableDeclaratorCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedVariableDeclarator(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedVariableDeclaratorBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedVariableDeclaratorCore(mFullElement);
        	UnmatchedModifiedVariableDeclaratorAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedVariableDeclarator(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclarator(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedVariableDeclaratorCore(XElement, XElement)"/> is not executed and <see cref="MatchedVariableDeclarator(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedVariableDeclaratorBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedVariableDeclaratorCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedVariableDeclaratorCore(XElement, XElement)"/>.</param>
        partial void MatchedVariableDeclaratorAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedVariableDeclarator(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedVariableDeclaratorCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedVariableDeclarator(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedVariableDeclaratorBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedVariableDeclaratorCore(oFullElement, mFullElement);
        	MatchedVariableDeclaratorAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalVariableDeclarator(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalVariableDeclarator(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalVariableDeclaratorCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalVariableDeclarator(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalVariableDeclaratorBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalVariableDeclaratorCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalVariableDeclaratorCore(XElement)"/>.</param>
        partial void UnmatchedOriginalVariableDeclaratorAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalVariableDeclaratorCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalVariableDeclarator(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalVariableDeclaratorBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalVariableDeclaratorCore(oFullElement);
        	UnmatchedOriginalVariableDeclaratorAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EqualsValueClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEqualsValueClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEqualsValueClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEqualsValueClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEqualsValueClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEqualsValueClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEqualsValueClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEqualsValueClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEqualsValueClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEqualsValueClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEqualsValueClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEqualsValueClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEqualsValueClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEqualsValueClauseCore(mFullElement);
        	UnmatchedModifiedEqualsValueClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEqualsValueClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEqualsValueClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEqualsValueClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedEqualsValueClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEqualsValueClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEqualsValueClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEqualsValueClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedEqualsValueClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEqualsValueClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEqualsValueClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEqualsValueClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEqualsValueClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEqualsValueClauseCore(oFullElement, mFullElement);
        	MatchedEqualsValueClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEqualsValueClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEqualsValueClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEqualsValueClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEqualsValueClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEqualsValueClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEqualsValueClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEqualsValueClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEqualsValueClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEqualsValueClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEqualsValueClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEqualsValueClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEqualsValueClauseCore(oFullElement);
        	UnmatchedOriginalEqualsValueClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ElseClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedElseClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElseClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedElseClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedElseClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedElseClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedElseClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElseClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedElseClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedElseClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedElseClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedElseClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedElseClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedElseClauseCore(mFullElement);
        	UnmatchedModifiedElseClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElseClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElseClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedElseClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElseClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElseClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedElseClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElseClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElseClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedElseClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedElseClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedElseClauseCore(oFullElement, mFullElement);
        	MatchedElseClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalElseClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElseClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalElseClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalElseClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalElseClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalElseClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElseClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalElseClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalElseClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalElseClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalElseClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalElseClauseCore(oFullElement);
        	UnmatchedOriginalElseClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SwitchSection
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSwitchSection(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSwitchSection(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSwitchSectionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSwitchSection(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSwitchSectionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSwitchSectionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSwitchSectionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSwitchSectionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSwitchSection(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSwitchSectionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSwitchSection(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSwitchSectionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSwitchSectionCore(mFullElement);
        	UnmatchedModifiedSwitchSectionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSwitchSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSwitchSectionCore(XElement, XElement)"/> is not executed and <see cref="MatchedSwitchSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSwitchSectionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSwitchSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchSectionCore(XElement, XElement)"/>.</param>
        partial void MatchedSwitchSectionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSwitchSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSwitchSectionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSwitchSection(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSwitchSectionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSwitchSectionCore(oFullElement, mFullElement);
        	MatchedSwitchSectionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSwitchSection(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSwitchSection(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSwitchSectionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSwitchSection(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSwitchSectionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSwitchSectionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSwitchSectionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSwitchSectionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSwitchSectionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSwitchSection(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSwitchSectionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSwitchSectionCore(oFullElement);
        	UnmatchedOriginalSwitchSectionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CatchClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCatchClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCatchClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCatchClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCatchClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCatchClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCatchClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCatchClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CatchKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCatchClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCatchClauseCore(mFullElement);
        	UnmatchedModifiedCatchClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedCatchClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedCatchClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CatchKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CatchKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCatchClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCatchClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCatchClauseCore(oFullElement, mFullElement);
        	MatchedCatchClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCatchClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCatchClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCatchClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCatchClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCatchClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCatchClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CatchKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCatchClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCatchClauseCore(oFullElement);
        	UnmatchedOriginalCatchClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CatchDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCatchDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCatchDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCatchDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCatchDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCatchDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCatchDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCatchDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCatchDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCatchDeclarationCore(mFullElement);
        	UnmatchedModifiedCatchDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedCatchDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedCatchDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCatchDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCatchDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCatchDeclarationCore(oFullElement, mFullElement);
        	MatchedCatchDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCatchDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCatchDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCatchDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCatchDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCatchDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCatchDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCatchDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCatchDeclarationCore(oFullElement);
        	UnmatchedOriginalCatchDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CatchFilterClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCatchFilterClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchFilterClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCatchFilterClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCatchFilterClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCatchFilterClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCatchFilterClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCatchFilterClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCatchFilterClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCatchFilterClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchFilterClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCatchFilterClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCatchFilterClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCatchFilterClauseCore(mFullElement);
        	UnmatchedModifiedCatchFilterClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCatchFilterClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchFilterClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCatchFilterClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedCatchFilterClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCatchFilterClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCatchFilterClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCatchFilterClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedCatchFilterClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCatchFilterClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCatchFilterClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCatchFilterClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCatchFilterClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCatchFilterClauseCore(oFullElement, mFullElement);
        	MatchedCatchFilterClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCatchFilterClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchFilterClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCatchFilterClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCatchFilterClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCatchFilterClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCatchFilterClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCatchFilterClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCatchFilterClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchFilterClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhenKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCatchFilterClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCatchFilterClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCatchFilterClauseCore(oFullElement);
        	UnmatchedOriginalCatchFilterClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region FinallyClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedFinallyClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFinallyClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedFinallyClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedFinallyClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedFinallyClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedFinallyClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFinallyClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedFinallyClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedFinallyClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedFinallyClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FinallyKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedFinallyClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedFinallyClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedFinallyClauseCore(mFullElement);
        	UnmatchedModifiedFinallyClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFinallyClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFinallyClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFinallyClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedFinallyClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFinallyClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFinallyClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFinallyClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedFinallyClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFinallyClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFinallyClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FinallyKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FinallyKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedFinallyClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedFinallyClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedFinallyClauseCore(oFullElement, mFullElement);
        	MatchedFinallyClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalFinallyClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFinallyClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalFinallyClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalFinallyClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalFinallyClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalFinallyClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFinallyClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalFinallyClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalFinallyClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FinallyKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalFinallyClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalFinallyClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalFinallyClauseCore(oFullElement);
        	UnmatchedOriginalFinallyClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CompilationUnit
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCompilationUnit(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCompilationUnit(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCompilationUnitCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCompilationUnit(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCompilationUnitBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCompilationUnitCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCompilationUnitCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCompilationUnitAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCompilationUnit(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCompilationUnitCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfFileToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCompilationUnit(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCompilationUnitBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCompilationUnitCore(mFullElement);
        	UnmatchedModifiedCompilationUnitAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCompilationUnit(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCompilationUnit(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCompilationUnitCore(XElement, XElement)"/> is not executed and <see cref="MatchedCompilationUnit(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCompilationUnitBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCompilationUnitCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCompilationUnitCore(XElement, XElement)"/>.</param>
        partial void MatchedCompilationUnitAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCompilationUnit(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCompilationUnitCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfFileToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfFileToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCompilationUnit(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCompilationUnitBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCompilationUnitCore(oFullElement, mFullElement);
        	MatchedCompilationUnitAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCompilationUnit(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCompilationUnit(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCompilationUnitCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCompilationUnit(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCompilationUnitBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCompilationUnitCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCompilationUnitCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCompilationUnitAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCompilationUnitCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfFileToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCompilationUnit(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCompilationUnitBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCompilationUnitCore(oFullElement);
        	UnmatchedOriginalCompilationUnitAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ExternAliasDirective
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedExternAliasDirective(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExternAliasDirective(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedExternAliasDirectiveCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedExternAliasDirective(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedExternAliasDirectiveBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedExternAliasDirectiveCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExternAliasDirectiveCore(XElement)"/>.</param>
        partial void UnmatchedModifiedExternAliasDirectiveAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedExternAliasDirective(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedExternAliasDirectiveCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExternKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AliasKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedExternAliasDirective(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedExternAliasDirectiveBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedExternAliasDirectiveCore(mFullElement);
        	UnmatchedModifiedExternAliasDirectiveAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExternAliasDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExternAliasDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExternAliasDirectiveCore(XElement, XElement)"/> is not executed and <see cref="MatchedExternAliasDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExternAliasDirectiveBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExternAliasDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExternAliasDirectiveCore(XElement, XElement)"/>.</param>
        partial void MatchedExternAliasDirectiveAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExternAliasDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExternAliasDirectiveCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExternKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExternKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AliasKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AliasKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedExternAliasDirective(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedExternAliasDirectiveBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedExternAliasDirectiveCore(oFullElement, mFullElement);
        	MatchedExternAliasDirectiveAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalExternAliasDirective(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExternAliasDirective(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalExternAliasDirectiveCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalExternAliasDirective(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalExternAliasDirectiveBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalExternAliasDirectiveCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExternAliasDirectiveCore(XElement)"/>.</param>
        partial void UnmatchedOriginalExternAliasDirectiveAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalExternAliasDirectiveCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExternKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AliasKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalExternAliasDirective(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalExternAliasDirectiveBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalExternAliasDirectiveCore(oFullElement);
        	UnmatchedOriginalExternAliasDirectiveAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region UsingDirective
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedUsingDirective(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUsingDirective(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedUsingDirectiveCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedUsingDirective(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedUsingDirectiveBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedUsingDirectiveCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUsingDirectiveCore(XElement)"/>.</param>
        partial void UnmatchedModifiedUsingDirectiveAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedUsingDirective(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedUsingDirectiveCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StaticKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedUsingDirective(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedUsingDirectiveBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedUsingDirectiveCore(mFullElement);
        	UnmatchedModifiedUsingDirectiveAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUsingDirective(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingDirective(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUsingDirectiveCore(XElement, XElement)"/> is not executed and <see cref="MatchedUsingDirective(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUsingDirectiveBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUsingDirectiveCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingDirectiveCore(XElement, XElement)"/>.</param>
        partial void MatchedUsingDirectiveAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUsingDirective(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUsingDirectiveCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StaticKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StaticKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedUsingDirective(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedUsingDirectiveBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedUsingDirectiveCore(oFullElement, mFullElement);
        	MatchedUsingDirectiveAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalUsingDirective(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUsingDirective(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalUsingDirectiveCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalUsingDirective(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalUsingDirectiveBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalUsingDirectiveCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUsingDirectiveCore(XElement)"/>.</param>
        partial void UnmatchedOriginalUsingDirectiveAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalUsingDirectiveCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StaticKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalUsingDirective(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalUsingDirectiveBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalUsingDirectiveCore(oFullElement);
        	UnmatchedOriginalUsingDirectiveAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AttributeList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAttributeList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAttributeListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAttributeList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAttributeListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAttributeListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAttributeListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAttributeList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAttributeListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAttributeListCore(mFullElement);
        	UnmatchedModifiedAttributeListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeListCore(XElement, XElement)"/> is not executed and <see cref="MatchedAttributeList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeListCore(XElement, XElement)"/>.</param>
        partial void MatchedAttributeListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAttributeListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAttributeListCore(oFullElement, mFullElement);
        	MatchedAttributeListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAttributeList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAttributeListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAttributeList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAttributeListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAttributeListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAttributeListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAttributeListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAttributeListCore(oFullElement);
        	UnmatchedOriginalAttributeListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AttributeTargetSpecifier
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAttributeTargetSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeTargetSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAttributeTargetSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAttributeTargetSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAttributeTargetSpecifierBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAttributeTargetSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeTargetSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAttributeTargetSpecifierAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAttributeTargetSpecifier(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeTargetSpecifierCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeTargetSpecifier(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAttributeTargetSpecifierBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAttributeTargetSpecifierCore(mFullElement);
        	UnmatchedModifiedAttributeTargetSpecifierAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeTargetSpecifier(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeTargetSpecifier(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement)"/> is not executed and <see cref="MatchedAttributeTargetSpecifier(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeTargetSpecifierBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeTargetSpecifierCore(XElement, XElement)"/>.</param>
        partial void MatchedAttributeTargetSpecifierAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeTargetSpecifier(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeTargetSpecifierCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeTargetSpecifier(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAttributeTargetSpecifierBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAttributeTargetSpecifierCore(oFullElement, mFullElement);
        	MatchedAttributeTargetSpecifierAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAttributeTargetSpecifier(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeTargetSpecifier(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAttributeTargetSpecifierCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAttributeTargetSpecifier(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAttributeTargetSpecifierBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAttributeTargetSpecifierCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeTargetSpecifierCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAttributeTargetSpecifierAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeTargetSpecifierCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeTargetSpecifier(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAttributeTargetSpecifierBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAttributeTargetSpecifierCore(oFullElement);
        	UnmatchedOriginalAttributeTargetSpecifierAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Attribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAttribute(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAttributeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAttributeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAttribute(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttribute(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAttributeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAttributeCore(mFullElement);
        	UnmatchedModifiedAttributeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeCore(XElement, XElement)"/> is not executed and <see cref="MatchedAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeCore(XElement, XElement)"/>.</param>
        partial void MatchedAttributeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAttribute(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAttributeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAttributeCore(oFullElement, mFullElement);
        	MatchedAttributeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAttribute(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAttributeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAttributeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttribute(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAttributeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAttributeCore(oFullElement);
        	UnmatchedOriginalAttributeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AttributeArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAttributeArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAttributeArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAttributeArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAttributeArgumentListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAttributeArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAttributeArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAttributeArgumentListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAttributeArgumentList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeArgumentListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAttributeArgumentList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAttributeArgumentListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAttributeArgumentListCore(mFullElement);
        	UnmatchedModifiedAttributeArgumentListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAttributeArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAttributeArgumentListCore(XElement, XElement)"/> is not executed and <see cref="MatchedAttributeArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAttributeArgumentListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAttributeArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAttributeArgumentListCore(XElement, XElement)"/>.</param>
        partial void MatchedAttributeArgumentListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAttributeArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAttributeArgumentList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAttributeArgumentListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAttributeArgumentListCore(oFullElement, mFullElement);
        	MatchedAttributeArgumentListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAttributeArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAttributeArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAttributeArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAttributeArgumentListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAttributeArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAttributeArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAttributeArgumentListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeArgumentListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAttributeArgumentList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAttributeArgumentListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAttributeArgumentListCore(oFullElement);
        	UnmatchedOriginalAttributeArgumentListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DelegateDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDelegateDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDelegateDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDelegateDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDelegateDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDelegateDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDelegateDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDelegateDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDelegateDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDelegateDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDelegateDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDelegateDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDelegateDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDelegateDeclarationCore(mFullElement);
        	UnmatchedModifiedDelegateDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDelegateDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDelegateDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDelegateDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedDelegateDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDelegateDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDelegateDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDelegateDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedDelegateDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDelegateDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDelegateDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDelegateDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDelegateDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDelegateDeclarationCore(oFullElement, mFullElement);
        	MatchedDelegateDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDelegateDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDelegateDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDelegateDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDelegateDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDelegateDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDelegateDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDelegateDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDelegateDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDelegateDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDelegateDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDelegateDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDelegateDeclarationCore(oFullElement);
        	UnmatchedOriginalDelegateDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EnumMemberDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEnumMemberDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEnumMemberDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEnumMemberDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEnumMemberDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEnumMemberDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEnumMemberDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEnumMemberDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEnumMemberDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEnumMemberDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEnumMemberDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEnumMemberDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEnumMemberDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEnumMemberDeclarationCore(mFullElement);
        	UnmatchedModifiedEnumMemberDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEnumMemberDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumMemberDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedEnumMemberDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEnumMemberDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumMemberDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedEnumMemberDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEnumMemberDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEnumMemberDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEnumMemberDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEnumMemberDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEnumMemberDeclarationCore(oFullElement, mFullElement);
        	MatchedEnumMemberDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEnumMemberDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEnumMemberDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEnumMemberDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEnumMemberDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEnumMemberDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEnumMemberDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEnumMemberDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEnumMemberDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEnumMemberDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEnumMemberDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEnumMemberDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEnumMemberDeclarationCore(oFullElement);
        	UnmatchedOriginalEnumMemberDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IncompleteMember
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIncompleteMember(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIncompleteMember(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIncompleteMemberCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIncompleteMember(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIncompleteMemberBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIncompleteMemberCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIncompleteMemberCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIncompleteMemberAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIncompleteMember(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIncompleteMemberCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIncompleteMember(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIncompleteMemberBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIncompleteMemberCore(mFullElement);
        	UnmatchedModifiedIncompleteMemberAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIncompleteMember(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIncompleteMember(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIncompleteMemberCore(XElement, XElement)"/> is not executed and <see cref="MatchedIncompleteMember(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIncompleteMemberBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIncompleteMemberCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIncompleteMemberCore(XElement, XElement)"/>.</param>
        partial void MatchedIncompleteMemberAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIncompleteMember(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIncompleteMemberCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIncompleteMember(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIncompleteMemberBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIncompleteMemberCore(oFullElement, mFullElement);
        	MatchedIncompleteMemberAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIncompleteMember(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIncompleteMember(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIncompleteMemberCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIncompleteMember(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIncompleteMemberBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIncompleteMemberCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIncompleteMemberCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIncompleteMemberAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIncompleteMemberCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIncompleteMember(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIncompleteMemberBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIncompleteMemberCore(oFullElement);
        	UnmatchedOriginalIncompleteMemberAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region GlobalStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedGlobalStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGlobalStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedGlobalStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedGlobalStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedGlobalStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedGlobalStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGlobalStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedGlobalStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedGlobalStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedGlobalStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedGlobalStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedGlobalStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedGlobalStatementCore(mFullElement);
        	UnmatchedModifiedGlobalStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGlobalStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGlobalStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGlobalStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedGlobalStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGlobalStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGlobalStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGlobalStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedGlobalStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGlobalStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGlobalStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedGlobalStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedGlobalStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedGlobalStatementCore(oFullElement, mFullElement);
        	MatchedGlobalStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalGlobalStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGlobalStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalGlobalStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalGlobalStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalGlobalStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalGlobalStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGlobalStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalGlobalStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalGlobalStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalGlobalStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalGlobalStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalGlobalStatementCore(oFullElement);
        	UnmatchedOriginalGlobalStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region NamespaceDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedNamespaceDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNamespaceDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedNamespaceDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedNamespaceDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedNamespaceDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedNamespaceDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNamespaceDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedNamespaceDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedNamespaceDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedNamespaceDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NamespaceKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedNamespaceDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedNamespaceDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedNamespaceDeclarationCore(mFullElement);
        	UnmatchedModifiedNamespaceDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNamespaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNamespaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNamespaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedNamespaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNamespaceDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNamespaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNamespaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedNamespaceDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNamespaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNamespaceDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NamespaceKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NamespaceKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedNamespaceDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedNamespaceDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedNamespaceDeclarationCore(oFullElement, mFullElement);
        	MatchedNamespaceDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalNamespaceDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNamespaceDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalNamespaceDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalNamespaceDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalNamespaceDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalNamespaceDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNamespaceDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalNamespaceDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalNamespaceDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NamespaceKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalNamespaceDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalNamespaceDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalNamespaceDeclarationCore(oFullElement);
        	UnmatchedOriginalNamespaceDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EnumDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEnumDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEnumDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEnumDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEnumDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEnumDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEnumDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEnumDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEnumDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEnumDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEnumDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EnumKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEnumDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEnumDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEnumDeclarationCore(mFullElement);
        	UnmatchedModifiedEnumDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEnumDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEnumDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedEnumDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEnumDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEnumDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEnumDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedEnumDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEnumDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEnumDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EnumKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EnumKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEnumDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEnumDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEnumDeclarationCore(oFullElement, mFullElement);
        	MatchedEnumDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEnumDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEnumDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEnumDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEnumDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEnumDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEnumDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEnumDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEnumDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEnumDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EnumKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEnumDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEnumDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEnumDeclarationCore(oFullElement);
        	UnmatchedOriginalEnumDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ClassDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedClassDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedClassDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedClassDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedClassDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedClassDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedClassDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedClassDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedClassDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedClassDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedClassDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedClassDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedClassDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedClassDeclarationCore(mFullElement);
        	UnmatchedModifiedClassDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedClassDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedClassDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedClassDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedClassDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedClassDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedClassDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedClassDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedClassDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedClassDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedClassDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedClassDeclarationCore(oFullElement, mFullElement);
        	MatchedClassDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalClassDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalClassDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalClassDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalClassDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalClassDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalClassDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalClassDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalClassDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalClassDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalClassDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalClassDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalClassDeclarationCore(oFullElement);
        	UnmatchedOriginalClassDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region StructDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedStructDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedStructDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedStructDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedStructDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedStructDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedStructDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedStructDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedStructDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedStructDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedStructDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedStructDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedStructDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedStructDeclarationCore(mFullElement);
        	UnmatchedModifiedStructDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedStructDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStructDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedStructDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedStructDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedStructDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedStructDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStructDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedStructDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedStructDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedStructDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedStructDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedStructDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedStructDeclarationCore(oFullElement, mFullElement);
        	MatchedStructDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalStructDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalStructDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalStructDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalStructDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalStructDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalStructDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalStructDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalStructDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalStructDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalStructDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalStructDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalStructDeclarationCore(oFullElement);
        	UnmatchedOriginalStructDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InterfaceDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterfaceDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterfaceDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterfaceDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterfaceDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterfaceDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterfaceDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterfaceDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterfaceDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterfaceDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterfaceDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterfaceDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterfaceDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterfaceDeclarationCore(mFullElement);
        	UnmatchedModifiedInterfaceDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterfaceDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterfaceDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterfaceDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterfaceDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterfaceDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterfaceDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterfaceDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedInterfaceDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterfaceDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterfaceDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterfaceDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterfaceDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterfaceDeclarationCore(oFullElement, mFullElement);
        	MatchedInterfaceDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterfaceDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterfaceDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterfaceDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterfaceDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterfaceDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterfaceDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterfaceDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterfaceDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterfaceDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterfaceDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterfaceDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterfaceDeclarationCore(oFullElement);
        	UnmatchedOriginalInterfaceDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region FieldDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedFieldDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFieldDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedFieldDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedFieldDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedFieldDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedFieldDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFieldDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedFieldDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedFieldDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedFieldDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedFieldDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedFieldDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedFieldDeclarationCore(mFullElement);
        	UnmatchedModifiedFieldDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFieldDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedFieldDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFieldDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedFieldDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedFieldDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedFieldDeclarationCore(oFullElement, mFullElement);
        	MatchedFieldDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalFieldDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFieldDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalFieldDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalFieldDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalFieldDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalFieldDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFieldDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalFieldDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalFieldDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalFieldDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalFieldDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalFieldDeclarationCore(oFullElement);
        	UnmatchedOriginalFieldDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EventFieldDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEventFieldDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEventFieldDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEventFieldDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEventFieldDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEventFieldDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEventFieldDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEventFieldDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEventFieldDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEventFieldDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEventFieldDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEventFieldDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEventFieldDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEventFieldDeclarationCore(mFullElement);
        	UnmatchedModifiedEventFieldDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEventFieldDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventFieldDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEventFieldDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedEventFieldDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEventFieldDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEventFieldDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventFieldDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedEventFieldDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEventFieldDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEventFieldDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEventFieldDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEventFieldDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEventFieldDeclarationCore(oFullElement, mFullElement);
        	MatchedEventFieldDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEventFieldDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEventFieldDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEventFieldDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEventFieldDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEventFieldDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEventFieldDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEventFieldDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEventFieldDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEventFieldDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEventFieldDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEventFieldDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEventFieldDeclarationCore(oFullElement);
        	UnmatchedOriginalEventFieldDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region MethodDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedMethodDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMethodDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedMethodDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedMethodDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedMethodDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedMethodDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMethodDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedMethodDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedMethodDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedMethodDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedMethodDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedMethodDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedMethodDeclarationCore(mFullElement);
        	UnmatchedModifiedMethodDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMethodDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMethodDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMethodDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedMethodDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMethodDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMethodDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMethodDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedMethodDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMethodDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMethodDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedMethodDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedMethodDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedMethodDeclarationCore(oFullElement, mFullElement);
        	MatchedMethodDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalMethodDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMethodDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalMethodDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalMethodDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalMethodDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalMethodDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMethodDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalMethodDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalMethodDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalMethodDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalMethodDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalMethodDeclarationCore(oFullElement);
        	UnmatchedOriginalMethodDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region OperatorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOperatorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOperatorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOperatorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOperatorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOperatorDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOperatorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOperatorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOperatorDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOperatorDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOperatorDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOperatorDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOperatorDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOperatorDeclarationCore(mFullElement);
        	UnmatchedModifiedOperatorDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOperatorDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedOperatorDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOperatorDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOperatorDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOperatorDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOperatorDeclarationCore(oFullElement, mFullElement);
        	MatchedOperatorDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOperatorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOperatorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOperatorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOperatorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOperatorDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOperatorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOperatorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOperatorDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOperatorDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOperatorDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOperatorDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOperatorDeclarationCore(oFullElement);
        	UnmatchedOriginalOperatorDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConversionOperatorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConversionOperatorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConversionOperatorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConversionOperatorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConversionOperatorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConversionOperatorDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConversionOperatorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConversionOperatorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConversionOperatorDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConversionOperatorDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConversionOperatorDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConversionOperatorDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConversionOperatorDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConversionOperatorDeclarationCore(mFullElement);
        	UnmatchedModifiedConversionOperatorDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConversionOperatorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedConversionOperatorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConversionOperatorDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedConversionOperatorDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConversionOperatorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConversionOperatorDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConversionOperatorDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConversionOperatorDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConversionOperatorDeclarationCore(oFullElement, mFullElement);
        	MatchedConversionOperatorDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConversionOperatorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConversionOperatorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConversionOperatorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConversionOperatorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConversionOperatorDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConversionOperatorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConversionOperatorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConversionOperatorDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConversionOperatorDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConversionOperatorDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConversionOperatorDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConversionOperatorDeclarationCore(oFullElement);
        	UnmatchedOriginalConversionOperatorDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConstructorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConstructorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConstructorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConstructorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConstructorDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConstructorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConstructorDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConstructorDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConstructorDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConstructorDeclarationCore(mFullElement);
        	UnmatchedModifiedConstructorDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedConstructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedConstructorDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConstructorDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConstructorDeclarationCore(oFullElement, mFullElement);
        	MatchedConstructorDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConstructorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConstructorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConstructorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConstructorDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConstructorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConstructorDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConstructorDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConstructorDeclarationCore(oFullElement);
        	UnmatchedOriginalConstructorDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DestructorDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDestructorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDestructorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDestructorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDestructorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDestructorDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDestructorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDestructorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDestructorDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDestructorDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDestructorDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TildeToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDestructorDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDestructorDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDestructorDeclarationCore(mFullElement);
        	UnmatchedModifiedDestructorDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDestructorDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDestructorDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDestructorDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedDestructorDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDestructorDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDestructorDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDestructorDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedDestructorDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDestructorDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDestructorDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TildeToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TildeToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDestructorDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDestructorDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDestructorDeclarationCore(oFullElement, mFullElement);
        	MatchedDestructorDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDestructorDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDestructorDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDestructorDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDestructorDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDestructorDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDestructorDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDestructorDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDestructorDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDestructorDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TildeToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDestructorDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDestructorDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDestructorDeclarationCore(oFullElement);
        	UnmatchedOriginalDestructorDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PropertyDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPropertyDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPropertyDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPropertyDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPropertyDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPropertyDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPropertyDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPropertyDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPropertyDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPropertyDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPropertyDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPropertyDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPropertyDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPropertyDeclarationCore(mFullElement);
        	UnmatchedModifiedPropertyDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPropertyDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPropertyDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPropertyDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedPropertyDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPropertyDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPropertyDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPropertyDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedPropertyDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPropertyDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPropertyDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPropertyDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPropertyDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPropertyDeclarationCore(oFullElement, mFullElement);
        	MatchedPropertyDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPropertyDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPropertyDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPropertyDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPropertyDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPropertyDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPropertyDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPropertyDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPropertyDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPropertyDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPropertyDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPropertyDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPropertyDeclarationCore(oFullElement);
        	UnmatchedOriginalPropertyDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EventDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEventDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEventDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEventDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEventDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEventDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEventDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEventDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEventDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEventDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEventDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEventDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEventDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEventDeclarationCore(mFullElement);
        	UnmatchedModifiedEventDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEventDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEventDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedEventDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEventDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEventDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEventDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedEventDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEventDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEventDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEventDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEventDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEventDeclarationCore(oFullElement, mFullElement);
        	MatchedEventDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEventDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEventDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEventDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEventDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEventDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEventDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEventDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEventDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEventDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EventKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEventDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEventDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEventDeclarationCore(oFullElement);
        	UnmatchedOriginalEventDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IndexerDeclaration
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIndexerDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIndexerDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIndexerDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIndexerDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIndexerDeclarationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIndexerDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIndexerDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIndexerDeclarationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIndexerDeclaration(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIndexerDeclarationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIndexerDeclaration(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIndexerDeclarationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIndexerDeclarationCore(mFullElement);
        	UnmatchedModifiedIndexerDeclarationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIndexerDeclaration(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerDeclaration(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIndexerDeclarationCore(XElement, XElement)"/> is not executed and <see cref="MatchedIndexerDeclaration(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIndexerDeclarationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIndexerDeclarationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerDeclarationCore(XElement, XElement)"/>.</param>
        partial void MatchedIndexerDeclarationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIndexerDeclaration(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIndexerDeclarationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIndexerDeclaration(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIndexerDeclarationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIndexerDeclarationCore(oFullElement, mFullElement);
        	MatchedIndexerDeclarationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIndexerDeclaration(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIndexerDeclaration(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIndexerDeclarationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIndexerDeclaration(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIndexerDeclarationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIndexerDeclarationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIndexerDeclarationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIndexerDeclarationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIndexerDeclarationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIndexerDeclaration(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIndexerDeclarationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIndexerDeclarationCore(oFullElement);
        	UnmatchedOriginalIndexerDeclarationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SimpleBaseType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSimpleBaseType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSimpleBaseType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSimpleBaseTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSimpleBaseType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSimpleBaseTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSimpleBaseTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSimpleBaseTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSimpleBaseTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSimpleBaseType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSimpleBaseTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSimpleBaseType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSimpleBaseTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSimpleBaseTypeCore(mFullElement);
        	UnmatchedModifiedSimpleBaseTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSimpleBaseType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleBaseType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSimpleBaseTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedSimpleBaseType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSimpleBaseTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSimpleBaseTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleBaseTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedSimpleBaseTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSimpleBaseType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSimpleBaseTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSimpleBaseType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSimpleBaseTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSimpleBaseTypeCore(oFullElement, mFullElement);
        	MatchedSimpleBaseTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSimpleBaseType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSimpleBaseType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSimpleBaseTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSimpleBaseType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSimpleBaseTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSimpleBaseTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSimpleBaseTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSimpleBaseTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSimpleBaseTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSimpleBaseType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSimpleBaseTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSimpleBaseTypeCore(oFullElement);
        	UnmatchedOriginalSimpleBaseTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConstructorConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConstructorConstraint(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConstructorConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConstructorConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConstructorConstraintBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConstructorConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstructorConstraintCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConstructorConstraintAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConstructorConstraint(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorConstraintCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstructorConstraint(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConstructorConstraintBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConstructorConstraintCore(mFullElement);
        	UnmatchedModifiedConstructorConstraintAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstructorConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstructorConstraintCore(XElement, XElement)"/> is not executed and <see cref="MatchedConstructorConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstructorConstraintBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstructorConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstructorConstraintCore(XElement, XElement)"/>.</param>
        partial void MatchedConstructorConstraintAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstructorConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstructorConstraintCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConstructorConstraint(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConstructorConstraintBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConstructorConstraintCore(oFullElement, mFullElement);
        	MatchedConstructorConstraintAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConstructorConstraint(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConstructorConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConstructorConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConstructorConstraintBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConstructorConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstructorConstraintCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConstructorConstraintAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorConstraintCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstructorConstraint(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConstructorConstraintBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConstructorConstraintCore(oFullElement);
        	UnmatchedOriginalConstructorConstraintAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ClassOrStructConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedClassOrStructConstraint(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedClassOrStructConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedClassOrStructConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedClassOrStructConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedClassOrStructConstraintBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedClassOrStructConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedClassOrStructConstraintCore(XElement)"/>.</param>
        partial void UnmatchedModifiedClassOrStructConstraintAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedClassOrStructConstraint(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedClassOrStructConstraintCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ClassOrStructKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedClassOrStructConstraint(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedClassOrStructConstraintBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedClassOrStructConstraintCore(mFullElement);
        	UnmatchedModifiedClassOrStructConstraintAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedClassOrStructConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassOrStructConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedClassOrStructConstraintCore(XElement, XElement)"/> is not executed and <see cref="MatchedClassOrStructConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedClassOrStructConstraintBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedClassOrStructConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedClassOrStructConstraintCore(XElement, XElement)"/>.</param>
        partial void MatchedClassOrStructConstraintAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedClassOrStructConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedClassOrStructConstraintCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ClassOrStructKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ClassOrStructKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedClassOrStructConstraint(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedClassOrStructConstraintBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedClassOrStructConstraintCore(oFullElement, mFullElement);
        	MatchedClassOrStructConstraintAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalClassOrStructConstraint(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalClassOrStructConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalClassOrStructConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalClassOrStructConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalClassOrStructConstraintBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalClassOrStructConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalClassOrStructConstraintCore(XElement)"/>.</param>
        partial void UnmatchedOriginalClassOrStructConstraintAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalClassOrStructConstraintCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ClassOrStructKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalClassOrStructConstraint(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalClassOrStructConstraintBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalClassOrStructConstraintCore(oFullElement);
        	UnmatchedOriginalClassOrStructConstraintAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeConstraint
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeConstraint(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeConstraintBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeConstraintCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeConstraintAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeConstraint(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeConstraintCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeConstraint(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeConstraintBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeConstraintCore(mFullElement);
        	UnmatchedModifiedTypeConstraintAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeConstraint(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeConstraint(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeConstraintCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeConstraint(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeConstraintBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeConstraintCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeConstraintCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeConstraintAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeConstraint(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeConstraintCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeConstraint(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeConstraintBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeConstraintCore(oFullElement, mFullElement);
        	MatchedTypeConstraintAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeConstraint(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeConstraint(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeConstraintCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeConstraint(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeConstraintBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeConstraintCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeConstraintCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeConstraintAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeConstraintCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeConstraint(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeConstraintBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeConstraintCore(oFullElement);
        	UnmatchedOriginalTypeConstraintAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedParameterList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedParameterListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParameterListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedParameterListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedParameterList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedParameterListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedParameterList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedParameterListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedParameterListCore(mFullElement);
        	UnmatchedModifiedParameterListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParameterListCore(XElement, XElement)"/> is not executed and <see cref="MatchedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParameterListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParameterListCore(XElement, XElement)"/>.</param>
        partial void MatchedParameterListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParameterListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedParameterList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedParameterListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedParameterListCore(oFullElement, mFullElement);
        	MatchedParameterListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalParameterList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalParameterListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParameterListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalParameterListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalParameterListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalParameterList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalParameterListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalParameterListCore(oFullElement);
        	UnmatchedOriginalParameterListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BracketedParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBracketedParameterList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBracketedParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBracketedParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBracketedParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBracketedParameterListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBracketedParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBracketedParameterListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBracketedParameterListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBracketedParameterList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBracketedParameterListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBracketedParameterList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBracketedParameterListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBracketedParameterListCore(mFullElement);
        	UnmatchedModifiedBracketedParameterListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="MatchedBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBracketedParameterListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void MatchedBracketedParameterListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBracketedParameterListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBracketedParameterList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBracketedParameterListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBracketedParameterListCore(oFullElement, mFullElement);
        	MatchedBracketedParameterListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBracketedParameterList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBracketedParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBracketedParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBracketedParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBracketedParameterListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBracketedParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBracketedParameterListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBracketedParameterListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBracketedParameterListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBracketedParameterList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBracketedParameterListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBracketedParameterListCore(oFullElement);
        	UnmatchedOriginalBracketedParameterListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SkippedTokensTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSkippedTokensTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSkippedTokensTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSkippedTokensTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSkippedTokensTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSkippedTokensTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSkippedTokensTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSkippedTokensTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSkippedTokensTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSkippedTokensTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSkippedTokensTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSkippedTokensTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSkippedTokensTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSkippedTokensTriviaCore(mFullElement);
        	UnmatchedModifiedSkippedTokensTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSkippedTokensTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSkippedTokensTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedSkippedTokensTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSkippedTokensTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSkippedTokensTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedSkippedTokensTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSkippedTokensTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSkippedTokensTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSkippedTokensTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSkippedTokensTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSkippedTokensTriviaCore(oFullElement, mFullElement);
        	MatchedSkippedTokensTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSkippedTokensTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSkippedTokensTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSkippedTokensTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSkippedTokensTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSkippedTokensTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSkippedTokensTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSkippedTokensTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSkippedTokensTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSkippedTokensTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSkippedTokensTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSkippedTokensTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSkippedTokensTriviaCore(oFullElement);
        	UnmatchedOriginalSkippedTokensTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DocumentationCommentTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDocumentationCommentTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDocumentationCommentTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDocumentationCommentTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDocumentationCommentTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDocumentationCommentTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDocumentationCommentTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDocumentationCommentTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDocumentationCommentTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDocumentationCommentTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDocumentationCommentTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfComment");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDocumentationCommentTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDocumentationCommentTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDocumentationCommentTriviaCore(mFullElement);
        	UnmatchedModifiedDocumentationCommentTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDocumentationCommentTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDocumentationCommentTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedDocumentationCommentTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDocumentationCommentTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDocumentationCommentTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedDocumentationCommentTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDocumentationCommentTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDocumentationCommentTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfComment");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfComment");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDocumentationCommentTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDocumentationCommentTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDocumentationCommentTriviaCore(oFullElement, mFullElement);
        	MatchedDocumentationCommentTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDocumentationCommentTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDocumentationCommentTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDocumentationCommentTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDocumentationCommentTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDocumentationCommentTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDocumentationCommentTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDocumentationCommentTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDocumentationCommentTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDocumentationCommentTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfComment");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDocumentationCommentTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDocumentationCommentTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDocumentationCommentTriviaCore(oFullElement);
        	UnmatchedOriginalDocumentationCommentTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EndIfDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEndIfDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEndIfDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEndIfDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEndIfDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEndIfDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEndIfDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEndIfDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEndIfDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEndIfDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEndIfDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndIfKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEndIfDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEndIfDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEndIfDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedEndIfDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEndIfDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedEndIfDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEndIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEndIfDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndIfKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndIfKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEndIfDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEndIfDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEndIfDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedEndIfDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEndIfDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEndIfDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEndIfDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEndIfDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEndIfDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEndIfDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEndIfDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEndIfDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEndIfDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndIfKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEndIfDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEndIfDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEndIfDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalEndIfDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region RegionDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedRegionDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRegionDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedRegionDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedRegionDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedRegionDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedRegionDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRegionDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedRegionDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedRegionDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedRegionDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RegionKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedRegionDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedRegionDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedRegionDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedRegionDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRegionDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedRegionDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRegionDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RegionKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RegionKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedRegionDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedRegionDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedRegionDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedRegionDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalRegionDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRegionDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalRegionDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalRegionDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalRegionDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalRegionDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRegionDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalRegionDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalRegionDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RegionKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalRegionDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalRegionDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalRegionDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalRegionDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EndRegionDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEndRegionDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEndRegionDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEndRegionDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEndRegionDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEndRegionDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEndRegionDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEndRegionDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEndRegionDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEndRegionDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEndRegionDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndRegionKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEndRegionDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEndRegionDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEndRegionDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedEndRegionDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEndRegionDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEndRegionDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedEndRegionDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEndRegionDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEndRegionDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndRegionKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndRegionKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEndRegionDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEndRegionDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEndRegionDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedEndRegionDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEndRegionDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEndRegionDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEndRegionDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEndRegionDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEndRegionDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEndRegionDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEndRegionDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEndRegionDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEndRegionDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndRegionKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEndRegionDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEndRegionDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEndRegionDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalEndRegionDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ErrorDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedErrorDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedErrorDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedErrorDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedErrorDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedErrorDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedErrorDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedErrorDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedErrorDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedErrorDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedErrorDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ErrorKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedErrorDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedErrorDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedErrorDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedErrorDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedErrorDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedErrorDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedErrorDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedErrorDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedErrorDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedErrorDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedErrorDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedErrorDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ErrorKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ErrorKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedErrorDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedErrorDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedErrorDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedErrorDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalErrorDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalErrorDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalErrorDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalErrorDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalErrorDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalErrorDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalErrorDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalErrorDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalErrorDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ErrorKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalErrorDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalErrorDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalErrorDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalErrorDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region WarningDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedWarningDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWarningDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedWarningDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedWarningDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedWarningDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedWarningDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWarningDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedWarningDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedWarningDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedWarningDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedWarningDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedWarningDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedWarningDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedWarningDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWarningDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedWarningDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWarningDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedWarningDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedWarningDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedWarningDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedWarningDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalWarningDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWarningDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalWarningDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalWarningDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalWarningDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalWarningDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWarningDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalWarningDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalWarningDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalWarningDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalWarningDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalWarningDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalWarningDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BadDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBadDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBadDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBadDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBadDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBadDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBadDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBadDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBadDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBadDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBadDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBadDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBadDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBadDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedBadDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedBadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBadDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedBadDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBadDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBadDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBadDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBadDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedBadDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBadDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBadDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBadDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBadDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBadDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBadDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBadDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBadDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBadDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBadDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBadDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBadDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalBadDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DefineDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDefineDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefineDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDefineDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDefineDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDefineDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDefineDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefineDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDefineDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDefineDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefineDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DefineKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefineDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDefineDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDefineDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedDefineDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedDefineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefineDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedDefineDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefineDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DefineKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DefineKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDefineDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDefineDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDefineDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedDefineDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDefineDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefineDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDefineDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDefineDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDefineDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDefineDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefineDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDefineDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefineDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DefineKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefineDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDefineDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDefineDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalDefineDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region UndefDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedUndefDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUndefDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedUndefDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedUndefDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedUndefDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedUndefDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUndefDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedUndefDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedUndefDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedUndefDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UndefKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedUndefDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedUndefDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedUndefDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedUndefDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUndefDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUndefDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedUndefDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUndefDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUndefDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedUndefDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUndefDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUndefDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UndefKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UndefKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedUndefDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedUndefDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedUndefDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedUndefDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalUndefDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUndefDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalUndefDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalUndefDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalUndefDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalUndefDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUndefDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalUndefDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalUndefDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UndefKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalUndefDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalUndefDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalUndefDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalUndefDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LineDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLineDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLineDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLineDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLineDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLineDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLineDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLineDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLineDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLineDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLineDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LineKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Line");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLineDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLineDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLineDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedLineDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLineDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLineDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedLineDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLineDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLineDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedLineDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLineDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLineDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LineKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LineKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Line");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Line");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLineDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLineDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLineDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedLineDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLineDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLineDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLineDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLineDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLineDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLineDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLineDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLineDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLineDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LineKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Line");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLineDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLineDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLineDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalLineDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PragmaWarningDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPragmaWarningDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPragmaWarningDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPragmaWarningDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPragmaWarningDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPragmaWarningDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPragmaWarningDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPragmaWarningDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPragmaWarningDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPragmaWarningDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPragmaWarningDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DisableOrRestoreKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPragmaWarningDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPragmaWarningDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPragmaWarningDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedPragmaWarningDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPragmaWarningDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaWarningDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedPragmaWarningDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPragmaWarningDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPragmaWarningDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DisableOrRestoreKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DisableOrRestoreKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPragmaWarningDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPragmaWarningDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPragmaWarningDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedPragmaWarningDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPragmaWarningDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPragmaWarningDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPragmaWarningDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPragmaWarningDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPragmaWarningDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPragmaWarningDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPragmaWarningDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPragmaWarningDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPragmaWarningDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WarningKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DisableOrRestoreKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPragmaWarningDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPragmaWarningDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPragmaWarningDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalPragmaWarningDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PragmaChecksumDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPragmaChecksumDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPragmaChecksumDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPragmaChecksumDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPragmaChecksumDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPragmaChecksumDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPragmaChecksumDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPragmaChecksumDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPragmaChecksumDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPragmaChecksumDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPragmaChecksumDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ChecksumKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Guid");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Bytes");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPragmaChecksumDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPragmaChecksumDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPragmaChecksumDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedPragmaChecksumDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPragmaChecksumDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPragmaChecksumDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedPragmaChecksumDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPragmaChecksumDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPragmaChecksumDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ChecksumKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ChecksumKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Guid");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Guid");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Bytes");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Bytes");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPragmaChecksumDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPragmaChecksumDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPragmaChecksumDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedPragmaChecksumDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPragmaChecksumDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPragmaChecksumDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPragmaChecksumDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPragmaChecksumDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPragmaChecksumDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPragmaChecksumDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPragmaChecksumDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPragmaChecksumDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPragmaChecksumDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "PragmaKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ChecksumKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Guid");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Bytes");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPragmaChecksumDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPragmaChecksumDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPragmaChecksumDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalPragmaChecksumDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ReferenceDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedReferenceDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedReferenceDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedReferenceDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedReferenceDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedReferenceDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedReferenceDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedReferenceDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedReferenceDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedReferenceDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedReferenceDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReferenceKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedReferenceDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedReferenceDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedReferenceDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedReferenceDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedReferenceDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReferenceDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedReferenceDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedReferenceDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedReferenceDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReferenceKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReferenceKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedReferenceDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedReferenceDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedReferenceDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedReferenceDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalReferenceDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalReferenceDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalReferenceDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalReferenceDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalReferenceDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalReferenceDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalReferenceDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalReferenceDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalReferenceDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReferenceKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalReferenceDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalReferenceDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalReferenceDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalReferenceDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LoadDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLoadDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLoadDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLoadDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLoadDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLoadDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLoadDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLoadDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLoadDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLoadDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLoadDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LoadKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLoadDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLoadDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLoadDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedLoadDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLoadDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLoadDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedLoadDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLoadDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLoadDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedLoadDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLoadDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLoadDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LoadKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LoadKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLoadDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLoadDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLoadDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedLoadDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLoadDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLoadDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLoadDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLoadDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLoadDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLoadDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLoadDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLoadDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLoadDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LoadKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "File");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLoadDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLoadDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLoadDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalLoadDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ShebangDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedShebangDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedShebangDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedShebangDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedShebangDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedShebangDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedShebangDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedShebangDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedShebangDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedShebangDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedShebangDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExclamationToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedShebangDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedShebangDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedShebangDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedShebangDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedShebangDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedShebangDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedShebangDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedShebangDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedShebangDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedShebangDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedShebangDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedShebangDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExclamationToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExclamationToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedShebangDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedShebangDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedShebangDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedShebangDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalShebangDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalShebangDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalShebangDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalShebangDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalShebangDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalShebangDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalShebangDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalShebangDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalShebangDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ExclamationToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalShebangDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalShebangDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalShebangDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalShebangDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ElseDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedElseDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElseDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedElseDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedElseDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedElseDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedElseDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElseDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedElseDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedElseDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedElseDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedElseDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedElseDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedElseDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedElseDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElseDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedElseDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElseDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElseDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedElseDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElseDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElseDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedElseDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedElseDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedElseDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedElseDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalElseDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElseDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalElseDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalElseDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalElseDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalElseDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElseDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalElseDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalElseDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElseKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalElseDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalElseDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalElseDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalElseDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IfDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIfDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIfDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIfDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIfDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIfDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIfDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIfDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIfDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIfDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIfDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIfDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIfDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIfDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedIfDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIfDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedIfDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIfDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedIfDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIfDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIfDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIfDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIfDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIfDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedIfDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIfDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIfDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIfDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIfDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIfDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIfDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIfDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIfDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIfDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIfDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIfDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIfDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalIfDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ElifDirectiveTrivia
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedElifDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElifDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedElifDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedElifDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedElifDirectiveTriviaBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedElifDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElifDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedModifiedElifDirectiveTriviaAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedElifDirectiveTrivia(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedElifDirectiveTriviaCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElifKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedElifDirectiveTrivia(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedElifDirectiveTriviaBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedElifDirectiveTriviaCore(mFullElement);
        	UnmatchedModifiedElifDirectiveTriviaAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElifDirectiveTrivia(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElifDirectiveTrivia(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement)"/> is not executed and <see cref="MatchedElifDirectiveTrivia(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElifDirectiveTriviaBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElifDirectiveTriviaCore(XElement, XElement)"/>.</param>
        partial void MatchedElifDirectiveTriviaAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElifDirectiveTrivia(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElifDirectiveTriviaCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElifKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElifKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedElifDirectiveTrivia(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedElifDirectiveTriviaBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedElifDirectiveTriviaCore(oFullElement, mFullElement);
        	MatchedElifDirectiveTriviaAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalElifDirectiveTrivia(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElifDirectiveTrivia(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalElifDirectiveTriviaCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalElifDirectiveTrivia(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalElifDirectiveTriviaBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalElifDirectiveTriviaCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElifDirectiveTriviaCore(XElement)"/>.</param>
        partial void UnmatchedOriginalElifDirectiveTriviaAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalElifDirectiveTriviaCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "HashToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ElifKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndOfDirectiveToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalElifDirectiveTrivia(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalElifDirectiveTriviaBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalElifDirectiveTriviaCore(oFullElement);
        	UnmatchedOriginalElifDirectiveTriviaAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeCrefCore(mFullElement);
        	UnmatchedModifiedTypeCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeCrefCore(oFullElement, mFullElement);
        	MatchedTypeCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeCrefCore(oFullElement);
        	UnmatchedOriginalTypeCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region QualifiedCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedQualifiedCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQualifiedCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedQualifiedCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedQualifiedCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedQualifiedCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedQualifiedCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQualifiedCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedQualifiedCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedQualifiedCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedQualifiedCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedQualifiedCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedQualifiedCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedQualifiedCrefCore(mFullElement);
        	UnmatchedModifiedQualifiedCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQualifiedCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQualifiedCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedQualifiedCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQualifiedCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQualifiedCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedQualifiedCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQualifiedCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQualifiedCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedQualifiedCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedQualifiedCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedQualifiedCrefCore(oFullElement, mFullElement);
        	MatchedQualifiedCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalQualifiedCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQualifiedCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalQualifiedCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalQualifiedCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalQualifiedCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalQualifiedCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQualifiedCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalQualifiedCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalQualifiedCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalQualifiedCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalQualifiedCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalQualifiedCrefCore(oFullElement);
        	UnmatchedOriginalQualifiedCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region NameMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedNameMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedNameMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedNameMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedNameMemberCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedNameMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNameMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedNameMemberCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedNameMemberCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameMemberCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedNameMemberCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedNameMemberCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedNameMemberCrefCore(mFullElement);
        	UnmatchedModifiedNameMemberCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNameMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNameMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedNameMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNameMemberCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNameMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNameMemberCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedNameMemberCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNameMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNameMemberCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedNameMemberCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedNameMemberCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedNameMemberCrefCore(oFullElement, mFullElement);
        	MatchedNameMemberCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalNameMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalNameMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalNameMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalNameMemberCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalNameMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNameMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalNameMemberCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameMemberCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalNameMemberCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalNameMemberCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalNameMemberCrefCore(oFullElement);
        	UnmatchedOriginalNameMemberCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IndexerMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIndexerMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIndexerMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIndexerMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIndexerMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIndexerMemberCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIndexerMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIndexerMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIndexerMemberCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIndexerMemberCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIndexerMemberCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIndexerMemberCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIndexerMemberCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIndexerMemberCrefCore(mFullElement);
        	UnmatchedModifiedIndexerMemberCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIndexerMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIndexerMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedIndexerMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIndexerMemberCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIndexerMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIndexerMemberCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedIndexerMemberCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIndexerMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIndexerMemberCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIndexerMemberCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIndexerMemberCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIndexerMemberCrefCore(oFullElement, mFullElement);
        	MatchedIndexerMemberCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIndexerMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIndexerMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIndexerMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIndexerMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIndexerMemberCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIndexerMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIndexerMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIndexerMemberCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIndexerMemberCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThisKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIndexerMemberCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIndexerMemberCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIndexerMemberCrefCore(oFullElement);
        	UnmatchedOriginalIndexerMemberCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region OperatorMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOperatorMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOperatorMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOperatorMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOperatorMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOperatorMemberCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOperatorMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOperatorMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOperatorMemberCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOperatorMemberCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOperatorMemberCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOperatorMemberCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOperatorMemberCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOperatorMemberCrefCore(mFullElement);
        	UnmatchedModifiedOperatorMemberCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOperatorMemberCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedOperatorMemberCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOperatorMemberCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOperatorMemberCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOperatorMemberCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOperatorMemberCrefCore(oFullElement, mFullElement);
        	MatchedOperatorMemberCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOperatorMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOperatorMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOperatorMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOperatorMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOperatorMemberCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOperatorMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOperatorMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOperatorMemberCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOperatorMemberCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOperatorMemberCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOperatorMemberCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOperatorMemberCrefCore(oFullElement);
        	UnmatchedOriginalOperatorMemberCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConversionOperatorMemberCref
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConversionOperatorMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConversionOperatorMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConversionOperatorMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConversionOperatorMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConversionOperatorMemberCrefBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConversionOperatorMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConversionOperatorMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConversionOperatorMemberCrefAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConversionOperatorMemberCref(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConversionOperatorMemberCrefCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConversionOperatorMemberCref(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConversionOperatorMemberCrefBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConversionOperatorMemberCrefCore(mFullElement);
        	UnmatchedModifiedConversionOperatorMemberCrefAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConversionOperatorMemberCref(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorMemberCref(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement)"/> is not executed and <see cref="MatchedConversionOperatorMemberCref(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConversionOperatorMemberCrefBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConversionOperatorMemberCrefCore(XElement, XElement)"/>.</param>
        partial void MatchedConversionOperatorMemberCrefAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConversionOperatorMemberCref(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConversionOperatorMemberCrefCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConversionOperatorMemberCref(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConversionOperatorMemberCrefBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConversionOperatorMemberCrefCore(oFullElement, mFullElement);
        	MatchedConversionOperatorMemberCrefAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConversionOperatorMemberCref(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConversionOperatorMemberCref(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConversionOperatorMemberCrefCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConversionOperatorMemberCref(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConversionOperatorMemberCrefBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConversionOperatorMemberCrefCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConversionOperatorMemberCrefCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConversionOperatorMemberCrefAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConversionOperatorMemberCrefCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ImplicitOrExplicitKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConversionOperatorMemberCref(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConversionOperatorMemberCrefBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConversionOperatorMemberCrefCore(oFullElement);
        	UnmatchedOriginalConversionOperatorMemberCrefAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CrefParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCrefParameterList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCrefParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCrefParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCrefParameterListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCrefParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefParameterListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCrefParameterListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCrefParameterList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefParameterListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefParameterList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCrefParameterListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCrefParameterListCore(mFullElement);
        	UnmatchedModifiedCrefParameterListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefParameterListCore(XElement, XElement)"/> is not executed and <see cref="MatchedCrefParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefParameterListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefParameterListCore(XElement, XElement)"/>.</param>
        partial void MatchedCrefParameterListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefParameterListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCrefParameterList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCrefParameterListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCrefParameterListCore(oFullElement, mFullElement);
        	MatchedCrefParameterListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCrefParameterList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCrefParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCrefParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCrefParameterListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCrefParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefParameterListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCrefParameterListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefParameterListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefParameterList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCrefParameterListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCrefParameterListCore(oFullElement);
        	UnmatchedOriginalCrefParameterListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CrefBracketedParameterList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCrefBracketedParameterList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefBracketedParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCrefBracketedParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCrefBracketedParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCrefBracketedParameterListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCrefBracketedParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCrefBracketedParameterListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCrefBracketedParameterListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCrefBracketedParameterList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefBracketedParameterListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCrefBracketedParameterList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCrefBracketedParameterListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCrefBracketedParameterListCore(mFullElement);
        	UnmatchedModifiedCrefBracketedParameterListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCrefBracketedParameterList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefBracketedParameterList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement)"/> is not executed and <see cref="MatchedCrefBracketedParameterList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCrefBracketedParameterListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCrefBracketedParameterListCore(XElement, XElement)"/>.</param>
        partial void MatchedCrefBracketedParameterListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCrefBracketedParameterList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCrefBracketedParameterListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCrefBracketedParameterList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCrefBracketedParameterListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCrefBracketedParameterListCore(oFullElement, mFullElement);
        	MatchedCrefBracketedParameterListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCrefBracketedParameterList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefBracketedParameterList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCrefBracketedParameterListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCrefBracketedParameterList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCrefBracketedParameterListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCrefBracketedParameterListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCrefBracketedParameterListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCrefBracketedParameterListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefBracketedParameterListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCrefBracketedParameterList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCrefBracketedParameterListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCrefBracketedParameterListCore(oFullElement);
        	UnmatchedOriginalCrefBracketedParameterListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlElement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlElementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlElementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlElementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlElementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlElementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlElement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartTag");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndTag");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlElement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlElementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlElementCore(mFullElement);
        	UnmatchedModifiedXmlElementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlElementCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlElementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlElementCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlElementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlElementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartTag");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartTag");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndTag");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndTag");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlElement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlElementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlElementCore(oFullElement, mFullElement);
        	MatchedXmlElementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlElement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlElementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlElementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlElementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlElementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlElementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartTag");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndTag");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlElement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlElementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlElementCore(oFullElement);
        	UnmatchedOriginalXmlElementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlEmptyElement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlEmptyElement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlEmptyElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlEmptyElementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlEmptyElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlEmptyElementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlEmptyElementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlEmptyElementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlEmptyElementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlEmptyElement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlEmptyElementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SlashGreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlEmptyElement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlEmptyElementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlEmptyElementCore(mFullElement);
        	UnmatchedModifiedXmlEmptyElementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlEmptyElement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlEmptyElement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlEmptyElementCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlEmptyElement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlEmptyElementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlEmptyElementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlEmptyElementCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlEmptyElementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlEmptyElement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlEmptyElementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SlashGreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SlashGreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlEmptyElement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlEmptyElementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlEmptyElementCore(oFullElement, mFullElement);
        	MatchedXmlEmptyElementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlEmptyElement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlEmptyElement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlEmptyElementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlEmptyElement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlEmptyElementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlEmptyElementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlEmptyElementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlEmptyElementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlEmptyElementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SlashGreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlEmptyElement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlEmptyElementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlEmptyElementCore(oFullElement);
        	UnmatchedOriginalXmlEmptyElementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlText
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlText(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlText(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlTextCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlText(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlTextBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlTextCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlTextCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlTextAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlText(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlTextCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlText(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlTextBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlTextCore(mFullElement);
        	UnmatchedModifiedXmlTextAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlTextCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlTextBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlTextAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlTextCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlText(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlTextBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlTextCore(oFullElement, mFullElement);
        	MatchedXmlTextAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlText(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlText(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlTextCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlText(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlTextBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlTextCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlTextCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlTextAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlTextCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlText(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlTextBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlTextCore(oFullElement);
        	UnmatchedOriginalXmlTextAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlCDataSection
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlCDataSection(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlCDataSection(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlCDataSectionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlCDataSection(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlCDataSectionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlCDataSectionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlCDataSectionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlCDataSectionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlCDataSection(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlCDataSectionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartCDataToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndCDataToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlCDataSection(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlCDataSectionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlCDataSectionCore(mFullElement);
        	UnmatchedModifiedXmlCDataSectionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlCDataSection(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCDataSection(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCDataSectionCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlCDataSection(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCDataSectionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCDataSectionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCDataSectionCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlCDataSectionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlCDataSection(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCDataSectionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartCDataToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartCDataToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndCDataToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndCDataToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlCDataSection(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlCDataSectionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlCDataSectionCore(oFullElement, mFullElement);
        	MatchedXmlCDataSectionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlCDataSection(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlCDataSection(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlCDataSectionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlCDataSection(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlCDataSectionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlCDataSectionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlCDataSectionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlCDataSectionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlCDataSectionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartCDataToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndCDataToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlCDataSection(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlCDataSectionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlCDataSectionCore(oFullElement);
        	UnmatchedOriginalXmlCDataSectionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlProcessingInstruction
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlProcessingInstruction(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlProcessingInstruction(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlProcessingInstructionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlProcessingInstruction(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlProcessingInstructionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlProcessingInstructionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlProcessingInstructionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlProcessingInstructionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlProcessingInstruction(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlProcessingInstructionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartProcessingInstructionToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndProcessingInstructionToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlProcessingInstruction(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlProcessingInstructionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlProcessingInstructionCore(mFullElement);
        	UnmatchedModifiedXmlProcessingInstructionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlProcessingInstruction(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlProcessingInstruction(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlProcessingInstruction(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlProcessingInstructionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlProcessingInstructionCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlProcessingInstructionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlProcessingInstruction(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlProcessingInstructionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartProcessingInstructionToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartProcessingInstructionToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndProcessingInstructionToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndProcessingInstructionToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlProcessingInstruction(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlProcessingInstructionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlProcessingInstructionCore(oFullElement, mFullElement);
        	MatchedXmlProcessingInstructionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlProcessingInstruction(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlProcessingInstruction(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlProcessingInstructionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlProcessingInstruction(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlProcessingInstructionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlProcessingInstructionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlProcessingInstructionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlProcessingInstructionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlProcessingInstructionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartProcessingInstructionToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndProcessingInstructionToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlProcessingInstruction(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlProcessingInstructionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlProcessingInstructionCore(oFullElement);
        	UnmatchedOriginalXmlProcessingInstructionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlComment
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlComment(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlComment(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlCommentCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlComment(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlCommentBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlCommentCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlCommentCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlCommentAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlComment(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlCommentCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "MinusMinusGreaterThanToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlComment(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlCommentBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlCommentCore(mFullElement);
        	UnmatchedModifiedXmlCommentAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlComment(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlComment(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCommentCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlComment(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCommentBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCommentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCommentCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlCommentAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlComment(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCommentCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "MinusMinusGreaterThanToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "MinusMinusGreaterThanToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlComment(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlCommentBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlCommentCore(oFullElement, mFullElement);
        	MatchedXmlCommentAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlComment(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlComment(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlCommentCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlComment(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlCommentBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlCommentCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlCommentCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlCommentAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlCommentCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LessThanExclamationMinusMinusToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "MinusMinusGreaterThanToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlComment(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlCommentBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlCommentCore(oFullElement);
        	UnmatchedOriginalXmlCommentAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlTextAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlTextAttribute(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlTextAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlTextAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlTextAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlTextAttributeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlTextAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlTextAttributeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlTextAttributeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlTextAttribute(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlTextAttributeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlTextAttribute(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlTextAttributeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlTextAttributeCore(mFullElement);
        	UnmatchedModifiedXmlTextAttributeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlTextAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlTextAttributeCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlTextAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlTextAttributeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlTextAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlTextAttributeCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlTextAttributeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlTextAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlTextAttributeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlTextAttribute(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlTextAttributeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlTextAttributeCore(oFullElement, mFullElement);
        	MatchedXmlTextAttributeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlTextAttribute(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlTextAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlTextAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlTextAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlTextAttributeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlTextAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlTextAttributeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlTextAttributeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlTextAttributeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlTextAttribute(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlTextAttributeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlTextAttributeCore(oFullElement);
        	UnmatchedOriginalXmlTextAttributeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlCrefAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlCrefAttribute(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlCrefAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlCrefAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlCrefAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlCrefAttributeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlCrefAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlCrefAttributeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlCrefAttributeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlCrefAttribute(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlCrefAttributeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlCrefAttribute(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlCrefAttributeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlCrefAttributeCore(mFullElement);
        	UnmatchedModifiedXmlCrefAttributeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlCrefAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCrefAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlCrefAttributeCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlCrefAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlCrefAttributeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlCrefAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlCrefAttributeCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlCrefAttributeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlCrefAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlCrefAttributeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlCrefAttribute(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlCrefAttributeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlCrefAttributeCore(oFullElement, mFullElement);
        	MatchedXmlCrefAttributeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlCrefAttribute(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlCrefAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlCrefAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlCrefAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlCrefAttributeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlCrefAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlCrefAttributeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlCrefAttributeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlCrefAttributeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlCrefAttribute(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlCrefAttributeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlCrefAttributeCore(oFullElement);
        	UnmatchedOriginalXmlCrefAttributeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region XmlNameAttribute
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedXmlNameAttribute(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlNameAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedXmlNameAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedXmlNameAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedXmlNameAttributeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedXmlNameAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedXmlNameAttributeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedXmlNameAttributeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedXmlNameAttribute(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlNameAttributeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedXmlNameAttribute(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedXmlNameAttributeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedXmlNameAttributeCore(mFullElement);
        	UnmatchedModifiedXmlNameAttributeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedXmlNameAttribute(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameAttribute(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedXmlNameAttributeCore(XElement, XElement)"/> is not executed and <see cref="MatchedXmlNameAttribute(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedXmlNameAttributeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedXmlNameAttributeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedXmlNameAttributeCore(XElement, XElement)"/>.</param>
        partial void MatchedXmlNameAttributeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedXmlNameAttribute(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedXmlNameAttributeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedXmlNameAttribute(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedXmlNameAttributeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedXmlNameAttributeCore(oFullElement, mFullElement);
        	MatchedXmlNameAttributeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalXmlNameAttribute(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlNameAttribute(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalXmlNameAttributeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalXmlNameAttribute(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalXmlNameAttributeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalXmlNameAttributeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalXmlNameAttributeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalXmlNameAttributeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlNameAttributeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Name");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StartQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EndQuoteToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalXmlNameAttribute(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalXmlNameAttributeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalXmlNameAttributeCore(oFullElement);
        	UnmatchedOriginalXmlNameAttributeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ParenthesizedExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedParenthesizedExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedParenthesizedExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedParenthesizedExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedParenthesizedExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedParenthesizedExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedParenthesizedExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedParenthesizedExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedParenthesizedExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedParenthesizedExpressionCore(mFullElement);
        	UnmatchedModifiedParenthesizedExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedParenthesizedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedParenthesizedExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedParenthesizedExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedParenthesizedExpressionCore(oFullElement, mFullElement);
        	MatchedParenthesizedExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalParenthesizedExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalParenthesizedExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalParenthesizedExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalParenthesizedExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalParenthesizedExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalParenthesizedExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalParenthesizedExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalParenthesizedExpressionCore(oFullElement);
        	UnmatchedOriginalParenthesizedExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TupleExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTupleExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTupleExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTupleExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTupleExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTupleExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTupleExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTupleExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTupleExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTupleExpressionCore(mFullElement);
        	UnmatchedModifiedTupleExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedTupleExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedTupleExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTupleExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTupleExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTupleExpressionCore(oFullElement, mFullElement);
        	MatchedTupleExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTupleExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTupleExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTupleExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTupleExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTupleExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTupleExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTupleExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTupleExpressionCore(oFullElement);
        	UnmatchedOriginalTupleExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PrefixUnaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPrefixUnaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPrefixUnaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPrefixUnaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPrefixUnaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPrefixUnaryExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPrefixUnaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPrefixUnaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPrefixUnaryExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPrefixUnaryExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPrefixUnaryExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPrefixUnaryExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPrefixUnaryExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPrefixUnaryExpressionCore(mFullElement);
        	UnmatchedModifiedPrefixUnaryExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPrefixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPrefixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedPrefixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPrefixUnaryExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPrefixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedPrefixUnaryExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPrefixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPrefixUnaryExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPrefixUnaryExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPrefixUnaryExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPrefixUnaryExpressionCore(oFullElement, mFullElement);
        	MatchedPrefixUnaryExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPrefixUnaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPrefixUnaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPrefixUnaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPrefixUnaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPrefixUnaryExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPrefixUnaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPrefixUnaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPrefixUnaryExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPrefixUnaryExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPrefixUnaryExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPrefixUnaryExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPrefixUnaryExpressionCore(oFullElement);
        	UnmatchedOriginalPrefixUnaryExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AwaitExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAwaitExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAwaitExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAwaitExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAwaitExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAwaitExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAwaitExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAwaitExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAwaitExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAwaitExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAwaitExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AwaitKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAwaitExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAwaitExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAwaitExpressionCore(mFullElement);
        	UnmatchedModifiedAwaitExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAwaitExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAwaitExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAwaitExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedAwaitExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAwaitExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAwaitExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAwaitExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedAwaitExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAwaitExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAwaitExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AwaitKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AwaitKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAwaitExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAwaitExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAwaitExpressionCore(oFullElement, mFullElement);
        	MatchedAwaitExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAwaitExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAwaitExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAwaitExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAwaitExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAwaitExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAwaitExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAwaitExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAwaitExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAwaitExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AwaitKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAwaitExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAwaitExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAwaitExpressionCore(oFullElement);
        	UnmatchedOriginalAwaitExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PostfixUnaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPostfixUnaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPostfixUnaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPostfixUnaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPostfixUnaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPostfixUnaryExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPostfixUnaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPostfixUnaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPostfixUnaryExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPostfixUnaryExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPostfixUnaryExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPostfixUnaryExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPostfixUnaryExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPostfixUnaryExpressionCore(mFullElement);
        	UnmatchedModifiedPostfixUnaryExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPostfixUnaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPostfixUnaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedPostfixUnaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPostfixUnaryExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPostfixUnaryExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedPostfixUnaryExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPostfixUnaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPostfixUnaryExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPostfixUnaryExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPostfixUnaryExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPostfixUnaryExpressionCore(oFullElement, mFullElement);
        	MatchedPostfixUnaryExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPostfixUnaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPostfixUnaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPostfixUnaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPostfixUnaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPostfixUnaryExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPostfixUnaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPostfixUnaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPostfixUnaryExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPostfixUnaryExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPostfixUnaryExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPostfixUnaryExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPostfixUnaryExpressionCore(oFullElement);
        	UnmatchedOriginalPostfixUnaryExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region MemberAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedMemberAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMemberAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedMemberAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedMemberAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedMemberAccessExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedMemberAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMemberAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedMemberAccessExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedMemberAccessExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedMemberAccessExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedMemberAccessExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedMemberAccessExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedMemberAccessExpressionCore(mFullElement);
        	UnmatchedModifiedMemberAccessExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMemberAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMemberAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedMemberAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMemberAccessExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMemberAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedMemberAccessExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMemberAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMemberAccessExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedMemberAccessExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedMemberAccessExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedMemberAccessExpressionCore(oFullElement, mFullElement);
        	MatchedMemberAccessExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalMemberAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMemberAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalMemberAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalMemberAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalMemberAccessExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalMemberAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMemberAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalMemberAccessExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalMemberAccessExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalMemberAccessExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalMemberAccessExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalMemberAccessExpressionCore(oFullElement);
        	UnmatchedOriginalMemberAccessExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConditionalAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConditionalAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConditionalAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConditionalAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConditionalAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConditionalAccessExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConditionalAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConditionalAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConditionalAccessExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConditionalAccessExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConditionalAccessExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConditionalAccessExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConditionalAccessExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConditionalAccessExpressionCore(mFullElement);
        	UnmatchedModifiedConditionalAccessExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConditionalAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedConditionalAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConditionalAccessExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedConditionalAccessExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConditionalAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConditionalAccessExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConditionalAccessExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConditionalAccessExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConditionalAccessExpressionCore(oFullElement, mFullElement);
        	MatchedConditionalAccessExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConditionalAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConditionalAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConditionalAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConditionalAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConditionalAccessExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConditionalAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConditionalAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConditionalAccessExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConditionalAccessExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConditionalAccessExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConditionalAccessExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConditionalAccessExpressionCore(oFullElement);
        	UnmatchedOriginalConditionalAccessExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region MemberBindingExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedMemberBindingExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMemberBindingExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedMemberBindingExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedMemberBindingExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedMemberBindingExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedMemberBindingExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMemberBindingExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedMemberBindingExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedMemberBindingExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedMemberBindingExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedMemberBindingExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedMemberBindingExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedMemberBindingExpressionCore(mFullElement);
        	UnmatchedModifiedMemberBindingExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMemberBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMemberBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedMemberBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMemberBindingExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMemberBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMemberBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedMemberBindingExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMemberBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMemberBindingExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedMemberBindingExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedMemberBindingExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedMemberBindingExpressionCore(oFullElement, mFullElement);
        	MatchedMemberBindingExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalMemberBindingExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMemberBindingExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalMemberBindingExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalMemberBindingExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalMemberBindingExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalMemberBindingExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMemberBindingExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalMemberBindingExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalMemberBindingExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalMemberBindingExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalMemberBindingExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalMemberBindingExpressionCore(oFullElement);
        	UnmatchedOriginalMemberBindingExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ElementBindingExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedElementBindingExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElementBindingExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedElementBindingExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedElementBindingExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedElementBindingExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedElementBindingExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElementBindingExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedElementBindingExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedElementBindingExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedElementBindingExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedElementBindingExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedElementBindingExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedElementBindingExpressionCore(mFullElement);
        	UnmatchedModifiedElementBindingExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElementBindingExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementBindingExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElementBindingExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedElementBindingExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElementBindingExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElementBindingExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementBindingExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedElementBindingExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElementBindingExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElementBindingExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedElementBindingExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedElementBindingExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedElementBindingExpressionCore(oFullElement, mFullElement);
        	MatchedElementBindingExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalElementBindingExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElementBindingExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalElementBindingExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalElementBindingExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalElementBindingExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalElementBindingExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElementBindingExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalElementBindingExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalElementBindingExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalElementBindingExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalElementBindingExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalElementBindingExpressionCore(oFullElement);
        	UnmatchedOriginalElementBindingExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ImplicitElementAccess
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedImplicitElementAccess(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedImplicitElementAccess(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedImplicitElementAccessCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedImplicitElementAccess(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedImplicitElementAccessBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedImplicitElementAccessCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedImplicitElementAccessCore(XElement)"/>.</param>
        partial void UnmatchedModifiedImplicitElementAccessAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedImplicitElementAccess(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedImplicitElementAccessCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedImplicitElementAccess(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedImplicitElementAccessBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedImplicitElementAccessCore(mFullElement);
        	UnmatchedModifiedImplicitElementAccessAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedImplicitElementAccess(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitElementAccess(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedImplicitElementAccessCore(XElement, XElement)"/> is not executed and <see cref="MatchedImplicitElementAccess(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedImplicitElementAccessBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedImplicitElementAccessCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitElementAccessCore(XElement, XElement)"/>.</param>
        partial void MatchedImplicitElementAccessAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedImplicitElementAccess(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedImplicitElementAccessCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedImplicitElementAccess(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedImplicitElementAccessBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedImplicitElementAccessCore(oFullElement, mFullElement);
        	MatchedImplicitElementAccessAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalImplicitElementAccess(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalImplicitElementAccess(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalImplicitElementAccessCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalImplicitElementAccess(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalImplicitElementAccessBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalImplicitElementAccessCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalImplicitElementAccessCore(XElement)"/>.</param>
        partial void UnmatchedOriginalImplicitElementAccessAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalImplicitElementAccessCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalImplicitElementAccess(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalImplicitElementAccessBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalImplicitElementAccessCore(oFullElement);
        	UnmatchedOriginalImplicitElementAccessAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BinaryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBinaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBinaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBinaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBinaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBinaryExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBinaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBinaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBinaryExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBinaryExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBinaryExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBinaryExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBinaryExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBinaryExpressionCore(mFullElement);
        	UnmatchedModifiedBinaryExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBinaryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBinaryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBinaryExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedBinaryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBinaryExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBinaryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBinaryExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedBinaryExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBinaryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBinaryExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBinaryExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBinaryExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBinaryExpressionCore(oFullElement, mFullElement);
        	MatchedBinaryExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBinaryExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBinaryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBinaryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBinaryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBinaryExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBinaryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBinaryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBinaryExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBinaryExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBinaryExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBinaryExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBinaryExpressionCore(oFullElement);
        	UnmatchedOriginalBinaryExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AssignmentExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAssignmentExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAssignmentExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAssignmentExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAssignmentExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAssignmentExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAssignmentExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAssignmentExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAssignmentExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAssignmentExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAssignmentExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAssignmentExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAssignmentExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAssignmentExpressionCore(mFullElement);
        	UnmatchedModifiedAssignmentExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAssignmentExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAssignmentExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAssignmentExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedAssignmentExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAssignmentExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAssignmentExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAssignmentExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedAssignmentExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAssignmentExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAssignmentExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAssignmentExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAssignmentExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAssignmentExpressionCore(oFullElement, mFullElement);
        	MatchedAssignmentExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAssignmentExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAssignmentExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAssignmentExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAssignmentExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAssignmentExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAssignmentExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAssignmentExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAssignmentExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAssignmentExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OperatorToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAssignmentExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAssignmentExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAssignmentExpressionCore(oFullElement);
        	UnmatchedOriginalAssignmentExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConditionalExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConditionalExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConditionalExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConditionalExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConditionalExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConditionalExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConditionalExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConditionalExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConditionalExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConditionalExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConditionalExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConditionalExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConditionalExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConditionalExpressionCore(mFullElement);
        	UnmatchedModifiedConditionalExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConditionalExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConditionalExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedConditionalExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConditionalExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConditionalExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConditionalExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedConditionalExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConditionalExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConditionalExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConditionalExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConditionalExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConditionalExpressionCore(oFullElement, mFullElement);
        	MatchedConditionalExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConditionalExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConditionalExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConditionalExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConditionalExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConditionalExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConditionalExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConditionalExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConditionalExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConditionalExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConditionalExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConditionalExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConditionalExpressionCore(oFullElement);
        	UnmatchedOriginalConditionalExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LiteralExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLiteralExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLiteralExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLiteralExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLiteralExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLiteralExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLiteralExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLiteralExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLiteralExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLiteralExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLiteralExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLiteralExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLiteralExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLiteralExpressionCore(mFullElement);
        	UnmatchedModifiedLiteralExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLiteralExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLiteralExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLiteralExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedLiteralExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLiteralExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLiteralExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLiteralExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedLiteralExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLiteralExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLiteralExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLiteralExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLiteralExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLiteralExpressionCore(oFullElement, mFullElement);
        	MatchedLiteralExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLiteralExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLiteralExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLiteralExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLiteralExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLiteralExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLiteralExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLiteralExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLiteralExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLiteralExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLiteralExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLiteralExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLiteralExpressionCore(oFullElement);
        	UnmatchedOriginalLiteralExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region MakeRefExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedMakeRefExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMakeRefExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedMakeRefExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedMakeRefExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedMakeRefExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedMakeRefExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedMakeRefExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedMakeRefExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedMakeRefExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedMakeRefExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedMakeRefExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedMakeRefExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedMakeRefExpressionCore(mFullElement);
        	UnmatchedModifiedMakeRefExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedMakeRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMakeRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedMakeRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedMakeRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedMakeRefExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedMakeRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedMakeRefExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedMakeRefExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedMakeRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedMakeRefExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedMakeRefExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedMakeRefExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedMakeRefExpressionCore(oFullElement, mFullElement);
        	MatchedMakeRefExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalMakeRefExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMakeRefExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalMakeRefExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalMakeRefExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalMakeRefExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalMakeRefExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalMakeRefExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalMakeRefExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalMakeRefExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalMakeRefExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalMakeRefExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalMakeRefExpressionCore(oFullElement);
        	UnmatchedOriginalMakeRefExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region RefTypeExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedRefTypeExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefTypeExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedRefTypeExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedRefTypeExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedRefTypeExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedRefTypeExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefTypeExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedRefTypeExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedRefTypeExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefTypeExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefTypeExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedRefTypeExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedRefTypeExpressionCore(mFullElement);
        	UnmatchedModifiedRefTypeExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefTypeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefTypeExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedRefTypeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefTypeExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefTypeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedRefTypeExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefTypeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefTypeExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedRefTypeExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedRefTypeExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedRefTypeExpressionCore(oFullElement, mFullElement);
        	MatchedRefTypeExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalRefTypeExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefTypeExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalRefTypeExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalRefTypeExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalRefTypeExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalRefTypeExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefTypeExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalRefTypeExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefTypeExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefTypeExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalRefTypeExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalRefTypeExpressionCore(oFullElement);
        	UnmatchedOriginalRefTypeExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region RefValueExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedRefValueExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefValueExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedRefValueExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedRefValueExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedRefValueExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedRefValueExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefValueExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedRefValueExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedRefValueExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefValueExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Comma");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefValueExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedRefValueExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedRefValueExpressionCore(mFullElement);
        	UnmatchedModifiedRefValueExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefValueExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefValueExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefValueExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedRefValueExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefValueExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefValueExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefValueExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedRefValueExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefValueExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefValueExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Comma");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Comma");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedRefValueExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedRefValueExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedRefValueExpressionCore(oFullElement, mFullElement);
        	MatchedRefValueExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalRefValueExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefValueExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalRefValueExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalRefValueExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalRefValueExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalRefValueExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefValueExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalRefValueExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefValueExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Comma");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefValueExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalRefValueExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalRefValueExpressionCore(oFullElement);
        	UnmatchedOriginalRefValueExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CheckedExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCheckedExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCheckedExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCheckedExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCheckedExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCheckedExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCheckedExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCheckedExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCheckedExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCheckedExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCheckedExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCheckedExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCheckedExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCheckedExpressionCore(mFullElement);
        	UnmatchedModifiedCheckedExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCheckedExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCheckedExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedCheckedExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCheckedExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCheckedExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedCheckedExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCheckedExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCheckedExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCheckedExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCheckedExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCheckedExpressionCore(oFullElement, mFullElement);
        	MatchedCheckedExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCheckedExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCheckedExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCheckedExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCheckedExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCheckedExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCheckedExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCheckedExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCheckedExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCheckedExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCheckedExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCheckedExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCheckedExpressionCore(oFullElement);
        	UnmatchedOriginalCheckedExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DefaultExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDefaultExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefaultExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDefaultExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDefaultExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDefaultExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDefaultExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefaultExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDefaultExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDefaultExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefaultExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefaultExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDefaultExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDefaultExpressionCore(mFullElement);
        	UnmatchedModifiedDefaultExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefaultExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefaultExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedDefaultExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefaultExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefaultExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedDefaultExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefaultExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefaultExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDefaultExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDefaultExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDefaultExpressionCore(oFullElement, mFullElement);
        	MatchedDefaultExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDefaultExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefaultExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDefaultExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDefaultExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDefaultExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDefaultExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefaultExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDefaultExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefaultExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefaultExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDefaultExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDefaultExpressionCore(oFullElement);
        	UnmatchedOriginalDefaultExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TypeOfExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTypeOfExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeOfExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTypeOfExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTypeOfExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTypeOfExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTypeOfExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTypeOfExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTypeOfExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTypeOfExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeOfExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTypeOfExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTypeOfExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTypeOfExpressionCore(mFullElement);
        	UnmatchedModifiedTypeOfExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTypeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTypeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedTypeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTypeOfExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTypeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTypeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedTypeOfExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTypeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTypeOfExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTypeOfExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTypeOfExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTypeOfExpressionCore(oFullElement, mFullElement);
        	MatchedTypeOfExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTypeOfExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeOfExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTypeOfExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTypeOfExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTypeOfExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTypeOfExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTypeOfExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTypeOfExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeOfExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTypeOfExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTypeOfExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTypeOfExpressionCore(oFullElement);
        	UnmatchedOriginalTypeOfExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SizeOfExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSizeOfExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSizeOfExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSizeOfExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSizeOfExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSizeOfExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSizeOfExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSizeOfExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSizeOfExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSizeOfExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSizeOfExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSizeOfExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSizeOfExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSizeOfExpressionCore(mFullElement);
        	UnmatchedModifiedSizeOfExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSizeOfExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSizeOfExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSizeOfExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedSizeOfExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSizeOfExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSizeOfExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSizeOfExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedSizeOfExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSizeOfExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSizeOfExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSizeOfExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSizeOfExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSizeOfExpressionCore(oFullElement, mFullElement);
        	MatchedSizeOfExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSizeOfExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSizeOfExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSizeOfExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSizeOfExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSizeOfExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSizeOfExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSizeOfExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSizeOfExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSizeOfExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSizeOfExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSizeOfExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSizeOfExpressionCore(oFullElement);
        	UnmatchedOriginalSizeOfExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InvocationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInvocationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInvocationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInvocationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInvocationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInvocationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInvocationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInvocationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInvocationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInvocationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInvocationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInvocationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInvocationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInvocationExpressionCore(mFullElement);
        	UnmatchedModifiedInvocationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInvocationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInvocationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInvocationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedInvocationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInvocationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInvocationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInvocationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedInvocationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInvocationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInvocationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInvocationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInvocationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInvocationExpressionCore(oFullElement, mFullElement);
        	MatchedInvocationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInvocationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInvocationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInvocationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInvocationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInvocationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInvocationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInvocationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInvocationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInvocationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInvocationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInvocationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInvocationExpressionCore(oFullElement);
        	UnmatchedOriginalInvocationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ElementAccessExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedElementAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElementAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedElementAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedElementAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedElementAccessExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedElementAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedElementAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedElementAccessExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedElementAccessExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedElementAccessExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedElementAccessExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedElementAccessExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedElementAccessExpressionCore(mFullElement);
        	UnmatchedModifiedElementAccessExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedElementAccessExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementAccessExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedElementAccessExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedElementAccessExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedElementAccessExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedElementAccessExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedElementAccessExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedElementAccessExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedElementAccessExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedElementAccessExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedElementAccessExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedElementAccessExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedElementAccessExpressionCore(oFullElement, mFullElement);
        	MatchedElementAccessExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalElementAccessExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElementAccessExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalElementAccessExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalElementAccessExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalElementAccessExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalElementAccessExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalElementAccessExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalElementAccessExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalElementAccessExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalElementAccessExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalElementAccessExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalElementAccessExpressionCore(oFullElement);
        	UnmatchedOriginalElementAccessExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DeclarationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDeclarationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDeclarationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDeclarationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDeclarationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDeclarationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDeclarationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDeclarationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDeclarationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDeclarationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDeclarationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDeclarationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDeclarationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDeclarationExpressionCore(mFullElement);
        	UnmatchedModifiedDeclarationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDeclarationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDeclarationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedDeclarationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDeclarationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDeclarationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedDeclarationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDeclarationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDeclarationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDeclarationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDeclarationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDeclarationExpressionCore(oFullElement, mFullElement);
        	MatchedDeclarationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDeclarationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDeclarationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDeclarationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDeclarationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDeclarationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDeclarationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDeclarationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDeclarationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDeclarationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDeclarationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDeclarationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDeclarationExpressionCore(oFullElement);
        	UnmatchedOriginalDeclarationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CastExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCastExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCastExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCastExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCastExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCastExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCastExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCastExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCastExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCastExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCastExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCastExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCastExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCastExpressionCore(mFullElement);
        	UnmatchedModifiedCastExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCastExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCastExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCastExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedCastExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCastExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCastExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCastExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedCastExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCastExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCastExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCastExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCastExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCastExpressionCore(oFullElement, mFullElement);
        	MatchedCastExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCastExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCastExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCastExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCastExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCastExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCastExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCastExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCastExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCastExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCastExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCastExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCastExpressionCore(oFullElement);
        	UnmatchedOriginalCastExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region RefExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedRefExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedRefExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedRefExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedRefExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedRefExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedRefExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedRefExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedRefExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedRefExpressionCore(mFullElement);
        	UnmatchedModifiedRefExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedRefExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedRefExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedRefExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedRefExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedRefExpressionCore(oFullElement, mFullElement);
        	MatchedRefExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalRefExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalRefExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalRefExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalRefExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalRefExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalRefExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalRefExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalRefExpressionCore(oFullElement);
        	UnmatchedOriginalRefExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InitializerExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInitializerExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInitializerExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInitializerExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInitializerExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInitializerExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInitializerExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInitializerExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInitializerExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInitializerExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInitializerExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInitializerExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInitializerExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInitializerExpressionCore(mFullElement);
        	UnmatchedModifiedInitializerExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInitializerExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInitializerExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInitializerExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedInitializerExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInitializerExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInitializerExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInitializerExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedInitializerExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInitializerExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInitializerExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInitializerExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInitializerExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInitializerExpressionCore(oFullElement, mFullElement);
        	MatchedInitializerExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInitializerExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInitializerExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInitializerExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInitializerExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInitializerExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInitializerExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInitializerExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInitializerExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInitializerExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInitializerExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInitializerExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInitializerExpressionCore(oFullElement);
        	UnmatchedOriginalInitializerExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ObjectCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedObjectCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedObjectCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedObjectCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedObjectCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedObjectCreationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedObjectCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedObjectCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedObjectCreationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedObjectCreationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedObjectCreationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedObjectCreationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedObjectCreationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedObjectCreationExpressionCore(mFullElement);
        	UnmatchedModifiedObjectCreationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedObjectCreationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedObjectCreationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedObjectCreationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedObjectCreationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedObjectCreationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedObjectCreationExpressionCore(oFullElement, mFullElement);
        	MatchedObjectCreationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalObjectCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalObjectCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalObjectCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalObjectCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalObjectCreationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalObjectCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalObjectCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalObjectCreationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalObjectCreationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalObjectCreationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalObjectCreationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalObjectCreationExpressionCore(oFullElement);
        	UnmatchedOriginalObjectCreationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AnonymousObjectCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAnonymousObjectCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousObjectCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAnonymousObjectCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAnonymousObjectCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAnonymousObjectCreationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAnonymousObjectCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousObjectCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAnonymousObjectCreationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAnonymousObjectCreationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousObjectCreationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousObjectCreationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAnonymousObjectCreationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAnonymousObjectCreationExpressionCore(mFullElement);
        	UnmatchedModifiedAnonymousObjectCreationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousObjectCreationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousObjectCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedAnonymousObjectCreationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousObjectCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectCreationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousObjectCreationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAnonymousObjectCreationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAnonymousObjectCreationExpressionCore(oFullElement, mFullElement);
        	MatchedAnonymousObjectCreationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAnonymousObjectCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousObjectCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAnonymousObjectCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAnonymousObjectCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAnonymousObjectCreationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAnonymousObjectCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousObjectCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAnonymousObjectCreationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousObjectCreationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousObjectCreationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAnonymousObjectCreationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAnonymousObjectCreationExpressionCore(oFullElement);
        	UnmatchedOriginalAnonymousObjectCreationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArrayCreationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArrayCreationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArrayCreationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayCreationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayCreationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArrayCreationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArrayCreationExpressionCore(mFullElement);
        	UnmatchedModifiedArrayCreationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayCreationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedArrayCreationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayCreationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArrayCreationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArrayCreationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArrayCreationExpressionCore(oFullElement, mFullElement);
        	MatchedArrayCreationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArrayCreationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArrayCreationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayCreationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayCreationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArrayCreationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArrayCreationExpressionCore(oFullElement);
        	UnmatchedOriginalArrayCreationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ImplicitArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedImplicitArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedImplicitArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedImplicitArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedImplicitArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedImplicitArrayCreationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedImplicitArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedImplicitArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedImplicitArrayCreationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedImplicitArrayCreationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedImplicitArrayCreationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedImplicitArrayCreationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedImplicitArrayCreationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedImplicitArrayCreationExpressionCore(mFullElement);
        	UnmatchedModifiedImplicitArrayCreationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedImplicitArrayCreationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedImplicitArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedImplicitArrayCreationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedImplicitArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedImplicitArrayCreationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedImplicitArrayCreationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedImplicitArrayCreationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedImplicitArrayCreationExpressionCore(oFullElement, mFullElement);
        	MatchedImplicitArrayCreationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalImplicitArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalImplicitArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalImplicitArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalImplicitArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalImplicitArrayCreationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalImplicitArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalImplicitArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalImplicitArrayCreationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalImplicitArrayCreationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "NewKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalImplicitArrayCreationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalImplicitArrayCreationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalImplicitArrayCreationExpressionCore(oFullElement);
        	UnmatchedOriginalImplicitArrayCreationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region StackAllocArrayCreationExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedStackAllocArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedStackAllocArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedStackAllocArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedStackAllocArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedStackAllocArrayCreationExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedStackAllocArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedStackAllocArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedStackAllocArrayCreationExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedStackAllocArrayCreationExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedStackAllocArrayCreationExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StackAllocKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedStackAllocArrayCreationExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedStackAllocArrayCreationExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedStackAllocArrayCreationExpressionCore(mFullElement);
        	UnmatchedModifiedStackAllocArrayCreationExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedStackAllocArrayCreationExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedStackAllocArrayCreationExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedStackAllocArrayCreationExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedStackAllocArrayCreationExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedStackAllocArrayCreationExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StackAllocKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StackAllocKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedStackAllocArrayCreationExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedStackAllocArrayCreationExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedStackAllocArrayCreationExpressionCore(oFullElement, mFullElement);
        	MatchedStackAllocArrayCreationExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalStackAllocArrayCreationExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalStackAllocArrayCreationExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalStackAllocArrayCreationExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalStackAllocArrayCreationExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalStackAllocArrayCreationExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalStackAllocArrayCreationExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalStackAllocArrayCreationExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalStackAllocArrayCreationExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalStackAllocArrayCreationExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StackAllocKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalStackAllocArrayCreationExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalStackAllocArrayCreationExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalStackAllocArrayCreationExpressionCore(oFullElement);
        	UnmatchedOriginalStackAllocArrayCreationExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region QueryExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedQueryExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedQueryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedQueryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedQueryExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedQueryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQueryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedQueryExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedQueryExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedQueryExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedQueryExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedQueryExpressionCore(mFullElement);
        	UnmatchedModifiedQueryExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQueryExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQueryExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedQueryExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQueryExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQueryExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQueryExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedQueryExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQueryExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQueryExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedQueryExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedQueryExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedQueryExpressionCore(oFullElement, mFullElement);
        	MatchedQueryExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalQueryExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalQueryExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalQueryExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalQueryExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalQueryExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQueryExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalQueryExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalQueryExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalQueryExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalQueryExpressionCore(oFullElement);
        	UnmatchedOriginalQueryExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region OmittedArraySizeExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOmittedArraySizeExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOmittedArraySizeExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOmittedArraySizeExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOmittedArraySizeExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOmittedArraySizeExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOmittedArraySizeExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOmittedArraySizeExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOmittedArraySizeExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOmittedArraySizeExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOmittedArraySizeExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedArraySizeExpressionToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOmittedArraySizeExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOmittedArraySizeExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOmittedArraySizeExpressionCore(mFullElement);
        	UnmatchedModifiedOmittedArraySizeExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOmittedArraySizeExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedArraySizeExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedOmittedArraySizeExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOmittedArraySizeExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedArraySizeExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedOmittedArraySizeExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOmittedArraySizeExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOmittedArraySizeExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedArraySizeExpressionToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedArraySizeExpressionToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOmittedArraySizeExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOmittedArraySizeExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOmittedArraySizeExpressionCore(oFullElement, mFullElement);
        	MatchedOmittedArraySizeExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOmittedArraySizeExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOmittedArraySizeExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOmittedArraySizeExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOmittedArraySizeExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOmittedArraySizeExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOmittedArraySizeExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOmittedArraySizeExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOmittedArraySizeExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOmittedArraySizeExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedArraySizeExpressionToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOmittedArraySizeExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOmittedArraySizeExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOmittedArraySizeExpressionCore(oFullElement);
        	UnmatchedOriginalOmittedArraySizeExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InterpolatedStringExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterpolatedStringExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolatedStringExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterpolatedStringExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterpolatedStringExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterpolatedStringExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterpolatedStringExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolatedStringExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterpolatedStringExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterpolatedStringExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolatedStringExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringStartToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringEndToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolatedStringExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterpolatedStringExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterpolatedStringExpressionCore(mFullElement);
        	UnmatchedModifiedInterpolatedStringExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolatedStringExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterpolatedStringExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolatedStringExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedInterpolatedStringExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolatedStringExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringStartToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringStartToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringEndToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringEndToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterpolatedStringExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterpolatedStringExpressionCore(oFullElement, mFullElement);
        	MatchedInterpolatedStringExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterpolatedStringExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolatedStringExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterpolatedStringExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterpolatedStringExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterpolatedStringExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterpolatedStringExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolatedStringExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterpolatedStringExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolatedStringExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringStartToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "StringEndToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolatedStringExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterpolatedStringExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterpolatedStringExpressionCore(oFullElement);
        	UnmatchedOriginalInterpolatedStringExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IsPatternExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIsPatternExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIsPatternExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIsPatternExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIsPatternExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIsPatternExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIsPatternExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIsPatternExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIsPatternExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIsPatternExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIsPatternExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IsKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIsPatternExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIsPatternExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIsPatternExpressionCore(mFullElement);
        	UnmatchedModifiedIsPatternExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIsPatternExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIsPatternExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIsPatternExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedIsPatternExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIsPatternExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIsPatternExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIsPatternExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedIsPatternExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIsPatternExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIsPatternExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IsKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IsKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIsPatternExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIsPatternExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIsPatternExpressionCore(oFullElement, mFullElement);
        	MatchedIsPatternExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIsPatternExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIsPatternExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIsPatternExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIsPatternExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIsPatternExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIsPatternExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIsPatternExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIsPatternExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIsPatternExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IsKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIsPatternExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIsPatternExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIsPatternExpressionCore(oFullElement);
        	UnmatchedOriginalIsPatternExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ThrowExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedThrowExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThrowExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedThrowExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedThrowExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedThrowExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedThrowExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThrowExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedThrowExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedThrowExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedThrowExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedThrowExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedThrowExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedThrowExpressionCore(mFullElement);
        	UnmatchedModifiedThrowExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThrowExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThrowExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedThrowExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThrowExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThrowExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedThrowExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThrowExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThrowExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedThrowExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedThrowExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedThrowExpressionCore(oFullElement, mFullElement);
        	MatchedThrowExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalThrowExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThrowExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalThrowExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalThrowExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalThrowExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalThrowExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThrowExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalThrowExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalThrowExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalThrowExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalThrowExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalThrowExpressionCore(oFullElement);
        	UnmatchedOriginalThrowExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PredefinedType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPredefinedType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPredefinedType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPredefinedTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPredefinedType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPredefinedTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPredefinedTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPredefinedTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPredefinedTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPredefinedType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPredefinedTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPredefinedType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPredefinedTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPredefinedTypeCore(mFullElement);
        	UnmatchedModifiedPredefinedTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPredefinedType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPredefinedType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPredefinedTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedPredefinedType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPredefinedTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPredefinedTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPredefinedTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedPredefinedTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPredefinedType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPredefinedTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPredefinedType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPredefinedTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPredefinedTypeCore(oFullElement, mFullElement);
        	MatchedPredefinedTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPredefinedType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPredefinedType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPredefinedTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPredefinedType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPredefinedTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPredefinedTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPredefinedTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPredefinedTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPredefinedTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPredefinedType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPredefinedTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPredefinedTypeCore(oFullElement);
        	UnmatchedOriginalPredefinedTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ArrayType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArrayType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArrayTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArrayType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArrayTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArrayTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArrayTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArrayTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArrayType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArrayType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArrayTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArrayTypeCore(mFullElement);
        	UnmatchedModifiedArrayTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArrayType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArrayTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedArrayType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArrayTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArrayTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArrayTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedArrayTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArrayType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArrayTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArrayType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArrayTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArrayTypeCore(oFullElement, mFullElement);
        	MatchedArrayTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArrayType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArrayTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArrayType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArrayTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArrayTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArrayTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArrayTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArrayType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArrayTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArrayTypeCore(oFullElement);
        	UnmatchedOriginalArrayTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region PointerType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedPointerType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPointerType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedPointerTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedPointerType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedPointerTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedPointerTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedPointerTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedPointerTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedPointerType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedPointerTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsteriskToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedPointerType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedPointerTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedPointerTypeCore(mFullElement);
        	UnmatchedModifiedPointerTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedPointerType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPointerType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedPointerTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedPointerType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedPointerTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedPointerTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedPointerTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedPointerTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedPointerType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedPointerTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsteriskToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsteriskToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedPointerType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedPointerTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedPointerTypeCore(oFullElement, mFullElement);
        	MatchedPointerTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalPointerType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPointerType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalPointerTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalPointerType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalPointerTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalPointerTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalPointerTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalPointerTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalPointerTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsteriskToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalPointerType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalPointerTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalPointerTypeCore(oFullElement);
        	UnmatchedOriginalPointerTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region NullableType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedNullableType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNullableType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedNullableTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedNullableType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedNullableTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedNullableTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedNullableTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedNullableTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedNullableType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedNullableTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedNullableType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedNullableTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedNullableTypeCore(mFullElement);
        	UnmatchedModifiedNullableTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedNullableType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNullableType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedNullableTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedNullableType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedNullableTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedNullableTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedNullableTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedNullableTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedNullableType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedNullableTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedNullableType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedNullableTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedNullableTypeCore(oFullElement, mFullElement);
        	MatchedNullableTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalNullableType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNullableType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalNullableTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalNullableType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalNullableTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalNullableTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalNullableTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalNullableTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalNullableTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "QuestionToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalNullableType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalNullableTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalNullableTypeCore(oFullElement);
        	UnmatchedOriginalNullableTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TupleType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTupleType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTupleTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTupleType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTupleTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTupleTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTupleTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTupleTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTupleType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTupleType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTupleTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTupleTypeCore(mFullElement);
        	UnmatchedModifiedTupleTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTupleType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTupleTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedTupleType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTupleTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTupleTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTupleTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedTupleTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTupleType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTupleTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTupleType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTupleTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTupleTypeCore(oFullElement, mFullElement);
        	MatchedTupleTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTupleType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTupleTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTupleType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTupleTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTupleTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTupleTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTupleTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTupleType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTupleTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTupleTypeCore(oFullElement);
        	UnmatchedOriginalTupleTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region OmittedTypeArgument
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOmittedTypeArgument(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOmittedTypeArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOmittedTypeArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOmittedTypeArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOmittedTypeArgumentBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOmittedTypeArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOmittedTypeArgumentCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOmittedTypeArgumentAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOmittedTypeArgument(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOmittedTypeArgumentCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedTypeArgumentToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOmittedTypeArgument(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOmittedTypeArgumentBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOmittedTypeArgumentCore(mFullElement);
        	UnmatchedModifiedOmittedTypeArgumentAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOmittedTypeArgument(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedTypeArgument(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement)"/> is not executed and <see cref="MatchedOmittedTypeArgument(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOmittedTypeArgumentBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOmittedTypeArgumentCore(XElement, XElement)"/>.</param>
        partial void MatchedOmittedTypeArgumentAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOmittedTypeArgument(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOmittedTypeArgumentCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedTypeArgumentToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedTypeArgumentToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOmittedTypeArgument(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOmittedTypeArgumentBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOmittedTypeArgumentCore(oFullElement, mFullElement);
        	MatchedOmittedTypeArgumentAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOmittedTypeArgument(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOmittedTypeArgument(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOmittedTypeArgumentCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOmittedTypeArgument(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOmittedTypeArgumentBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOmittedTypeArgumentCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOmittedTypeArgumentCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOmittedTypeArgumentAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOmittedTypeArgumentCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OmittedTypeArgumentToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOmittedTypeArgument(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOmittedTypeArgumentBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOmittedTypeArgumentCore(oFullElement);
        	UnmatchedOriginalOmittedTypeArgumentAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region RefType
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedRefType(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedRefTypeCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedRefType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedRefTypeBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedRefTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedRefTypeCore(XElement)"/>.</param>
        partial void UnmatchedModifiedRefTypeAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedRefType(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefTypeCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReadOnlyKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedRefType(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedRefTypeBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedRefTypeCore(mFullElement);
        	UnmatchedModifiedRefTypeAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedRefType(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefType(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedRefTypeCore(XElement, XElement)"/> is not executed and <see cref="MatchedRefType(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedRefTypeBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedRefTypeCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedRefTypeCore(XElement, XElement)"/>.</param>
        partial void MatchedRefTypeAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedRefType(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedRefTypeCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReadOnlyKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReadOnlyKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedRefType(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedRefTypeBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedRefTypeCore(oFullElement, mFullElement);
        	MatchedRefTypeAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalRefType(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefType(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalRefTypeCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalRefType(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalRefTypeBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalRefTypeCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalRefTypeCore(XElement)"/>.</param>
        partial void UnmatchedOriginalRefTypeAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefTypeCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "RefKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReadOnlyKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalRefType(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalRefTypeBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalRefTypeCore(oFullElement);
        	UnmatchedOriginalRefTypeAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region QualifiedName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedQualifiedName(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQualifiedName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedQualifiedNameCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedQualifiedName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedQualifiedNameBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedQualifiedNameCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedQualifiedNameCore(XElement)"/>.</param>
        partial void UnmatchedModifiedQualifiedNameAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedQualifiedName(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedQualifiedNameCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedQualifiedName(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedQualifiedNameBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedQualifiedNameCore(mFullElement);
        	UnmatchedModifiedQualifiedNameAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="MatchedQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedQualifiedNameBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void MatchedQualifiedNameAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedQualifiedNameCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedQualifiedName(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedQualifiedNameBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedQualifiedNameCore(oFullElement, mFullElement);
        	MatchedQualifiedNameAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalQualifiedName(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQualifiedName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalQualifiedNameCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalQualifiedName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalQualifiedNameBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalQualifiedNameCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalQualifiedNameCore(XElement)"/>.</param>
        partial void UnmatchedOriginalQualifiedNameAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalQualifiedNameCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DotToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalQualifiedName(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalQualifiedNameBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalQualifiedNameCore(oFullElement);
        	UnmatchedOriginalQualifiedNameAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AliasQualifiedName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAliasQualifiedName(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAliasQualifiedName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAliasQualifiedNameCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAliasQualifiedName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAliasQualifiedNameBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAliasQualifiedNameCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAliasQualifiedNameCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAliasQualifiedNameAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAliasQualifiedName(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAliasQualifiedNameCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAliasQualifiedName(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAliasQualifiedNameBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAliasQualifiedNameCore(mFullElement);
        	UnmatchedModifiedAliasQualifiedNameAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAliasQualifiedName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAliasQualifiedName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAliasQualifiedNameCore(XElement, XElement)"/> is not executed and <see cref="MatchedAliasQualifiedName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAliasQualifiedNameBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAliasQualifiedNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAliasQualifiedNameCore(XElement, XElement)"/>.</param>
        partial void MatchedAliasQualifiedNameAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAliasQualifiedName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAliasQualifiedNameCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAliasQualifiedName(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAliasQualifiedNameBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAliasQualifiedNameCore(oFullElement, mFullElement);
        	MatchedAliasQualifiedNameAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAliasQualifiedName(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAliasQualifiedName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAliasQualifiedNameCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAliasQualifiedName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAliasQualifiedNameBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAliasQualifiedNameCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAliasQualifiedNameCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAliasQualifiedNameAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAliasQualifiedNameCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAliasQualifiedName(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAliasQualifiedNameBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAliasQualifiedNameCore(oFullElement);
        	UnmatchedOriginalAliasQualifiedNameAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IdentifierName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIdentifierName(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIdentifierName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIdentifierNameCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIdentifierName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIdentifierNameBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIdentifierNameCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIdentifierNameCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIdentifierNameAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIdentifierName(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIdentifierNameCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIdentifierName(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIdentifierNameBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIdentifierNameCore(mFullElement);
        	UnmatchedModifiedIdentifierNameAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIdentifierName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIdentifierName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIdentifierNameCore(XElement, XElement)"/> is not executed and <see cref="MatchedIdentifierName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIdentifierNameBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIdentifierNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIdentifierNameCore(XElement, XElement)"/>.</param>
        partial void MatchedIdentifierNameAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIdentifierName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIdentifierNameCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIdentifierName(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIdentifierNameBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIdentifierNameCore(oFullElement, mFullElement);
        	MatchedIdentifierNameAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIdentifierName(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIdentifierName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIdentifierNameCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIdentifierName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIdentifierNameBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIdentifierNameCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIdentifierNameCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIdentifierNameAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIdentifierNameCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIdentifierName(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIdentifierNameBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIdentifierNameCore(oFullElement);
        	UnmatchedOriginalIdentifierNameAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region GenericName
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedGenericName(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGenericName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedGenericNameCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedGenericName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedGenericNameBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedGenericNameCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGenericNameCore(XElement)"/>.</param>
        partial void UnmatchedModifiedGenericNameAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedGenericName(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedGenericNameCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedGenericName(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedGenericNameBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedGenericNameCore(mFullElement);
        	UnmatchedModifiedGenericNameAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGenericName(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGenericName(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGenericNameCore(XElement, XElement)"/> is not executed and <see cref="MatchedGenericName(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGenericNameBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGenericNameCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGenericNameCore(XElement, XElement)"/>.</param>
        partial void MatchedGenericNameAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGenericName(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGenericNameCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedGenericName(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedGenericNameBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedGenericNameCore(oFullElement, mFullElement);
        	MatchedGenericNameAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalGenericName(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGenericName(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalGenericNameCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalGenericName(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalGenericNameBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalGenericNameCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGenericNameCore(XElement)"/>.</param>
        partial void UnmatchedOriginalGenericNameAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalGenericNameCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalGenericName(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalGenericNameBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalGenericNameCore(oFullElement);
        	UnmatchedOriginalGenericNameAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ThisExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedThisExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThisExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedThisExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedThisExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedThisExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedThisExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThisExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedThisExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedThisExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedThisExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedThisExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedThisExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedThisExpressionCore(mFullElement);
        	UnmatchedModifiedThisExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThisExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThisExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThisExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedThisExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThisExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThisExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThisExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedThisExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThisExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThisExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedThisExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedThisExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedThisExpressionCore(oFullElement, mFullElement);
        	MatchedThisExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalThisExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThisExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalThisExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalThisExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalThisExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalThisExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThisExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalThisExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalThisExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalThisExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalThisExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalThisExpressionCore(oFullElement);
        	UnmatchedOriginalThisExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BaseExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBaseExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBaseExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBaseExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBaseExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBaseExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBaseExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBaseExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBaseExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBaseExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBaseExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBaseExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBaseExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBaseExpressionCore(mFullElement);
        	UnmatchedModifiedBaseExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBaseExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBaseExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedBaseExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBaseExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBaseExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBaseExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedBaseExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBaseExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBaseExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBaseExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBaseExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBaseExpressionCore(oFullElement, mFullElement);
        	MatchedBaseExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBaseExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBaseExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBaseExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBaseExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBaseExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBaseExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBaseExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBaseExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBaseExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Token");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBaseExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBaseExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBaseExpressionCore(oFullElement);
        	UnmatchedOriginalBaseExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region AnonymousMethodExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedAnonymousMethodExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousMethodExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedAnonymousMethodExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedAnonymousMethodExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedAnonymousMethodExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedAnonymousMethodExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedAnonymousMethodExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedAnonymousMethodExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedAnonymousMethodExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousMethodExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedAnonymousMethodExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedAnonymousMethodExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedAnonymousMethodExpressionCore(mFullElement);
        	UnmatchedModifiedAnonymousMethodExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedAnonymousMethodExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousMethodExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedAnonymousMethodExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedAnonymousMethodExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedAnonymousMethodExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedAnonymousMethodExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedAnonymousMethodExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedAnonymousMethodExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedAnonymousMethodExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedAnonymousMethodExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedAnonymousMethodExpressionCore(oFullElement, mFullElement);
        	MatchedAnonymousMethodExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalAnonymousMethodExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousMethodExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalAnonymousMethodExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalAnonymousMethodExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalAnonymousMethodExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalAnonymousMethodExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalAnonymousMethodExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalAnonymousMethodExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousMethodExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DelegateKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalAnonymousMethodExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalAnonymousMethodExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalAnonymousMethodExpressionCore(oFullElement);
        	UnmatchedOriginalAnonymousMethodExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SimpleLambdaExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSimpleLambdaExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSimpleLambdaExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSimpleLambdaExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSimpleLambdaExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSimpleLambdaExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSimpleLambdaExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSimpleLambdaExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSimpleLambdaExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSimpleLambdaExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSimpleLambdaExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSimpleLambdaExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSimpleLambdaExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSimpleLambdaExpressionCore(mFullElement);
        	UnmatchedModifiedSimpleLambdaExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSimpleLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedSimpleLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSimpleLambdaExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSimpleLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedSimpleLambdaExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSimpleLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSimpleLambdaExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSimpleLambdaExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSimpleLambdaExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSimpleLambdaExpressionCore(oFullElement, mFullElement);
        	MatchedSimpleLambdaExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSimpleLambdaExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSimpleLambdaExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSimpleLambdaExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSimpleLambdaExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSimpleLambdaExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSimpleLambdaExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSimpleLambdaExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSimpleLambdaExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSimpleLambdaExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSimpleLambdaExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSimpleLambdaExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSimpleLambdaExpressionCore(oFullElement);
        	UnmatchedOriginalSimpleLambdaExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ParenthesizedLambdaExpression
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedParenthesizedLambdaExpression(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedLambdaExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedParenthesizedLambdaExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedParenthesizedLambdaExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedParenthesizedLambdaExpressionBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedParenthesizedLambdaExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedLambdaExpressionCore(XElement)"/>.</param>
        partial void UnmatchedModifiedParenthesizedLambdaExpressionAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedParenthesizedLambdaExpression(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedLambdaExpressionCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedLambdaExpression(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedParenthesizedLambdaExpressionBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedParenthesizedLambdaExpressionCore(mFullElement);
        	UnmatchedModifiedParenthesizedLambdaExpressionAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement)"/> is not executed and <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedLambdaExpressionBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedLambdaExpressionCore(XElement, XElement)"/>.</param>
        partial void MatchedParenthesizedLambdaExpressionAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedLambdaExpression(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedLambdaExpressionCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedLambdaExpression(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedParenthesizedLambdaExpressionBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedParenthesizedLambdaExpressionCore(oFullElement, mFullElement);
        	MatchedParenthesizedLambdaExpressionAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalParenthesizedLambdaExpression(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedLambdaExpression(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalParenthesizedLambdaExpressionCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalParenthesizedLambdaExpression(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalParenthesizedLambdaExpressionBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalParenthesizedLambdaExpressionCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedLambdaExpressionCore(XElement)"/>.</param>
        partial void UnmatchedOriginalParenthesizedLambdaExpressionAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedLambdaExpressionCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "AsyncKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ArrowToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedLambdaExpression(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalParenthesizedLambdaExpressionBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalParenthesizedLambdaExpressionCore(oFullElement);
        	UnmatchedOriginalParenthesizedLambdaExpressionAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedArgumentListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedArgumentListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedArgumentList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedArgumentListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedArgumentList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedArgumentListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedArgumentListCore(mFullElement);
        	UnmatchedModifiedArgumentListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="MatchedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedArgumentListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedArgumentListCore(XElement, XElement)"/>.</param>
        partial void MatchedArgumentListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedArgumentListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedArgumentList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedArgumentListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedArgumentListCore(oFullElement, mFullElement);
        	MatchedArgumentListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalArgumentListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalArgumentListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalArgumentListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalArgumentList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalArgumentListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalArgumentListCore(oFullElement);
        	UnmatchedOriginalArgumentListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BracketedArgumentList
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBracketedArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBracketedArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBracketedArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBracketedArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBracketedArgumentListBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBracketedArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBracketedArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBracketedArgumentListAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBracketedArgumentList(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBracketedArgumentListCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBracketedArgumentList(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBracketedArgumentListBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBracketedArgumentListCore(mFullElement);
        	UnmatchedModifiedBracketedArgumentListAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBracketedArgumentList(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedArgumentList(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBracketedArgumentListCore(XElement, XElement)"/> is not executed and <see cref="MatchedBracketedArgumentList(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBracketedArgumentListBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBracketedArgumentListCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBracketedArgumentListCore(XElement, XElement)"/>.</param>
        partial void MatchedBracketedArgumentListAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBracketedArgumentList(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBracketedArgumentListCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBracketedArgumentList(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBracketedArgumentListBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBracketedArgumentListCore(oFullElement, mFullElement);
        	MatchedBracketedArgumentListAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBracketedArgumentList(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBracketedArgumentList(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBracketedArgumentListCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBracketedArgumentList(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBracketedArgumentListBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBracketedArgumentListCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBracketedArgumentListCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBracketedArgumentListAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBracketedArgumentListCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBracketToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBracketedArgumentList(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBracketedArgumentListBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBracketedArgumentListCore(oFullElement);
        	UnmatchedOriginalBracketedArgumentListAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region FromClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedFromClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFromClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedFromClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedFromClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedFromClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedFromClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFromClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedFromClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedFromClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedFromClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FromKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedFromClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedFromClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedFromClauseCore(mFullElement);
        	UnmatchedModifiedFromClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFromClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFromClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFromClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedFromClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFromClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFromClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFromClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedFromClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFromClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFromClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FromKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FromKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedFromClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedFromClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedFromClauseCore(oFullElement, mFullElement);
        	MatchedFromClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalFromClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFromClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalFromClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalFromClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalFromClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalFromClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFromClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalFromClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalFromClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FromKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalFromClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalFromClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalFromClauseCore(oFullElement);
        	UnmatchedOriginalFromClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LetClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLetClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLetClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLetClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLetClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLetClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLetClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLetClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLetClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLetClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLetClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LetKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLetClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLetClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLetClauseCore(mFullElement);
        	UnmatchedModifiedLetClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLetClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLetClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLetClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedLetClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLetClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLetClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLetClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedLetClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLetClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLetClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LetKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LetKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLetClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLetClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLetClauseCore(oFullElement, mFullElement);
        	MatchedLetClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLetClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLetClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLetClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLetClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLetClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLetClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLetClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLetClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLetClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LetKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLetClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLetClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLetClauseCore(oFullElement);
        	UnmatchedOriginalLetClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region JoinClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedJoinClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedJoinClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedJoinClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedJoinClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedJoinClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedJoinClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedJoinClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedJoinClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedJoinClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedJoinClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "JoinKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OnKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedJoinClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedJoinClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedJoinClauseCore(mFullElement);
        	UnmatchedModifiedJoinClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedJoinClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedJoinClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedJoinClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedJoinClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedJoinClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedJoinClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedJoinClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedJoinClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedJoinClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "JoinKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "JoinKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OnKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OnKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedJoinClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedJoinClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedJoinClauseCore(oFullElement, mFullElement);
        	MatchedJoinClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalJoinClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalJoinClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalJoinClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalJoinClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalJoinClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalJoinClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalJoinClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalJoinClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalJoinClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "JoinKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OnKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "EqualsKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalJoinClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalJoinClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalJoinClauseCore(oFullElement);
        	UnmatchedOriginalJoinClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region WhereClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedWhereClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhereClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedWhereClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedWhereClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedWhereClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedWhereClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhereClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedWhereClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedWhereClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhereClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhereClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedWhereClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedWhereClauseCore(mFullElement);
        	UnmatchedModifiedWhereClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhereClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhereClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhereClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedWhereClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhereClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhereClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhereClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedWhereClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhereClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhereClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedWhereClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedWhereClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedWhereClauseCore(oFullElement, mFullElement);
        	MatchedWhereClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalWhereClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhereClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalWhereClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalWhereClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalWhereClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalWhereClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhereClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalWhereClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhereClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhereKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhereClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalWhereClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalWhereClauseCore(oFullElement);
        	UnmatchedOriginalWhereClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region OrderByClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedOrderByClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOrderByClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedOrderByClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedOrderByClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedOrderByClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedOrderByClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedOrderByClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedOrderByClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedOrderByClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedOrderByClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OrderByKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedOrderByClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedOrderByClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedOrderByClauseCore(mFullElement);
        	UnmatchedModifiedOrderByClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedOrderByClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderByClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedOrderByClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedOrderByClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedOrderByClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedOrderByClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedOrderByClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedOrderByClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedOrderByClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedOrderByClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OrderByKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OrderByKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedOrderByClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedOrderByClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedOrderByClauseCore(oFullElement, mFullElement);
        	MatchedOrderByClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalOrderByClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOrderByClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalOrderByClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalOrderByClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalOrderByClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalOrderByClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalOrderByClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalOrderByClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalOrderByClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OrderByKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalOrderByClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalOrderByClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalOrderByClauseCore(oFullElement);
        	UnmatchedOriginalOrderByClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SelectClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSelectClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSelectClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSelectClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSelectClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSelectClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSelectClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSelectClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSelectClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSelectClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSelectClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SelectKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSelectClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSelectClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSelectClauseCore(mFullElement);
        	UnmatchedModifiedSelectClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSelectClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSelectClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSelectClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedSelectClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSelectClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSelectClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSelectClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedSelectClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSelectClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSelectClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SelectKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SelectKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSelectClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSelectClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSelectClauseCore(oFullElement, mFullElement);
        	MatchedSelectClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSelectClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSelectClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSelectClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSelectClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSelectClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSelectClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSelectClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSelectClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSelectClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SelectKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSelectClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSelectClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSelectClauseCore(oFullElement);
        	UnmatchedOriginalSelectClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region GroupClause
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedGroupClause(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGroupClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedGroupClauseCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedGroupClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedGroupClauseBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedGroupClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGroupClauseCore(XElement)"/>.</param>
        partial void UnmatchedModifiedGroupClauseAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedGroupClause(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedGroupClauseCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GroupKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ByKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedGroupClause(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedGroupClauseBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedGroupClauseCore(mFullElement);
        	UnmatchedModifiedGroupClauseAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGroupClause(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGroupClause(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGroupClauseCore(XElement, XElement)"/> is not executed and <see cref="MatchedGroupClause(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGroupClauseBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGroupClauseCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGroupClauseCore(XElement, XElement)"/>.</param>
        partial void MatchedGroupClauseAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGroupClause(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGroupClauseCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GroupKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GroupKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ByKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ByKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedGroupClause(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedGroupClauseBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedGroupClauseCore(oFullElement, mFullElement);
        	MatchedGroupClauseAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalGroupClause(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGroupClause(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalGroupClauseCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalGroupClause(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalGroupClauseBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalGroupClauseCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGroupClauseCore(XElement)"/>.</param>
        partial void UnmatchedOriginalGroupClauseAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalGroupClauseCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GroupKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ByKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalGroupClause(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalGroupClauseBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalGroupClauseCore(oFullElement);
        	UnmatchedOriginalGroupClauseAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DeclarationPattern
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDeclarationPattern(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDeclarationPattern(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDeclarationPatternCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDeclarationPattern(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDeclarationPatternBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDeclarationPatternCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDeclarationPatternCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDeclarationPatternAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDeclarationPattern(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDeclarationPatternCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDeclarationPattern(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDeclarationPatternBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDeclarationPatternCore(mFullElement);
        	UnmatchedModifiedDeclarationPatternAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDeclarationPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDeclarationPatternCore(XElement, XElement)"/> is not executed and <see cref="MatchedDeclarationPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDeclarationPatternBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDeclarationPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDeclarationPatternCore(XElement, XElement)"/>.</param>
        partial void MatchedDeclarationPatternAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDeclarationPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDeclarationPatternCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDeclarationPattern(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDeclarationPatternBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDeclarationPatternCore(oFullElement, mFullElement);
        	MatchedDeclarationPatternAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDeclarationPattern(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDeclarationPattern(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDeclarationPatternCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDeclarationPattern(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDeclarationPatternBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDeclarationPatternCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDeclarationPatternCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDeclarationPatternAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDeclarationPatternCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDeclarationPattern(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDeclarationPatternBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDeclarationPatternCore(oFullElement);
        	UnmatchedOriginalDeclarationPatternAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ConstantPattern
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedConstantPattern(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstantPattern(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedConstantPatternCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedConstantPattern(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedConstantPatternBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedConstantPatternCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedConstantPatternCore(XElement)"/>.</param>
        partial void UnmatchedModifiedConstantPatternAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedConstantPattern(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstantPatternCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedConstantPattern(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedConstantPatternBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedConstantPatternCore(mFullElement);
        	UnmatchedModifiedConstantPatternAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedConstantPattern(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstantPattern(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedConstantPatternCore(XElement, XElement)"/> is not executed and <see cref="MatchedConstantPattern(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedConstantPatternBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedConstantPatternCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedConstantPatternCore(XElement, XElement)"/>.</param>
        partial void MatchedConstantPatternAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedConstantPattern(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedConstantPatternCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedConstantPattern(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedConstantPatternBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedConstantPatternCore(oFullElement, mFullElement);
        	MatchedConstantPatternAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalConstantPattern(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstantPattern(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalConstantPatternCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalConstantPattern(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalConstantPatternBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalConstantPatternCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalConstantPatternCore(XElement)"/>.</param>
        partial void UnmatchedOriginalConstantPatternAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstantPatternCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalConstantPattern(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalConstantPatternBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalConstantPatternCore(oFullElement);
        	UnmatchedOriginalConstantPatternAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region InterpolatedStringText
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterpolatedStringText(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolatedStringText(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterpolatedStringTextCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterpolatedStringText(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterpolatedStringTextBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterpolatedStringTextCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolatedStringTextCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterpolatedStringTextAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterpolatedStringText(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolatedStringTextCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TextToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolatedStringText(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterpolatedStringTextBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterpolatedStringTextCore(mFullElement);
        	UnmatchedModifiedInterpolatedStringTextAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolatedStringText(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringText(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolatedStringTextCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterpolatedStringText(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolatedStringTextBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolatedStringTextCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolatedStringTextCore(XElement, XElement)"/>.</param>
        partial void MatchedInterpolatedStringTextAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolatedStringText(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringTextCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TextToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TextToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolatedStringText(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterpolatedStringTextBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterpolatedStringTextCore(oFullElement, mFullElement);
        	MatchedInterpolatedStringTextAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterpolatedStringText(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolatedStringText(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterpolatedStringTextCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterpolatedStringText(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterpolatedStringTextBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterpolatedStringTextCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolatedStringTextCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterpolatedStringTextAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolatedStringTextCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TextToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolatedStringText(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterpolatedStringTextBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterpolatedStringTextCore(oFullElement);
        	UnmatchedOriginalInterpolatedStringTextAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Interpolation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedInterpolation(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedInterpolationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedInterpolation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedInterpolationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedInterpolationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedInterpolationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedInterpolationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedInterpolation(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedInterpolation(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedInterpolationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedInterpolationCore(mFullElement);
        	UnmatchedModifiedInterpolationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedInterpolation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedInterpolationCore(XElement, XElement)"/> is not executed and <see cref="MatchedInterpolation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedInterpolationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedInterpolationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedInterpolationCore(XElement, XElement)"/>.</param>
        partial void MatchedInterpolationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedInterpolation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedInterpolationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedInterpolation(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedInterpolationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedInterpolationCore(oFullElement, mFullElement);
        	MatchedInterpolationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalInterpolation(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalInterpolationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalInterpolation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalInterpolationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalInterpolationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalInterpolationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalInterpolationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalInterpolation(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalInterpolationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalInterpolationCore(oFullElement);
        	UnmatchedOriginalInterpolationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region Block
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBlock(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBlock(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBlockCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBlock(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBlockBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBlockCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBlockCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBlockAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBlock(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBlockCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBlock(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBlockBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBlockCore(mFullElement);
        	UnmatchedModifiedBlockAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBlock(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBlock(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBlockCore(XElement, XElement)"/> is not executed and <see cref="MatchedBlock(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBlockBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBlockCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBlockCore(XElement, XElement)"/>.</param>
        partial void MatchedBlockAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBlock(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBlockCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBlock(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBlockBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBlockCore(oFullElement, mFullElement);
        	MatchedBlockAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBlock(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBlock(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBlockCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBlock(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBlockBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBlockCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBlockCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBlockAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBlockCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBlock(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBlockBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBlockCore(oFullElement);
        	UnmatchedOriginalBlockAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LocalFunctionStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLocalFunctionStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLocalFunctionStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLocalFunctionStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLocalFunctionStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLocalFunctionStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLocalFunctionStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLocalFunctionStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLocalFunctionStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLocalFunctionStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLocalFunctionStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLocalFunctionStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLocalFunctionStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLocalFunctionStatementCore(mFullElement);
        	UnmatchedModifiedLocalFunctionStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLocalFunctionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalFunctionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLocalFunctionStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedLocalFunctionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLocalFunctionStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLocalFunctionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalFunctionStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedLocalFunctionStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLocalFunctionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLocalFunctionStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLocalFunctionStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLocalFunctionStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLocalFunctionStatementCore(oFullElement, mFullElement);
        	MatchedLocalFunctionStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLocalFunctionStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLocalFunctionStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLocalFunctionStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLocalFunctionStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLocalFunctionStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLocalFunctionStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLocalFunctionStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLocalFunctionStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLocalFunctionStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLocalFunctionStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLocalFunctionStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLocalFunctionStatementCore(oFullElement);
        	UnmatchedOriginalLocalFunctionStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LocalDeclarationStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLocalDeclarationStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLocalDeclarationStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLocalDeclarationStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLocalDeclarationStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLocalDeclarationStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLocalDeclarationStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLocalDeclarationStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLocalDeclarationStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLocalDeclarationStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLocalDeclarationStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLocalDeclarationStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLocalDeclarationStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLocalDeclarationStatementCore(mFullElement);
        	UnmatchedModifiedLocalDeclarationStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLocalDeclarationStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalDeclarationStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedLocalDeclarationStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLocalDeclarationStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLocalDeclarationStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedLocalDeclarationStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLocalDeclarationStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLocalDeclarationStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLocalDeclarationStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLocalDeclarationStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLocalDeclarationStatementCore(oFullElement, mFullElement);
        	MatchedLocalDeclarationStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLocalDeclarationStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLocalDeclarationStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLocalDeclarationStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLocalDeclarationStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLocalDeclarationStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLocalDeclarationStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLocalDeclarationStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLocalDeclarationStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLocalDeclarationStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLocalDeclarationStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLocalDeclarationStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLocalDeclarationStatementCore(oFullElement);
        	UnmatchedOriginalLocalDeclarationStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ExpressionStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedExpressionStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExpressionStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedExpressionStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedExpressionStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedExpressionStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedExpressionStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedExpressionStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedExpressionStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedExpressionStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedExpressionStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedExpressionStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedExpressionStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedExpressionStatementCore(mFullElement);
        	UnmatchedModifiedExpressionStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedExpressionStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExpressionStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedExpressionStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedExpressionStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedExpressionStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedExpressionStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedExpressionStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedExpressionStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedExpressionStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedExpressionStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedExpressionStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedExpressionStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedExpressionStatementCore(oFullElement, mFullElement);
        	MatchedExpressionStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalExpressionStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExpressionStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalExpressionStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalExpressionStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalExpressionStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalExpressionStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalExpressionStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalExpressionStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalExpressionStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalExpressionStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalExpressionStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalExpressionStatementCore(oFullElement);
        	UnmatchedOriginalExpressionStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region EmptyStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedEmptyStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEmptyStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedEmptyStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedEmptyStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedEmptyStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedEmptyStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedEmptyStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedEmptyStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedEmptyStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedEmptyStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedEmptyStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedEmptyStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedEmptyStatementCore(mFullElement);
        	UnmatchedModifiedEmptyStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedEmptyStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEmptyStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedEmptyStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedEmptyStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedEmptyStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedEmptyStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedEmptyStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedEmptyStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedEmptyStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedEmptyStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedEmptyStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedEmptyStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedEmptyStatementCore(oFullElement, mFullElement);
        	MatchedEmptyStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalEmptyStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEmptyStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalEmptyStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalEmptyStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalEmptyStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalEmptyStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalEmptyStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalEmptyStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalEmptyStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalEmptyStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalEmptyStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalEmptyStatementCore(oFullElement);
        	UnmatchedOriginalEmptyStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LabeledStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLabeledStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLabeledStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLabeledStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLabeledStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLabeledStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLabeledStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLabeledStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLabeledStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLabeledStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLabeledStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLabeledStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLabeledStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLabeledStatementCore(mFullElement);
        	UnmatchedModifiedLabeledStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLabeledStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLabeledStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLabeledStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedLabeledStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLabeledStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLabeledStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLabeledStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedLabeledStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLabeledStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLabeledStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLabeledStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLabeledStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLabeledStatementCore(oFullElement, mFullElement);
        	MatchedLabeledStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLabeledStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLabeledStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLabeledStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLabeledStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLabeledStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLabeledStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLabeledStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLabeledStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLabeledStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLabeledStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLabeledStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLabeledStatementCore(oFullElement);
        	UnmatchedOriginalLabeledStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region GotoStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedGotoStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGotoStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedGotoStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedGotoStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedGotoStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedGotoStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedGotoStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedGotoStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedGotoStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedGotoStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GotoKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CaseOrDefaultKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedGotoStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedGotoStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedGotoStatementCore(mFullElement);
        	UnmatchedModifiedGotoStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedGotoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGotoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedGotoStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedGotoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedGotoStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedGotoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedGotoStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedGotoStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedGotoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedGotoStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GotoKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GotoKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CaseOrDefaultKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CaseOrDefaultKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedGotoStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedGotoStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedGotoStatementCore(oFullElement, mFullElement);
        	MatchedGotoStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalGotoStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGotoStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalGotoStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalGotoStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalGotoStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalGotoStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalGotoStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalGotoStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalGotoStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "GotoKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CaseOrDefaultKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalGotoStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalGotoStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalGotoStatementCore(oFullElement);
        	UnmatchedOriginalGotoStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region BreakStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedBreakStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBreakStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedBreakStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedBreakStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedBreakStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedBreakStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedBreakStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedBreakStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedBreakStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedBreakStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "BreakKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedBreakStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedBreakStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedBreakStatementCore(mFullElement);
        	UnmatchedModifiedBreakStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedBreakStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBreakStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedBreakStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedBreakStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedBreakStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedBreakStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedBreakStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedBreakStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedBreakStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedBreakStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "BreakKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "BreakKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedBreakStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedBreakStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedBreakStatementCore(oFullElement, mFullElement);
        	MatchedBreakStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalBreakStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBreakStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalBreakStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalBreakStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalBreakStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalBreakStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalBreakStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalBreakStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalBreakStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "BreakKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalBreakStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalBreakStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalBreakStatementCore(oFullElement);
        	UnmatchedOriginalBreakStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ContinueStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedContinueStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedContinueStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedContinueStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedContinueStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedContinueStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedContinueStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedContinueStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedContinueStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedContinueStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedContinueStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ContinueKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedContinueStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedContinueStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedContinueStatementCore(mFullElement);
        	UnmatchedModifiedContinueStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedContinueStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedContinueStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedContinueStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedContinueStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedContinueStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedContinueStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedContinueStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedContinueStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedContinueStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedContinueStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ContinueKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ContinueKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedContinueStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedContinueStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedContinueStatementCore(oFullElement, mFullElement);
        	MatchedContinueStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalContinueStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalContinueStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalContinueStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalContinueStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalContinueStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalContinueStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalContinueStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalContinueStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalContinueStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ContinueKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalContinueStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalContinueStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalContinueStatementCore(oFullElement);
        	UnmatchedOriginalContinueStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ReturnStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedReturnStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedReturnStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedReturnStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedReturnStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedReturnStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedReturnStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedReturnStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedReturnStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedReturnStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedReturnStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedReturnStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedReturnStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedReturnStatementCore(mFullElement);
        	UnmatchedModifiedReturnStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedReturnStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReturnStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedReturnStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedReturnStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedReturnStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedReturnStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedReturnStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedReturnStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedReturnStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedReturnStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedReturnStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedReturnStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedReturnStatementCore(oFullElement, mFullElement);
        	MatchedReturnStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalReturnStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalReturnStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalReturnStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalReturnStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalReturnStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalReturnStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalReturnStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalReturnStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalReturnStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalReturnStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalReturnStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalReturnStatementCore(oFullElement);
        	UnmatchedOriginalReturnStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ThrowStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedThrowStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThrowStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedThrowStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedThrowStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedThrowStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedThrowStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedThrowStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedThrowStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedThrowStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedThrowStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedThrowStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedThrowStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedThrowStatementCore(mFullElement);
        	UnmatchedModifiedThrowStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedThrowStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedThrowStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedThrowStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedThrowStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedThrowStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedThrowStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedThrowStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedThrowStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedThrowStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedThrowStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedThrowStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedThrowStatementCore(oFullElement, mFullElement);
        	MatchedThrowStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalThrowStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThrowStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalThrowStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalThrowStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalThrowStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalThrowStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalThrowStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalThrowStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalThrowStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ThrowKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalThrowStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalThrowStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalThrowStatementCore(oFullElement);
        	UnmatchedOriginalThrowStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region YieldStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedYieldStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedYieldStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedYieldStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedYieldStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedYieldStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedYieldStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedYieldStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedYieldStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedYieldStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedYieldStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "YieldKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnOrBreakKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedYieldStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedYieldStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedYieldStatementCore(mFullElement);
        	UnmatchedModifiedYieldStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedYieldStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedYieldStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedYieldStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedYieldStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedYieldStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedYieldStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedYieldStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedYieldStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedYieldStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedYieldStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "YieldKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "YieldKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnOrBreakKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnOrBreakKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedYieldStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedYieldStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedYieldStatementCore(oFullElement, mFullElement);
        	MatchedYieldStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalYieldStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalYieldStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalYieldStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalYieldStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalYieldStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalYieldStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalYieldStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalYieldStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalYieldStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "YieldKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ReturnOrBreakKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalYieldStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalYieldStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalYieldStatementCore(oFullElement);
        	UnmatchedOriginalYieldStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region WhileStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedWhileStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhileStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedWhileStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedWhileStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedWhileStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedWhileStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedWhileStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedWhileStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedWhileStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhileStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedWhileStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedWhileStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedWhileStatementCore(mFullElement);
        	UnmatchedModifiedWhileStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedWhileStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhileStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedWhileStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedWhileStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedWhileStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedWhileStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedWhileStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedWhileStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedWhileStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedWhileStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedWhileStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedWhileStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedWhileStatementCore(oFullElement, mFullElement);
        	MatchedWhileStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalWhileStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhileStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalWhileStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalWhileStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalWhileStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalWhileStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalWhileStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalWhileStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhileStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalWhileStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalWhileStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalWhileStatementCore(oFullElement);
        	UnmatchedOriginalWhileStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DoStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDoStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDoStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDoStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDoStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDoStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDoStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDoStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDoStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDoStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDoStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DoKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDoStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDoStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDoStatementCore(mFullElement);
        	UnmatchedModifiedDoStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDoStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDoStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDoStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedDoStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDoStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDoStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDoStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedDoStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDoStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDoStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DoKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DoKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDoStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDoStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDoStatementCore(oFullElement, mFullElement);
        	MatchedDoStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDoStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDoStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDoStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDoStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDoStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDoStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDoStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDoStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDoStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "DoKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "WhileKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDoStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDoStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDoStatementCore(oFullElement);
        	UnmatchedOriginalDoStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ForStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedForStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedForStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedForStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedForStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedForStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedForStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedForStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedForStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FirstSemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SecondSemicolonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedForStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedForStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedForStatementCore(mFullElement);
        	UnmatchedModifiedForStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedForStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedForStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FirstSemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FirstSemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SecondSemicolonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SecondSemicolonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedForStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedForStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedForStatementCore(oFullElement, mFullElement);
        	MatchedForStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalForStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalForStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalForStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalForStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalForStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalForStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalForStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FirstSemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SecondSemicolonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalForStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalForStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalForStatementCore(oFullElement);
        	UnmatchedOriginalForStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region UsingStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedUsingStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUsingStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedUsingStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedUsingStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedUsingStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedUsingStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUsingStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedUsingStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedUsingStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedUsingStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedUsingStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedUsingStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedUsingStatementCore(mFullElement);
        	UnmatchedModifiedUsingStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUsingStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUsingStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedUsingStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUsingStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUsingStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUsingStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedUsingStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUsingStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUsingStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedUsingStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedUsingStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedUsingStatementCore(oFullElement, mFullElement);
        	MatchedUsingStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalUsingStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUsingStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalUsingStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalUsingStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalUsingStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalUsingStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUsingStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalUsingStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalUsingStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UsingKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalUsingStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalUsingStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalUsingStatementCore(oFullElement);
        	UnmatchedOriginalUsingStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region FixedStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedFixedStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFixedStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedFixedStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedFixedStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedFixedStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedFixedStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedFixedStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedFixedStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedFixedStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedFixedStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FixedKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedFixedStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedFixedStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedFixedStatementCore(mFullElement);
        	UnmatchedModifiedFixedStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedFixedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFixedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedFixedStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedFixedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedFixedStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedFixedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedFixedStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedFixedStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedFixedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedFixedStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FixedKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FixedKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedFixedStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedFixedStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedFixedStatementCore(oFullElement, mFullElement);
        	MatchedFixedStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalFixedStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFixedStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalFixedStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalFixedStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalFixedStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalFixedStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalFixedStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalFixedStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalFixedStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "FixedKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalFixedStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalFixedStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalFixedStatementCore(oFullElement);
        	UnmatchedOriginalFixedStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CheckedStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCheckedStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCheckedStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCheckedStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCheckedStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCheckedStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCheckedStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCheckedStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCheckedStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCheckedStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCheckedStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCheckedStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCheckedStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCheckedStatementCore(mFullElement);
        	UnmatchedModifiedCheckedStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCheckedStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCheckedStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedCheckedStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCheckedStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCheckedStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCheckedStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedCheckedStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCheckedStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCheckedStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCheckedStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCheckedStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCheckedStatementCore(oFullElement, mFullElement);
        	MatchedCheckedStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCheckedStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCheckedStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCheckedStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCheckedStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCheckedStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCheckedStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCheckedStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCheckedStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCheckedStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCheckedStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCheckedStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCheckedStatementCore(oFullElement);
        	UnmatchedOriginalCheckedStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region UnsafeStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedUnsafeStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUnsafeStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedUnsafeStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedUnsafeStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedUnsafeStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedUnsafeStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedUnsafeStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedUnsafeStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedUnsafeStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedUnsafeStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnsafeKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedUnsafeStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedUnsafeStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedUnsafeStatementCore(mFullElement);
        	UnmatchedModifiedUnsafeStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedUnsafeStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUnsafeStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedUnsafeStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedUnsafeStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedUnsafeStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedUnsafeStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedUnsafeStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedUnsafeStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedUnsafeStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedUnsafeStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnsafeKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnsafeKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedUnsafeStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedUnsafeStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedUnsafeStatementCore(oFullElement, mFullElement);
        	MatchedUnsafeStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalUnsafeStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUnsafeStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalUnsafeStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalUnsafeStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalUnsafeStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalUnsafeStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalUnsafeStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalUnsafeStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalUnsafeStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnsafeKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalUnsafeStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalUnsafeStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalUnsafeStatementCore(oFullElement);
        	UnmatchedOriginalUnsafeStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region LockStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedLockStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLockStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedLockStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedLockStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedLockStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedLockStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedLockStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedLockStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedLockStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedLockStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LockKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedLockStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedLockStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedLockStatementCore(mFullElement);
        	UnmatchedModifiedLockStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedLockStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLockStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedLockStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedLockStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedLockStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedLockStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedLockStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedLockStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedLockStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedLockStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LockKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LockKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedLockStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedLockStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedLockStatementCore(oFullElement, mFullElement);
        	MatchedLockStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalLockStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLockStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalLockStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalLockStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalLockStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalLockStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalLockStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalLockStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalLockStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "LockKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalLockStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalLockStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalLockStatementCore(oFullElement);
        	UnmatchedOriginalLockStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region IfStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedIfStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIfStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedIfStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedIfStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedIfStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedIfStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedIfStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedIfStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedIfStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedIfStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedIfStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedIfStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedIfStatementCore(mFullElement);
        	UnmatchedModifiedIfStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedIfStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedIfStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedIfStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedIfStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedIfStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedIfStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedIfStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedIfStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedIfStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedIfStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedIfStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedIfStatementCore(oFullElement, mFullElement);
        	MatchedIfStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalIfStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIfStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalIfStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalIfStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalIfStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalIfStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalIfStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalIfStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalIfStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "IfKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalIfStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalIfStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalIfStatementCore(oFullElement);
        	UnmatchedOriginalIfStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SwitchStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSwitchStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSwitchStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSwitchStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSwitchStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSwitchStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSwitchStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSwitchStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSwitchStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSwitchStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSwitchStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SwitchKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSwitchStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSwitchStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSwitchStatementCore(mFullElement);
        	UnmatchedModifiedSwitchStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSwitchStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSwitchStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedSwitchStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSwitchStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSwitchStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSwitchStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedSwitchStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSwitchStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSwitchStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SwitchKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SwitchKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSwitchStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSwitchStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSwitchStatementCore(oFullElement, mFullElement);
        	MatchedSwitchStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSwitchStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSwitchStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSwitchStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSwitchStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSwitchStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSwitchStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSwitchStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSwitchStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSwitchStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "SwitchKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseBraceToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSwitchStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSwitchStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSwitchStatementCore(oFullElement);
        	UnmatchedOriginalSwitchStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region TryStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedTryStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTryStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedTryStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedTryStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedTryStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedTryStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedTryStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedTryStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedTryStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedTryStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TryKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedTryStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedTryStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedTryStatementCore(mFullElement);
        	UnmatchedModifiedTryStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedTryStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTryStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedTryStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedTryStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedTryStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedTryStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedTryStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedTryStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedTryStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedTryStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TryKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TryKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedTryStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedTryStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedTryStatementCore(oFullElement, mFullElement);
        	MatchedTryStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalTryStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTryStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalTryStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalTryStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalTryStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalTryStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalTryStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalTryStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalTryStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "TryKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalTryStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalTryStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalTryStatementCore(oFullElement);
        	UnmatchedOriginalTryStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ForEachStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedForEachStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForEachStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedForEachStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedForEachStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedForEachStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedForEachStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForEachStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedForEachStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedForEachStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedForEachStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedForEachStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedForEachStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedForEachStatementCore(mFullElement);
        	UnmatchedModifiedForEachStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForEachStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForEachStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedForEachStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForEachStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForEachStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedForEachStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForEachStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForEachStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedForEachStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedForEachStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedForEachStatementCore(oFullElement, mFullElement);
        	MatchedForEachStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalForEachStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForEachStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalForEachStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalForEachStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalForEachStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalForEachStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForEachStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalForEachStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalForEachStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalForEachStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalForEachStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalForEachStatementCore(oFullElement);
        	UnmatchedOriginalForEachStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ForEachVariableStatement
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedForEachVariableStatement(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForEachVariableStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedForEachVariableStatementCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedForEachVariableStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedForEachVariableStatementBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedForEachVariableStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedForEachVariableStatementCore(XElement)"/>.</param>
        partial void UnmatchedModifiedForEachVariableStatementAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedForEachVariableStatement(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedForEachVariableStatementCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedForEachVariableStatement(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedForEachVariableStatementBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedForEachVariableStatementCore(mFullElement);
        	UnmatchedModifiedForEachVariableStatementAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedForEachVariableStatement(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachVariableStatement(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedForEachVariableStatementCore(XElement, XElement)"/> is not executed and <see cref="MatchedForEachVariableStatement(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedForEachVariableStatementBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedForEachVariableStatementCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedForEachVariableStatementCore(XElement, XElement)"/>.</param>
        partial void MatchedForEachVariableStatementAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedForEachVariableStatement(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedForEachVariableStatementCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedForEachVariableStatement(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedForEachVariableStatementBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedForEachVariableStatementCore(oFullElement, mFullElement);
        	MatchedForEachVariableStatementAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalForEachVariableStatement(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForEachVariableStatement(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalForEachVariableStatementCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalForEachVariableStatement(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalForEachVariableStatementBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalForEachVariableStatementCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalForEachVariableStatementCore(XElement)"/>.</param>
        partial void UnmatchedOriginalForEachVariableStatementAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalForEachVariableStatementCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ForEachKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "InKeyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalForEachVariableStatement(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalForEachVariableStatementBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalForEachVariableStatementCore(oFullElement);
        	UnmatchedOriginalForEachVariableStatementAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region SingleVariableDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedSingleVariableDesignation(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSingleVariableDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedSingleVariableDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedSingleVariableDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedSingleVariableDesignationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedSingleVariableDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedSingleVariableDesignationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedSingleVariableDesignationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedSingleVariableDesignation(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedSingleVariableDesignationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedSingleVariableDesignation(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedSingleVariableDesignationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedSingleVariableDesignationCore(mFullElement);
        	UnmatchedModifiedSingleVariableDesignationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedSingleVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSingleVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedSingleVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="MatchedSingleVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedSingleVariableDesignationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedSingleVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedSingleVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void MatchedSingleVariableDesignationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedSingleVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedSingleVariableDesignationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedSingleVariableDesignation(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedSingleVariableDesignationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedSingleVariableDesignationCore(oFullElement, mFullElement);
        	MatchedSingleVariableDesignationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalSingleVariableDesignation(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSingleVariableDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalSingleVariableDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalSingleVariableDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalSingleVariableDesignationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalSingleVariableDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalSingleVariableDesignationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalSingleVariableDesignationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalSingleVariableDesignationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Identifier");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalSingleVariableDesignation(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalSingleVariableDesignationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalSingleVariableDesignationCore(oFullElement);
        	UnmatchedOriginalSingleVariableDesignationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DiscardDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDiscardDesignation(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDiscardDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDiscardDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDiscardDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDiscardDesignationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDiscardDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDiscardDesignationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDiscardDesignationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDiscardDesignation(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDiscardDesignationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnderscoreToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDiscardDesignation(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDiscardDesignationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDiscardDesignationCore(mFullElement);
        	UnmatchedModifiedDiscardDesignationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDiscardDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDiscardDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDiscardDesignationCore(XElement, XElement)"/> is not executed and <see cref="MatchedDiscardDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDiscardDesignationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDiscardDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDiscardDesignationCore(XElement, XElement)"/>.</param>
        partial void MatchedDiscardDesignationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDiscardDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDiscardDesignationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnderscoreToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnderscoreToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDiscardDesignation(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDiscardDesignationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDiscardDesignationCore(oFullElement, mFullElement);
        	MatchedDiscardDesignationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDiscardDesignation(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDiscardDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDiscardDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDiscardDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDiscardDesignationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDiscardDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDiscardDesignationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDiscardDesignationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDiscardDesignationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "UnderscoreToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDiscardDesignation(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDiscardDesignationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDiscardDesignationCore(oFullElement);
        	UnmatchedOriginalDiscardDesignationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region ParenthesizedVariableDesignation
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedParenthesizedVariableDesignation(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedVariableDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedParenthesizedVariableDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedParenthesizedVariableDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedParenthesizedVariableDesignationBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedParenthesizedVariableDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedParenthesizedVariableDesignationCore(XElement)"/>.</param>
        partial void UnmatchedModifiedParenthesizedVariableDesignationAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedParenthesizedVariableDesignation(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedVariableDesignationCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedParenthesizedVariableDesignation(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedParenthesizedVariableDesignationBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedParenthesizedVariableDesignationCore(mFullElement);
        	UnmatchedModifiedParenthesizedVariableDesignationAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement)"/> is not executed and <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedParenthesizedVariableDesignationBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedParenthesizedVariableDesignationCore(XElement, XElement)"/>.</param>
        partial void MatchedParenthesizedVariableDesignationAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedParenthesizedVariableDesignation(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedParenthesizedVariableDesignationCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedParenthesizedVariableDesignation(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedParenthesizedVariableDesignationBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedParenthesizedVariableDesignationCore(oFullElement, mFullElement);
        	MatchedParenthesizedVariableDesignationAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalParenthesizedVariableDesignation(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedVariableDesignation(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalParenthesizedVariableDesignationCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalParenthesizedVariableDesignation(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalParenthesizedVariableDesignationBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalParenthesizedVariableDesignationCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalParenthesizedVariableDesignationCore(XElement)"/>.</param>
        partial void UnmatchedOriginalParenthesizedVariableDesignationAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedVariableDesignationCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "OpenParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "CloseParenToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalParenthesizedVariableDesignation(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalParenthesizedVariableDesignationBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalParenthesizedVariableDesignationCore(oFullElement);
        	UnmatchedOriginalParenthesizedVariableDesignationAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CasePatternSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCasePatternSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCasePatternSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCasePatternSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCasePatternSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCasePatternSwitchLabelBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCasePatternSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCasePatternSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCasePatternSwitchLabelAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCasePatternSwitchLabel(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCasePatternSwitchLabelCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCasePatternSwitchLabel(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCasePatternSwitchLabelBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCasePatternSwitchLabelCore(mFullElement);
        	UnmatchedModifiedCasePatternSwitchLabelAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCasePatternSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCasePatternSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="MatchedCasePatternSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCasePatternSwitchLabelBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCasePatternSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void MatchedCasePatternSwitchLabelAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCasePatternSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCasePatternSwitchLabelCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCasePatternSwitchLabel(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCasePatternSwitchLabelBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCasePatternSwitchLabelCore(oFullElement, mFullElement);
        	MatchedCasePatternSwitchLabelAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCasePatternSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCasePatternSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCasePatternSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCasePatternSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCasePatternSwitchLabelBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCasePatternSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCasePatternSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCasePatternSwitchLabelAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCasePatternSwitchLabelCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCasePatternSwitchLabel(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCasePatternSwitchLabelBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCasePatternSwitchLabelCore(oFullElement);
        	UnmatchedOriginalCasePatternSwitchLabelAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region CaseSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedCaseSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCaseSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedCaseSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedCaseSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedCaseSwitchLabelBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedCaseSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedCaseSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedModifiedCaseSwitchLabelAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedCaseSwitchLabel(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedCaseSwitchLabelCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedCaseSwitchLabel(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedCaseSwitchLabelBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedCaseSwitchLabelCore(mFullElement);
        	UnmatchedModifiedCaseSwitchLabelAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedCaseSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCaseSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedCaseSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="MatchedCaseSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedCaseSwitchLabelBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedCaseSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedCaseSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void MatchedCaseSwitchLabelAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedCaseSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedCaseSwitchLabelCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedCaseSwitchLabel(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedCaseSwitchLabelBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedCaseSwitchLabelCore(oFullElement, mFullElement);
        	MatchedCaseSwitchLabelAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalCaseSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCaseSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalCaseSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalCaseSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalCaseSwitchLabelBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalCaseSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalCaseSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedOriginalCaseSwitchLabelAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalCaseSwitchLabelCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalCaseSwitchLabel(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalCaseSwitchLabelBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalCaseSwitchLabelCore(oFullElement);
        	UnmatchedOriginalCaseSwitchLabelAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    	#region DefaultSwitchLabel
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedModifiedDefaultSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefaultSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedModifiedDefaultSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedModifiedDefaultSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedModifiedDefaultSwitchLabelBefore(XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedModifiedDefaultSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedModifiedDefaultSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedModifiedDefaultSwitchLabelAfter(XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedModifiedDefaultSwitchLabel(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefaultSwitchLabelCore(XElement mFullElement)
    	{
    		if(mFullElement == null)
    			throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement child = null;
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		child = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Insert(child, mFullElement);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched modified element existing in the seed delta. 
        /// </summary>
        /// <param name="mFullElement">The full description associated to the unmatched modified element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedModifiedDefaultSwitchLabel(XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedModifiedDefaultSwitchLabelBefore(mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedModifiedDefaultSwitchLabelCore(mFullElement);
        	UnmatchedModifiedDefaultSwitchLabelAfter(mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="MatchedDefaultSwitchLabel(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultSwitchLabel(XElement, XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement)"/> is not executed and <see cref="MatchedDefaultSwitchLabel(XElement, XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void MatchedDefaultSwitchLabelBefore(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="MatchedDefaultSwitchLabelCore(XElement, XElement)"/>.</param>
        partial void MatchedDefaultSwitchLabelAfter(XElement oFullElement, XElement mFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="MatchedDefaultSwitchLabel(XElement, XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> MatchedDefaultSwitchLabelCore(XElement oFullElement, XElement mFullElement)
    	{
    		if(oFullElement == null) throw new ArgumentNullException(nameof(oFullElement));
    		if(mFullElement == null) throw new ArgumentNullException(nameof(mFullElement));
    
    		XElement oChild = null, mChild = null;
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		oChild = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		mChild = mFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(oChild == null && mChild != null)
    			yield return this.Insert(mChild, oFullElement);
    		else if(oChild != null && mChild == null)
    			yield return this.Delete(oChild);
    		else if(oChild != null && mChild != null)
    		{
    			var match = this.MatchIfAvailable(oChild, mChild);
    			if(match != null)
    			{
    				yield return match;
    
    				if(oChild.Elements().Count() == 0 && mChild.Elements().Count() == 0 && oChild.Value != mChild.Value)
    					yield return this.Update(oChild, mChild);
    			}
    		}
    		
    		yield break;
    	}		
        
        /// <summary>
        /// Computes the expandable changes starting from an matched element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the matched original element version.</param>
        /// <param name="mFullElement">The full description associated to the unmatched modified element version.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> MatchedDefaultSwitchLabel(XElement oFullElement, XElement mFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	MatchedDefaultSwitchLabelBefore(oFullElement, mFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.MatchedDefaultSwitchLabelCore(oFullElement, mFullElement);
        	MatchedDefaultSwitchLabelAfter(oFullElement, mFullElement, ref result);
        	return result;
        }
    
    	/// <summary>
        /// Method hook for implementing logic to execute before the <see cref="UnmatchedOriginalDefaultSwitchLabel(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefaultSwitchLabel(XElement)"/>.</param>
        /// <param name="ignoreCore">If true, the <see cref="UnmatchedOriginalDefaultSwitchLabelCore(XElement)"/> is not executed and <see cref="UnmatchedOriginalDefaultSwitchLabel(XElement)"/> returns the current value of <paramref name="result"/>.</param>
        partial void UnmatchedOriginalDefaultSwitchLabelBefore(XElement oFullElement, ref IEnumerable<XElement> result, ref bool ignoreCore);
    
        /// <summary>
        /// Method hook for implementing logic to execute after the <see cref="UnmatchedOriginalDefaultSwitchLabelCore(XElement)"/>.
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <param name="result">Mechanism to modify the result of <see cref="UnmatchedOriginalDefaultSwitchLabelCore(XElement)"/>.</param>
        partial void UnmatchedOriginalDefaultSwitchLabelAfter(XElement oFullElement, ref IEnumerable<XElement> result);
        
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        /// <remarks>This is the default implementation for <see cref="UnmatchedOriginal(XElement)"/>.</remarks>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefaultSwitchLabelCore(XElement oFullElement)
    	{
    		if(oFullElement == null)
    			throw new ArgumentNullException(nameof(oFullElement));
    
    		XElement child = null;
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "Keyword");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		child = oFullElement.Elements().SingleOrDefault(c => c.Attribute("part")?.Value == "ColonToken");
    		if(child != null)
    			yield return this.Delete(child);
    		
    		yield break;
    	}		
    	
        /// <summary>
        /// Computes the expandable changes starting from an unmatched original element existing in the seed delta. 
        /// </summary>
        /// <param name="oFullElement">The full description associated to the unmatched original element.</param>
        /// <returns>The expanded matches and actions.</returns>
        public virtual IEnumerable<XElement> UnmatchedOriginalDefaultSwitchLabel(XElement oFullElement)
        {
            IEnumerable<XElement> result = new XElement[0];
        	var ignoreCore = false;
        	UnmatchedOriginalDefaultSwitchLabelBefore(oFullElement, ref result, ref ignoreCore);
        	if(ignoreCore) 
        		return result;
        	
        	result = this.UnmatchedOriginalDefaultSwitchLabelCore(oFullElement);
        	UnmatchedOriginalDefaultSwitchLabelAfter(oFullElement, ref result);
        	return result;
        }
    
    	#endregion
    
    }
}
// Generated helper templates
// Generated items
